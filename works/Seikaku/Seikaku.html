<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DeepProfile AI | 超精密性格プロファイリング</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=Noto+Sans+JP:wght@400;500;700;900&display=swap');
    
    body {
      font-family: 'Inter', 'Noto Sans JP', sans-serif;
    }

    .glass {
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .fade-in { animation: fadeIn 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
    .slide-up { animation: slideUp 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards; }

    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes slideUp { 
      from { opacity: 0; transform: translateY(20px); } 
      to { opacity: 1; transform: translateY(0); } 
    }

    .loader-ring {
      border: 3px solid rgba(99, 102, 241, 0.1);
      border-top: 3px solid #6366f1;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      animation: spin 1s cubic-bezier(0.55, 0.1, 0.15, 0.9) infinite;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    .radar-polygon {
      transition: all 0.5s ease;
    }

    .panel-strong {
      border: 1px solid rgba(148, 163, 184, 0.35);
      box-shadow:
        0 20px 44px -30px rgba(15, 23, 42, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.95);
    }

    .feature-card {
      position: relative;
      background: rgba(255, 255, 255, 0.88);
      border: 1px solid rgba(148, 163, 184, 0.3);
      box-shadow: 0 14px 28px -24px rgba(15, 23, 42, 0.55);
    }

    .feature-card::before {
      content: "";
      position: absolute;
      top: 0.7rem;
      left: 1rem;
      right: 1rem;
      height: 3px;
      border-radius: 999px;
      background: var(--feature-accent, #6366f1);
      opacity: 0.9;
    }
  </style>
</head>
<body class="min-h-screen bg-[#f8fafc] text-slate-900 selection:bg-indigo-100 overflow-x-hidden relative">
  
  <!-- Background Decorations -->
  <div class="fixed inset-0 -z-10 overflow-hidden pointer-events-none">
    <div class="absolute -top-[10%] -left-[10%] w-[40%] h-[40%] bg-indigo-100 rounded-full blur-[120px] opacity-50"></div>
    <div class="absolute top-[40%] -right-[10%] w-[35%] h-[35%] bg-purple-100 rounded-full blur-[120px] opacity-40"></div>
  </div>

  <div class="max-w-4xl mx-auto px-4 py-8 md:py-12">
    
    <!-- Header -->
    <header class="flex items-center justify-between mb-10 slide-up">
      <div class="flex items-center gap-3">
        <div class="bg-indigo-600 p-2.5 rounded-2xl text-white shadow-lg shadow-indigo-200 cursor-pointer" onclick="resetApp()">
          <i data-lucide="brain-circuit" class="w-6 h-6"></i>
        </div>
        <div>
          <h1 class="text-xl font-black tracking-tight text-slate-800">DeepProfile <span class="text-indigo-600">AI</span></h1>
          <p class="text-[10px] font-bold text-slate-400 uppercase tracking-widest leading-none mt-1">Version 3.0 Auto-Sync</p>
        </div>
      </div>
      
      <div id="user-status" class="flex items-center gap-3">
        <button id="auth-btn" class="px-3 py-1.5 rounded-lg border border-slate-200 text-xs font-bold text-slate-700 hover:bg-slate-50 transition-colors">
          Googleでログイン
        </button>
        <div class="hidden sm:flex flex-col items-end">
          <span class="text-[10px] font-bold text-slate-400 uppercase tracking-tighter">Your ID</span>
          <span id="display-uid" class="text-[11px] font-mono text-slate-500 bg-slate-100 px-2 py-0.5 rounded">Connecting...</span>
        </div>
        <div id="phase-badge" class="hidden text-xs font-bold text-indigo-600 bg-indigo-50 border border-indigo-100 px-4 py-1.5 rounded-full">
          Phase 1
        </div>
      </div>
    </header>

    <main id="app-container" class="transition-all duration-500">
      
      <!-- Screen: Intro -->
      <div id="screen-intro" class="fade-in space-y-8">
        <div class="bg-white rounded-[2.5rem] p-8 md:p-12 shadow-xl shadow-indigo-100/50 border border-slate-100 relative overflow-hidden panel-strong">
          <div class="absolute top-0 right-0 p-8 opacity-10">
            <i data-lucide="sparkles" class="w-32 h-32 text-indigo-600"></i>
          </div>

          <div class="relative z-10 space-y-6 max-w-2xl">
            <h2 class="text-4xl md:text-5xl font-black tracking-tight text-slate-900 leading-[1.1]">
              MBTIを超える、<br/><span class="text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-purple-600">あなたの「真実」を暴く。</span>
            </h2>
            <p class="text-slate-500 leading-relaxed text-lg">
              最新のBIG5理論とAI解析を統合。16問の設問と、AIがあなた専用に生成する「深層質問」への回答から、100億通り以上のパターンであなたをプロファイリングします。
            </p>
            
            <div class="flex flex-col sm:flex-row gap-4 pt-4">
              <button onclick="startAssessment()" class="flex-1 bg-slate-900 hover:bg-slate-800 text-white font-bold py-5 px-8 rounded-2xl flex items-center justify-center gap-3 transition-all active:scale-[0.98] shadow-xl shadow-slate-200">
                プロファイリングを開始
                <i data-lucide="chevron-right" class="w-5 h-5"></i>
              </button>
              <button onclick="toggleHistory()" class="flex-1 bg-white hover:bg-slate-50 text-slate-700 border-2 border-slate-100 font-bold py-5 px-8 rounded-2xl flex items-center justify-center gap-3 transition-all active:scale-[0.98]">
                <i data-lucide="history" class="w-5 h-5"></i>
                診断履歴を見る
              </button>
            </div>
          </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
          <div class="feature-card p-6 rounded-[2rem] flex flex-col gap-3" style="--feature-accent: linear-gradient(90deg, #6366f1, #3b82f6);">
            <i data-lucide="fingerprint" class="text-indigo-600 w-8 h-8"></i>
            <h3 class="font-bold text-slate-800">唯一無二の分析</h3>
            <p class="text-sm text-slate-500 leading-relaxed">ありきたりな16タイプに当てはめるのではなく、あなたの言葉をAIが直接読み解きます。</p>
          </div>
          <div class="feature-card p-6 rounded-[2rem] flex flex-col gap-3" style="--feature-accent: linear-gradient(90deg, #8b5cf6, #ec4899);">
            <i data-lucide="database" class="text-purple-600 w-8 h-8"></i>
            <h3 class="font-bold text-slate-800">深層質問エンジン</h3>
            <p class="text-sm text-slate-500 leading-relaxed">回答傾向をもとに、次に答えるべき問いをAIが再構成し、診断の解像度を高めます。</p>
          </div>
          <div class="feature-card p-6 rounded-[2rem] flex flex-col gap-3" style="--feature-accent: linear-gradient(90deg, #f59e0b, #fb7185);">
            <i data-lucide="shield-check" class="text-amber-600 w-8 h-8"></i>
            <h3 class="font-bold text-slate-800">心理学的な裏付け</h3>
            <p class="text-sm text-slate-500 leading-relaxed">世界で最も信頼される性格特性論「BIG5」をベースにアルゴリズムを構築。</p>
          </div>
        </div>
      </div>

      <!-- Screen: History -->
      <div id="screen-history" class="hidden fade-in space-y-6">
        <div class="flex items-center justify-between">
          <h2 class="text-2xl font-black text-slate-800 flex items-center gap-3">
            <i data-lucide="history" class="text-indigo-600"></i>
            診断履歴
          </h2>
          <button onclick="showScreen('intro')" class="text-sm font-bold text-slate-500 hover:text-indigo-600 transition-colors">
            トップに戻る
          </button>
        </div>
        
        <div id="history-list" class="grid grid-cols-1 gap-4">
          <!-- History items will be injected here -->
          <div class="p-12 text-center text-slate-400 italic bg-white rounded-3xl border border-dashed border-slate-200">
            履歴がありません。まずは診断を受けてみましょう。
          </div>
        </div>
      </div>

      <!-- Screen: Questions -->
      <div id="screen-questions" class="hidden glass rounded-[2.5rem] p-8 md:p-12 shadow-2xl space-y-10">
        <div class="space-y-4">
          <div class="flex justify-between items-end">
            <span class="text-xs font-black uppercase tracking-[0.2em] text-indigo-600">Phase 1: Base Analysis</span>
            <span id="q-progress-text" class="text-sm font-mono font-bold text-slate-400">01 / 16</span>
          </div>
          <div class="w-full bg-slate-100 rounded-full h-1.5 overflow-hidden">
            <div id="q-progress-bar" class="bg-indigo-600 h-full transition-all duration-500 ease-out" style="width: 0%"></div>
          </div>
        </div>

        <div class="min-h-[140px] flex items-center">
          <h3 id="question-text" class="text-2xl md:text-3xl font-black text-slate-800 leading-tight"></h3>
        </div>

        <div class="grid grid-cols-1 gap-3" id="options-container">
          <!-- Options injected here -->
        </div>
      </div>

      <!-- Screen: Dynamic Question (Generating & Answering) -->
      <div id="screen-generating-q" class="hidden flex flex-col items-center justify-center py-24 space-y-8 text-center bg-white rounded-[2.5rem] shadow-xl">
        <div id="dynamic-q-loading" class="flex flex-col items-center justify-center space-y-8 text-center">
          <div class="loader-ring"></div>
          <div class="space-y-2">
            <h3 class="text-2xl font-black text-slate-800">あなたの思考をトレース中</h3>
            <p class="text-slate-500">回答パターンから、あなた向けの3問を生成しています...</p>
          </div>
        </div>
        <div id="dynamic-q-error" class="hidden w-full max-w-xl px-6">
          <div class="bg-rose-50 border border-rose-100 rounded-2xl p-6 space-y-5">
            <div class="space-y-2">
              <h3 class="text-xl font-black text-rose-700">質問の生成に失敗しました</h3>
              <p id="dynamic-q-error-text" class="text-sm text-rose-700"></p>
              <p id="dynamic-q-retry-countdown" class="hidden text-xs font-bold text-rose-600"></p>
            </div>
            <div class="flex flex-col sm:flex-row gap-3">
              <button id="dynamic-q-retry-btn" onclick="retryDynamicQuestions()" class="flex-1 bg-rose-600 hover:bg-rose-700 text-white font-bold py-3 px-4 rounded-xl transition-colors disabled:opacity-60 disabled:cursor-not-allowed">
                再問い合わせする
              </button>
              <button onclick="showScreen('questions')" class="flex-1 bg-white hover:bg-slate-50 text-slate-700 border border-slate-200 font-bold py-3 px-4 rounded-xl transition-colors">
                戻る
              </button>
            </div>
          </div>
        </div>
      </div>

      <div id="screen-dynamic-question" class="hidden space-y-8">
        <div class="bg-indigo-600 text-white p-8 rounded-[2.5rem] shadow-xl relative overflow-hidden">
          <i data-lucide="sparkles" class="absolute -bottom-4 -right-4 w-32 h-32 opacity-20"></i>
          <div class="relative z-10">
            <span class="inline-block px-3 py-1 bg-white/20 rounded-lg text-[10px] font-bold uppercase tracking-widest mb-4">Phase 2: Deep Dive</span>
            <h2 class="text-2xl md:text-3xl font-black">AIが生成した「3つの鍵」</h2>
            <p class="text-indigo-100 mt-2 text-sm md:text-base">これらの問いにどう答えるかで、あなたの輪郭が決定します。</p>
          </div>
        </div>

        <div id="dynamic-questions-container" class="space-y-6">
          <!-- Dynamic questions injected here -->
        </div>

        <div id="gemini-status-bar" class="hidden bg-amber-50 border border-amber-100 rounded-xl px-4 py-3">
          <p id="gemini-status-text" class="text-sm font-bold text-amber-700"></p>
        </div>

        <button id="analyze-btn" onclick="submitFreeText()" class="w-full bg-slate-900 hover:bg-slate-800 text-white font-bold py-5 rounded-2xl flex items-center justify-center gap-3 shadow-xl transition-all active:scale-[0.98] disabled:opacity-50 disabled:cursor-not-allowed">
          最終解析を実行する
          <i data-lucide="zap" class="w-5 h-5 text-amber-400 fill-amber-400"></i>
        </button>
      </div>

      <!-- Screen: Analyzing -->
      <div id="screen-analyzing" class="hidden flex flex-col items-center justify-center py-24 space-y-8 text-center bg-slate-900 rounded-[2.5rem] shadow-2xl text-white">
        <div class="loader-ring !border-white/10 !border-top-white"></div>
        <div class="space-y-3">
          <h3 class="text-2xl font-black">ディーププロファイリング中</h3>
          <p class="text-slate-400 max-w-sm mx-auto">100億通りの性格マトリックスと照合し、<br/>あなただけの定義を構築しています...</p>
        </div>
      </div>

      <!-- Screen: Result -->
      <div id="screen-result" class="hidden space-y-10">
        <!-- Hero Catchphrase -->
        <div class="bg-gradient-to-br from-pink-50 via-violet-50 to-sky-50 rounded-[2.5rem] p-10 md:p-16 text-center space-y-6 shadow-xl border border-violet-100 relative overflow-hidden">
          <div class="absolute inset-0 bg-gradient-to-b from-white/40 to-transparent"></div>
          <div class="relative z-10 space-y-4">
            <span class="inline-block px-4 py-1 rounded-full bg-white/80 border border-violet-200 text-violet-500 font-bold text-[10px] tracking-[0.3em] uppercase">Result Identity</span>
            <h2 id="res-catchphrase" class="text-3xl md:text-6xl font-black text-transparent bg-clip-text bg-gradient-to-r from-fuchsia-500 via-indigo-500 to-sky-500 animate-gradient pb-2"></h2>
            <p id="res-wit" class="hidden text-sm md:text-base font-semibold text-indigo-700"></p>
          </div>
        </div>

        <!-- Metrics & Main Analysis -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
          <div class="bg-gradient-to-br from-cyan-50 to-indigo-50 rounded-[2.5rem] p-8 shadow-xl border border-cyan-100 flex flex-col items-center">
            <h3 class="text-xs font-black text-cyan-600 uppercase tracking-widest mb-8">Personality Spectrum</h3>
            <div id="radar-chart-container" class="w-full aspect-square max-w-[320px]"></div>
          </div>

          <div class="space-y-6">
            <div class="bg-gradient-to-br from-violet-300 to-indigo-300 text-white rounded-[2rem] p-8 shadow-lg relative overflow-hidden h-full">
              <i data-lucide="quote" class="absolute top-4 right-6 w-12 h-12 opacity-25"></i>
              <h3 class="text-lg font-bold mb-4 flex items-center gap-2">
                <i data-lucide="scan-face" class="w-5 h-5"></i>
                Base Insight
              </h3>
              <p id="res-analysis" class="text-white/95 leading-relaxed font-medium"></p>
            </div>
          </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <div class="bg-gradient-to-br from-sky-50 to-indigo-50 rounded-[2rem] p-8 border border-sky-100 space-y-5">
            <h4 class="text-sky-700 font-black flex items-center gap-2">
              <i data-lucide="activity" class="w-5 h-5"></i>
              BIG5 Scores
            </h4>
            <div id="res-big5" class="grid grid-cols-1 md:grid-cols-2 gap-3"></div>
          </div>

          <div class="bg-gradient-to-br from-emerald-50 to-teal-50 rounded-[2rem] p-8 border border-emerald-100 space-y-5">
            <h4 class="text-emerald-700 font-black flex items-center gap-2">
              <i data-lucide="compass" class="w-5 h-5"></i>
              RIASEC Aptitude
            </h4>
            <div id="res-riasec" class="grid grid-cols-1 md:grid-cols-2 gap-3"></div>
          </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <div class="bg-gradient-to-r from-emerald-50 to-cyan-50 rounded-[2rem] p-8 border border-emerald-100 space-y-3">
            <h4 class="text-emerald-700 font-black flex items-center gap-2">
              <i data-lucide="badge-check" class="w-5 h-5"></i>
              診断の信頼度
            </h4>
            <p id="res-confidence-level" class="text-2xl font-black text-emerald-700"></p>
            <p id="res-confidence-note" class="text-sm text-emerald-700 leading-relaxed"></p>
            <p id="res-model-used" class="text-xs text-emerald-700/90 font-semibold"></p>
          </div>
          <div class="bg-gradient-to-r from-slate-50 to-indigo-50 rounded-[2rem] p-8 border border-slate-200 space-y-3">
            <h4 class="text-slate-700 font-black flex items-center gap-2">
              <i data-lucide="git-compare-arrows" class="w-5 h-5"></i>
              前回からの変化
            </h4>
            <p id="res-history-compare" class="text-sm text-slate-700 leading-relaxed"></p>
          </div>
        </div>

        <div class="bg-gradient-to-r from-indigo-50 to-cyan-50 rounded-[2rem] p-8 border border-indigo-100 space-y-4">
          <h4 class="text-indigo-700 font-black flex items-center gap-2">
            <i data-lucide="git-merge" class="w-5 h-5"></i>
            Hybrid Synthesis (BIG5 × RIASEC × Deep Answers)
          </h4>
          <p id="res-hybrid" class="text-indigo-800 text-sm md:text-base leading-relaxed"></p>
          <p id="res-evidence" class="text-xs md:text-sm text-indigo-600/90 leading-relaxed"></p>
        </div>

        <div class="bg-gradient-to-r from-amber-50 to-rose-50 rounded-[2rem] p-8 border border-amber-100 space-y-4">
          <h4 class="text-rose-700 font-black flex items-center gap-2">
            <i data-lucide="eye" class="w-5 h-5"></i>
            Hidden Self (隠された欲求)
          </h4>
          <p id="res-hidden" class="text-rose-700 text-sm md:text-base leading-relaxed"></p>
        </div>

        <!-- Extra Topics Generation -->
        <div class="space-y-6 pt-8">
          <div class="flex items-center gap-3 px-2">
            <div class="bg-gradient-to-br from-fuchsia-100 to-indigo-100 p-2 rounded-xl border border-fuchsia-200">
              <i data-lucide="layers" class="w-5 h-5 text-fuchsia-600"></i>
            </div>
            <div>
              <h3 class="text-xl md:text-2xl font-black text-indigo-700">Deep Exploration</h3>
              <p class="text-xs font-bold text-indigo-400 mt-0.5">知りたい項目を選んでAIに深く掘り下げさせましょう</p>
            </div>
          </div>
          
          <div id="extra-topics-container" class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <!-- Topics injected here -->
          </div>
        </div>

        <!-- Actions -->
        <div class="flex flex-col sm:flex-row gap-4 justify-center pt-10 border-t border-indigo-100">
          <button onclick="toggleHistory()" class="bg-indigo-50 hover:bg-indigo-100 text-indigo-700 border-2 border-indigo-100 font-bold py-4 px-8 rounded-2xl flex items-center justify-center gap-3 transition-all active:scale-[0.98]">
            <i data-lucide="list" class="w-5 h-5"></i>
            履歴一覧を見る
          </button>
          <button onclick="resetApp()" class="bg-gradient-to-r from-violet-500 to-indigo-500 hover:from-violet-600 hover:to-indigo-600 text-white font-bold py-4 px-8 rounded-2xl flex items-center justify-center gap-3 transition-all active:scale-[0.98]">
            <i data-lucide="rotate-ccw" class="w-5 h-5"></i>
            新しく診断する
          </button>
        </div>
      </div>

    </main>

    <!-- Footer -->
    <footer class="mt-16 text-center text-slate-400 text-xs pb-10 space-y-2">
      <p>&copy; 2024 DeepProfile AI. All rights reserved.</p>
      <p class="font-mono opacity-50">Experimental Cognitive Analysis Model v3.0</p>
    </footer>
  </div>

  <script type="module">
    import { initializeApp, getApp, getApps } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, collection, onSnapshot, addDoc, updateDoc, serverTimestamp, query, orderBy, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- Config & Globals ---
    const GEMINI_PROXY_ENDPOINT = "/api/gemini-seikaku";
    
    const FIREBASE_CONFIG_ENDPOINTS = ["/api/firebase-config-antiage", "/api/firebase-config-mental"];
    const FIREBASE_APP_NAME = "antiage-auth";
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

    let app = null;
    let auth = null;
    let db = null;
    let authProvider = null;
    let user = null;
    let historyUnsub = null;
    let historyData = [];
    let currentDocId = null; // To track currently viewed/saved document

    // --- State & Constants ---
    const QUESTIONS = [
      { id: 'O1', type: 'Openness', text: '新しいアイデアや抽象的な概念について考えるのが好きだ。' },
      { id: 'O2', type: 'Openness', text: '型破りな方法や、まだ誰もやっていないことに強く惹かれる。' },
      { id: 'C1', type: 'Conscientiousness', text: '計画を立て、細かいリスクまで確認してから行動する。' },
      { id: 'C2', type: 'Conscientiousness', text: '一度決めたルールや目標は、どんなに面倒でも最後までやり抜く。' },
      { id: 'E1', type: 'Extraversion', text: '大勢の人がいる賑やかな場所に行くと、エネルギーが湧いてくる。' },
      { id: 'E2', type: 'Extraversion', text: '沈黙が続くのが苦手で、自分から積極的に話題を振ることが多い。' },
      { id: 'A1', type: 'Agreeableness', text: '他人が困っていると、自分の都合を後回しにしてでも助けたくなる。' },
      { id: 'A2', type: 'Agreeableness', text: '議論で相手を論破するより、お互いが納得する妥協点を見つけたい。' },
      { id: 'N1', type: 'Neuroticism', text: '些細な失敗や他人の何気ない一言をいつまでも引きずってしまう。' },
      { id: 'N2', type: 'Neuroticism', text: 'プレッシャーがかかる状況や予期せぬトラブルで、冷静さを失いやすい。' },
      { id: 'R1', type: 'Realistic', text: '抽象的な理論より、実際に手や体を動かして目に見える結果を出すのが好きだ。' },
      { id: 'I1', type: 'Investigative', text: '複雑な問題に対して、データや論理を用いて分析的に答えを導き出すのが好きだ。' },
      { id: 'A3', type: 'Artistic', text: '感情や直感を大切にし、自分なりの美意識や表現方法で何かを創り出したい。' },
      { id: 'S1', type: 'Social', text: '人と深く関わり、相手の成長や問題解決をサポートすることに大きな喜びを感じる。' },
      { id: 'E3', type: 'Enterprising', text: 'リーダーとして集団を引っ張り、目標を達成したり社会に影響を与えたりしたい。' },
      { id: 'C3', type: 'Conventional', text: '決められた手順やルールに従い、正確かつ効率的に物事を処理することに安心感がある。' }
    ];

    const OPTIONS = [
      { label: '全くない', value: 1, color: 'bg-rose-50 text-rose-700 hover:bg-rose-100 border-rose-200' },
      { label: 'あまりない', value: 2, color: 'bg-orange-50 text-orange-700 hover:bg-orange-100 border-orange-200' },
      { label: 'どちらでもない', value: 3, color: 'bg-slate-50 text-slate-700 hover:bg-slate-100 border-slate-200' },
      { label: 'ややある', value: 4, color: 'bg-emerald-50 text-emerald-700 hover:bg-emerald-100 border-emerald-200' },
      { label: '非常にある', value: 5, color: 'bg-indigo-50 text-indigo-700 hover:bg-indigo-100 border-indigo-200' }
    ];

    const BIG5_TRAITS = ['Openness', 'Conscientiousness', 'Extraversion', 'Agreeableness', 'Neuroticism'];
    const BIG5_LABELS = {
      Openness: '開放性',
      Conscientiousness: '誠実性',
      Extraversion: '外向性',
      Agreeableness: '協調性',
      Neuroticism: '神経傾向'
    };

    const RIASEC_TRAITS = ['Realistic', 'Investigative', 'Artistic', 'Social', 'Enterprising', 'Conventional'];
    const RIASEC_LABELS = {
      Realistic: 'Realistic',
      Investigative: 'Investigative',
      Artistic: 'Artistic',
      Social: 'Social',
      Enterprising: 'Enterprising',
      Conventional: 'Conventional'
    };

    const EXTRA_TOPICS = [
      { id: 'romance', title: '恋愛・パートナーシップ', icon: 'heart', prompt: 'この人物の恋愛傾向、惹かれる相手のタイプ、パートナーとしてうまくいくための条件を詳細に分析してください。（700〜1000字程度）' },
      { id: 'career', title: '天職とキャリア', icon: 'briefcase', prompt: 'この人物の才能が最も活きる職業環境、絶対に避けるべき職場、リーダーシップのスタイルについて詳細に分析してください。（700〜1000字程度）' },
      { id: 'stress', title: 'ストレスと地雷ポイント', icon: 'bomb', prompt: 'この人物が密かにストレスを抱える要因、激怒する・あるいは心を閉ざす「地雷」ポイントとその対処法を詳細に分析してください。（700〜1000字程度）' },
      { id: 'talent', title: '隠された才能', icon: 'sparkles', prompt: '本人がまだ自覚していない可能性が高い、他の人にはない特異な才能やポテンシャルについて詳細に分析してください。（700〜1000字程度）' },
      { id: 'money', title: '金銭感覚とリスク', icon: 'coins', prompt: 'この人物のお金に対する価値観、浪費しやすいポイント、リスクを取る際の思考回路について詳細に分析してください。（700〜1000字程度）' },
      { id: 'darkside', title: '人間関係のダークサイド', icon: 'moon', prompt: '極限のストレス下や絶望した時に現れる「闇落ち」した姿（シャドウ）と、他者を無意識にコントロールしようとする際の癖について詳細に分析してください。（700〜1000字程度）' },
      { id: 'growth', title: '人生最大の壁と突破口', icon: 'mountain', prompt: 'この人物が人生で何度もぶつかるであろう本質的な「壁」と、それを乗り越えるための具体的な突破口について詳細に分析してください。（700〜1000字程度）' },
      { id: 'lifestyle', title: '究極の理想のライフスタイル', icon: 'coffee', prompt: 'この人物が心からの安らぎと充実を感じる、究極的に理想とする生活環境や日常のルーティンについて詳細に分析してください。（700〜1000字程度）' }
    ];

    let currentQIndex = 0;
    let answers = {};
    let baseScores = {};
    let riasecScores = {};
    let dynamicQuestions = [];
    let finalProfile = null;
    let isAnswering = false;
    let isGeneratingDynamicQuestions = false;
    let isSubmittingProfile = false;
    let geminiCooldownUntilMs = 0;
    let geminiCooldownTimer = null;
    let lastGeminiMeta = { model: "", fallbackUsed: false, at: 0 };

    // --- Firebase Auth ---
    function parseFirebaseConfigCandidate(candidate) {
      if (!candidate) return null;
      if (typeof candidate === "string") {
        try {
          return JSON.parse(candidate);
        } catch {
          return null;
        }
      }
      if (typeof candidate === "object") return candidate;
      return null;
    }

    function isValidFirebaseConfig(config) {
      return !!(config && config.apiKey && config.projectId && config.authDomain);
    }

    function readFirebaseConfigRuntime() {
      const direct = parseFirebaseConfigCandidate(typeof __firebase_config !== "undefined" ? __firebase_config : null);
      if (isValidFirebaseConfig(direct)) return direct;

      const fromWindow = parseFirebaseConfigCandidate(window.__FIREBASE_CONFIG__);
      if (isValidFirebaseConfig(fromWindow)) return fromWindow;

      const meta = document.querySelector('meta[name="firebase-config"]');
      const fromMeta = parseFirebaseConfigCandidate(meta?.content);
      if (isValidFirebaseConfig(fromMeta)) return fromMeta;
      return null;
    }

    async function fetchFirebaseConfigFromServer() {
      for (const endpoint of FIREBASE_CONFIG_ENDPOINTS) {
        try {
          const res = await fetch(endpoint, { method: "GET", cache: "no-store" });
          if (!res.ok) continue;
          const data = await res.json();
          if (isValidFirebaseConfig(data)) return data;
        } catch {}
      }
      return null;
    }

    function updateAuthUi() {
      const authBtn = document.getElementById("auth-btn");
      const uidEl = document.getElementById("display-uid");
      if (!authBtn || !uidEl) return;
      if (user) {
        authBtn.textContent = "ログアウト";
        uidEl.textContent = `${user.uid.substring(0, 8)}...`;
      } else {
        authBtn.textContent = "Googleでログイン";
        uidEl.textContent = "ログインが必要です";
      }
    }

    async function initFirebaseAuth() {
      const firebaseConfig = readFirebaseConfigRuntime() || await fetchFirebaseConfigFromServer();
      if (!isValidFirebaseConfig(firebaseConfig)) {
        throw new Error("Firebase設定が見つかりません。/api/firebase-config-antiage を確認してください。");
      }

      app = getApps().some((a) => a.name === FIREBASE_APP_NAME)
        ? getApp(FIREBASE_APP_NAME)
        : initializeApp(firebaseConfig, FIREBASE_APP_NAME);
      auth = getAuth(app);
      db = getFirestore(app);
      authProvider = new GoogleAuthProvider();
      authProvider.setCustomParameters({ prompt: "select_account" });

      onAuthStateChanged(auth, (u) => {
        user = u || null;
        currentDocId = null;
        if (historyUnsub) {
          historyUnsub();
          historyUnsub = null;
        }
        if (user) {
          loadHistory();
        } else {
          historyData = [];
          renderHistoryList();
        }
        updateAuthUi();
      });

      const authBtn = document.getElementById("auth-btn");
      authBtn?.addEventListener("click", async () => {
        if (!auth) return;
        authBtn.disabled = true;
        try {
          if (user) {
            await signOut(auth);
          } else {
            await signInWithPopup(auth, authProvider);
          }
        } catch (err) {
          console.error("Auth Error:", err);
          alert("ログイン処理でエラーが発生しました。時間をおいて再試行してください。");
        } finally {
          authBtn.disabled = false;
        }
      });

      updateAuthUi();
    }

    initFirebaseAuth().catch((err) => {
      console.error("Firebase Init Error:", err);
      const uidEl = document.getElementById("display-uid");
      if (uidEl) uidEl.textContent = "設定エラー";
      const authBtn = document.getElementById("auth-btn");
      if (authBtn) authBtn.disabled = true;
      alert("Firebase設定の取得に失敗しました。管理者設定を確認してください。");
    });

    // --- Firestore Functions ---
    function loadHistory() {
      if (!user) return;
      const historyCol = collection(db, 'artifacts', appId, 'users', user.uid, 'history');
      historyUnsub = onSnapshot(historyCol, (snapshot) => {
        historyData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        renderHistoryList();
      }, (err) => console.error("Firestore Error:", err));
    }

    async function autoSaveToCloud(profileData) {
      if (!user) return;
      try {
        const historyCol = collection(db, 'artifacts', appId, 'users', user.uid, 'history');
        const docRef = await addDoc(historyCol, {
          ...profileData,
          extraData: {}, // 追加項目の格納用
          createdAt: serverTimestamp()
        });
        currentDocId = docRef.id;
        await pruneHistoryToLastThree();
      } catch (err) {
        console.error("Auto Save Error:", err);
      }
    }

    async function pruneHistoryToLastThree() {
      if (!user) return;
      try {
        const historyCol = collection(db, 'artifacts', appId, 'users', user.uid, 'history');
        const q = query(historyCol, orderBy("createdAt", "desc"));
        const snap = await getDocs(q);
        const docs = snap.docs;
        if (docs.length <= 3) return;
        const staleDocs = docs.slice(3);
        await Promise.all(staleDocs.map((d) => deleteDoc(d.ref)));
      } catch (err) {
        console.error("History prune error:", err);
      }
    }

    // --- Navigation ---
    window.showScreen = (screenId) => {
      const screens = ['intro', 'history', 'questions', 'generating-q', 'dynamic-question', 'analyzing', 'result'];
      screens.forEach(s => document.getElementById(`screen-${s}`).classList.add('hidden'));
      document.getElementById(`screen-${screenId}`).classList.remove('hidden');
      
      const badge = document.getElementById('phase-badge');
      if (screenId === 'questions') {
        badge.classList.remove('hidden');
        badge.textContent = 'Phase 1';
      } else if (screenId === 'dynamic-question') {
        badge.classList.remove('hidden');
        badge.textContent = 'Phase 2';
      } else {
        badge.classList.add('hidden');
      }
      refreshGeminiRateLimitUi();
      window.scrollTo(0, 0);
    };

    window.toggleHistory = () => showScreen('history');

    function ensureSignedIn() {
      if (user) return true;
      alert("先にGoogleでログインしてください。");
      return false;
    }
    
    window.resetApp = () => {
      currentQIndex = 0;
      answers = {};
      finalProfile = null;
      currentDocId = null;
      isAnswering = false;
      isGeneratingDynamicQuestions = false;
      isSubmittingProfile = false;
      lucide.createIcons();
      showScreen('intro');
    };

    // --- Core Logic ---
    window.startAssessment = () => {
      if (!ensureSignedIn()) return;
      currentQIndex = 0;
      answers = {};
      isAnswering = false;
      isGeneratingDynamicQuestions = false;
      isSubmittingProfile = false;
      renderQuestion();
      showScreen('questions');
    };

    function renderQuestion() {
      const q = QUESTIONS[currentQIndex];
      const progress = ((currentQIndex + 1) / QUESTIONS.length) * 100;
      
      document.getElementById('q-progress-text').textContent = `${(currentQIndex + 1).toString().padStart(2, '0')} / ${QUESTIONS.length}`;
      document.getElementById('q-progress-bar').style.width = `${progress}%`;
      
      const qText = document.getElementById('question-text');
      qText.classList.remove('fade-in');
      void qText.offsetWidth;
      qText.textContent = q.text;
      qText.classList.add('fade-in');

      const container = document.getElementById('options-container');
      container.innerHTML = '';
      OPTIONS.forEach(opt => {
        const btn = document.createElement('button');
        btn.className = `p-5 border-2 rounded-2xl text-left font-bold transition-all active:scale-[0.97] flex justify-between items-center ${opt.color}`;
        btn.innerHTML = `<span>${opt.label}</span> <i data-lucide="circle" class="w-4 h-4 opacity-30"></i>`;
        btn.onclick = () => handleAnswer(opt.value);
        container.appendChild(btn);
      });
      lucide.createIcons();
    }

    async function handleAnswer(val) {
      if (isAnswering || isGeneratingDynamicQuestions) return;
      isAnswering = true;
      const optionButtons = document.querySelectorAll('#options-container button');
      optionButtons.forEach((btn) => { btn.disabled = true; });
      answers[QUESTIONS[currentQIndex].id] = val;
      if (currentQIndex < QUESTIONS.length - 1) {
        currentQIndex++;
        renderQuestion();
        isAnswering = false;
      } else {
        try {
          await generateDynamicQuestions();
        } finally {
          isAnswering = false;
        }
      }
    }

    function calculateNormalizedScores(traits) {
      const scores = {};
      traits.forEach((trait) => {
        const subset = QUESTIONS.filter((q) => q.type === trait);
        const sum = subset.reduce((acc, q) => acc + (answers[q.id] || 3), 0);
        scores[trait] = Math.round((sum / (subset.length * 5)) * 100);
      });
      return scores;
    }

    function getTopTraits(scores, labels, topN = 2) {
      return Object.entries(scores)
        .sort((a, b) => b[1] - a[1])
        .slice(0, topN)
        .map(([key, value]) => `${labels[key] || key}(${value})`)
        .join(' / ');
    }

    function getBottomTraits(scores, labels, bottomN = 2) {
      return Object.entries(scores)
        .sort((a, b) => a[1] - b[1])
        .slice(0, bottomN)
        .map(([key, value]) => `${labels[key] || key}(${value})`)
        .join(' / ');
    }

    function normalizeText(value, fallback = "") {
      return typeof value === "string" && value.trim().length > 0 ? value.trim() : fallback;
    }

    function normalizeStringArray(value) {
      if (!Array.isArray(value)) return [];
      return value
        .map((v) => (typeof v === "string" ? v.trim() : ""))
        .filter((v) => v.length > 0)
        .slice(0, 8);
    }

    function shortenQuestionText(value, fallback = "") {
      const source = normalizeText(value, fallback).replace(/\s+/g, " ").trim();
      if (!source) return fallback;
      const firstSentence = source.split(/[。！？\n]/).map((s) => s.trim()).find(Boolean) || source;
      const short = firstSentence.length > 42 ? `${firstSentence.slice(0, 42)}…` : firstSentence;
      if (/[？?]$/.test(short)) return short;
      return `${short}？`;
    }

    function normalizeDynamicQuestion(raw) {
      const requiredPoints = normalizeStringArray(raw?.required_points || raw?.requiredPoints);
      const targetTraits = normalizeStringArray(raw?.rubric?.target_traits || raw?.rubric?.targetTraits);
      const confirmSignals = normalizeStringArray(raw?.rubric?.confirm_signals || raw?.rubric?.confirmSignals);
      const contradictSignals = normalizeStringArray(raw?.rubric?.contradict_signals || raw?.rubric?.contradictSignals);
      const text = shortenQuestionText(raw?.text, "");
      if (!text) return null;

      return {
        theme: normalizeText(raw?.theme, "Deep Dive"),
        role: normalizeText(raw?.role, "probe"),
        objective: normalizeText(raw?.objective, ""),
        text,
        requiredPoints,
        rubric: {
          targetTraits,
          confirmSignals,
          contradictSignals
        }
      };
    }

    function setDynamicQuestionGenerationUi({ loading, errorMessage = "" }) {
      const loadingEl = document.getElementById('dynamic-q-loading');
      const errorEl = document.getElementById('dynamic-q-error');
      const errorTextEl = document.getElementById('dynamic-q-error-text');
      if (loadingEl) loadingEl.classList.toggle('hidden', !loading);
      if (errorEl) errorEl.classList.toggle('hidden', loading);
      if (errorTextEl) {
        errorTextEl.textContent = loading
          ? ""
          : (errorMessage || "質問の生成に失敗しました。再問い合わせしてください。");
      }
      refreshGeminiRateLimitUi();
    }

    function getGeminiCooldownRemainingSec() {
      return Math.max(0, Math.ceil((geminiCooldownUntilMs - Date.now()) / 1000));
    }

    function clearGeminiCooldownTicker() {
      if (!geminiCooldownTimer) return;
      clearInterval(geminiCooldownTimer);
      geminiCooldownTimer = null;
    }

    function refreshGeminiRateLimitUi() {
      const remainingSec = getGeminiCooldownRemainingSec();
      const statusBar = document.getElementById('gemini-status-bar');
      const statusText = document.getElementById('gemini-status-text');
      const retryCountdown = document.getElementById('dynamic-q-retry-countdown');
      const retryBtn = document.getElementById('dynamic-q-retry-btn');
      const analyzeBtn = document.getElementById('analyze-btn');

      if (statusBar && statusText) {
        if (remainingSec > 0) {
          statusBar.classList.remove('hidden');
          statusText.textContent = `API制限中です。再試行まで ${remainingSec}s`;
        } else {
          statusBar.classList.add('hidden');
          statusText.textContent = "";
        }
      }

      if (retryCountdown) {
        if (remainingSec > 0) {
          retryCountdown.classList.remove('hidden');
          retryCountdown.textContent = `再問い合わせは ${remainingSec}s 後に可能です。`;
        } else {
          retryCountdown.classList.add('hidden');
          retryCountdown.textContent = "";
        }
      }

      if (retryBtn) {
        retryBtn.disabled = remainingSec > 0 || isGeneratingDynamicQuestions;
      }

      if (analyzeBtn) {
        const canSubmit = isDynamicAnswersReady(1) && !isSubmittingProfile;
        analyzeBtn.disabled = remainingSec > 0 || !canSubmit;
      }

      if (remainingSec <= 0) {
        clearGeminiCooldownTicker();
      }
    }

    function startGeminiCooldownTicker() {
      refreshGeminiRateLimitUi();
      if (getGeminiCooldownRemainingSec() <= 0) return;
      if (geminiCooldownTimer) return;
      geminiCooldownTimer = setInterval(() => {
        refreshGeminiRateLimitUi();
      }, 1000);
    }

    window.retryDynamicQuestions = async () => {
      if (isGeneratingDynamicQuestions) return;
      if (getGeminiCooldownRemainingSec() > 0) {
        refreshGeminiRateLimitUi();
        return;
      }
      await generateDynamicQuestions();
    };

    function pickScoreSubset(source, traits) {
      const result = {};
      if (!source || typeof source !== 'object') return result;
      traits.forEach((trait) => {
        const raw = Number(source[trait]);
        if (Number.isFinite(raw)) {
          result[trait] = Math.max(0, Math.min(100, Math.round(raw)));
        }
      });
      return result;
    }

    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function extractRetryAfterSec(text) {
      if (typeof text !== 'string') return 0;
      const match = text.match(/(\d+)\s*s\b/i);
      if (!match) return 0;
      const sec = Number(match[1]);
      return Number.isFinite(sec) && sec > 0 ? sec : 0;
    }

    async function fetchGemini(prompt, schema, options = {}) {
      if (!user) {
        throw new Error("Not signed in");
      }
      
      let delay = 1200;
      const maxAttempts = 2;
      for (let i = 0; i < maxAttempts; i++) {
        const now = Date.now();
        if (geminiCooldownUntilMs > now) {
          startGeminiCooldownTicker();
          await sleep(geminiCooldownUntilMs - now);
        }
        try {
          const token = await user.getIdToken();
          const res = await fetch(GEMINI_PROXY_ENDPOINT, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
              prompt,
              schema,
              temperature: Number.isFinite(Number(options?.temperature))
                ? Number(options.temperature)
                : undefined,
              model: typeof options?.model === "string" ? options.model : undefined
            })
          });
          const raw = await res.text();
          if (!res.ok) {
            let msg = "API Error";
            try {
              const parsed = JSON.parse(raw);
              msg = parsed?.error || msg;
            } catch {}
            const retryHeader = Number(res.headers.get("retry-after") || 0);
            const retryAfterSec = Math.max(
              Number.isFinite(retryHeader) && retryHeader > 0 ? Math.ceil(retryHeader) : 0,
              extractRetryAfterSec(msg)
            );
            const err = new Error(msg);
            err.status = res.status;
            err.retryAfterSec = retryAfterSec;
            throw err;
          }
          const parsed = JSON.parse(raw);
          if (!parsed?.ok || !parsed?.data) throw new Error("Invalid API response");
          lastGeminiMeta = {
            model: typeof parsed?.model === "string" ? parsed.model : "",
            fallbackUsed: !!parsed?.fallbackUsed,
            at: Date.now()
          };
          geminiCooldownUntilMs = 0;
          refreshGeminiRateLimitUi();
          return { data: parsed.data, meta: { ...lastGeminiMeta } };
        } catch (e) {
          const status = Number(e?.status || 0);
          if (status === 429) {
            const retrySec = Math.max(1, Number(e?.retryAfterSec || 0), Math.ceil(delay / 1000));
            geminiCooldownUntilMs = Date.now() + retrySec * 1000;
            startGeminiCooldownTicker();
            if (i === maxAttempts - 1) {
              throw new Error(`Rate limit reached. Please try again in ${retrySec}s.`);
            }
            await sleep(retrySec * 1000);
            continue;
          }
          if (i === maxAttempts - 1) throw e;
          await sleep(delay);
          delay = Math.min(delay * 2, 12000);
        }
      }
      throw new Error("Gemini request failed");
    }

    async function generateDynamicQuestions() {
      if (isGeneratingDynamicQuestions) return;
      isGeneratingDynamicQuestions = true;
      setDynamicQuestionGenerationUi({ loading: true, errorMessage: "" });
      showScreen('generating-q');
      
      // Calculate basic scores
      baseScores = calculateNormalizedScores(BIG5_TRAITS);
      riasecScores = calculateNormalizedScores(RIASEC_TRAITS);
      const topBig5 = getTopTraits(baseScores, BIG5_LABELS, 2);
      const topRiasec = getTopTraits(riasecScores, RIASEC_LABELS, 2);
      const bottomBig5 = getBottomTraits(baseScores, BIG5_LABELS, 2);
      const bottomRiasec = getBottomTraits(riasecScores, RIASEC_LABELS, 2);

      const prompt = `あなたはGemini向けの心理測定質問デザイナーです。
目的は、回答しやすく情報量の高い3問を作ることです。

[入力データ]
BIG5: ${JSON.stringify(baseScores)}
RIASEC: ${JSON.stringify(riasecScores)}
BIG5上位: ${topBig5}
BIG5下位: ${bottomBig5}
RIASEC上位: ${topRiasec}
RIASEC下位: ${bottomRiasec}

[必須役割]
1. high_validation（強み確認）
2. low_validation（弱み確認）
3. contradiction_check（状況による揺れ確認）

[生成ルール]
- 各質問は20〜40文字程度、1文、平易な日本語。
- 誘導・断定・説教は禁止。
- 回答者が具体例を自然に書ける問いにする。
- 役割ごとに観点を重複させない。

[出力]
- responseSchemaに厳密準拠。
- questionsは3件固定。
- JSON以外を出力しない。`;

      const schema = {
        type: "OBJECT",
        properties: {
          questions: {
            type: "ARRAY",
            items: {
              type: "OBJECT",
              properties: {
                theme: { type: "STRING" },
                role: { type: "STRING" },
                objective: { type: "STRING" },
                text: { type: "STRING" },
                required_points: {
                  type: "ARRAY",
                  items: { type: "STRING" }
                },
                rubric: {
                  type: "OBJECT",
                  properties: {
                    target_traits: {
                      type: "ARRAY",
                      items: { type: "STRING" }
                    },
                    confirm_signals: {
                      type: "ARRAY",
                      items: { type: "STRING" }
                    },
                    contradict_signals: {
                      type: "ARRAY",
                      items: { type: "STRING" }
                    }
                  }
                }
              }
            }
          }
        }
      };

      try {
        const { data } = await fetchGemini(prompt, schema, { temperature: 0.42 });
        const generated = Array.isArray(data?.questions)
          ? data.questions.slice(0, 3).map((q) => normalizeDynamicQuestion(q)).filter(Boolean)
          : [];
        if (generated.length !== 3) {
          throw new Error("有効な3つの質問を生成できませんでした。");
        }
        dynamicQuestions = generated;
        renderDynamicQuestions();
        showScreen('dynamic-question');
      } catch (err) {
        console.error(err);
        const message = typeof err?.message === "string" && err.message.trim().length
          ? err.message.trim()
          : "質問の生成に失敗しました。";
        setDynamicQuestionGenerationUi({ loading: false, errorMessage: `${message} 「再問い合わせする」を押してください。` });
        showScreen('generating-q');
      } finally {
        isGeneratingDynamicQuestions = false;
        refreshGeminiRateLimitUi();
      }
    }

    function isDynamicAnswersReady(minChars = 1) {
      const inputs = document.querySelectorAll('#dynamic-questions-container textarea');
      if (inputs.length !== dynamicQuestions.length || inputs.length === 0) return false;
      return Array.from(inputs).every((ta) => ta.value.trim().length >= minChars);
    }

    function renderDynamicQuestions() {
      const container = document.getElementById('dynamic-questions-container');
      const analyzeBtn = document.getElementById('analyze-btn');
      container.innerHTML = '';
      dynamicQuestions.forEach((q, i) => {
        const div = document.createElement('div');
        div.className = "bg-white p-7 rounded-[2rem] shadow-lg border border-slate-100 space-y-4";
        div.innerHTML = `
          <div class="flex items-center gap-2">
            <span class="bg-indigo-100 text-indigo-600 px-3 py-1 rounded-lg text-[10px] font-black uppercase tracking-widest">${q.theme}</span>
          </div>
          <h4 class="font-bold text-slate-800 text-lg">${q.text}</h4>
          <textarea id="ans-${i}" class="w-full bg-slate-50 border-2 border-slate-100 rounded-xl p-4 text-sm focus:border-indigo-500 focus:outline-none focus:bg-white transition-all min-h-[120px]" placeholder="短くてもOKです。自由に書いてください。"></textarea>
        `;
        container.appendChild(div);
      });
      
      const inputs = container.querySelectorAll('textarea');
      if (analyzeBtn) analyzeBtn.disabled = true;
      const validate = () => {
        refreshGeminiRateLimitUi();
      };
      inputs.forEach((ta) => {
        ta.addEventListener('input', validate);
        ta.addEventListener('change', validate);
        ta.addEventListener('blur', validate);
        ta.addEventListener('keyup', validate);
      });
      validate();
    }

    window.submitFreeText = async () => {
      if (!ensureSignedIn()) return;
      if (isSubmittingProfile) return;
      const waitSec = getGeminiCooldownRemainingSec();
      if (waitSec > 0) {
        alert(`API制限中です。${waitSec}s 後に再実行してください。`);
        refreshGeminiRateLimitUi();
        return;
      }
      if (!isDynamicAnswersReady(1)) {
        alert("3つの質問すべてに回答してから進んでください。");
        const btn = document.getElementById('analyze-btn');
        if (btn) btn.disabled = !isDynamicAnswersReady(1);
        return;
      }
      isSubmittingProfile = true;
      const analyzeBtn = document.getElementById('analyze-btn');
      if (analyzeBtn) analyzeBtn.disabled = true;
      showScreen('analyzing');
      const dynamicAnswerPayload = dynamicQuestions.map((q, i) => ({
        theme: q.theme,
        role: q.role || "",
        question: q.text,
        answer: document.getElementById(`ans-${i}`).value.trim()
      }));
      const freeAnswers = dynamicAnswerPayload
        .map((entry) => `【${entry.theme}/${entry.role}】${entry.question}\n回答: ${entry.answer}`)
        .join('\n\n');
      
      const prompt = `あなたは知性的でユーモア感覚のある心理分析AIです。
以下のデータを統合し、実用性の高いハイブリッド診断を作成してください。

[入力]
BIG5: ${JSON.stringify(baseScores)}
RIASEC: ${JSON.stringify(riasecScores)}
質問設計: ${JSON.stringify(dynamicQuestions)}
回答: ${freeAnswers}

[分析方針]
- 数値は観測値として扱い、改変しない。
- 一般論より、回答本文の具体的記述を優先して解釈する。
- 強みだけでなく、弱みとトレードオフも示す。
- 文章は知的で読みやすく、比喩やウィットは「軽く1〜2箇所」だけ入れる。
- ユーモアは相手を下げず、気づきを深める方向に使う。

[出力仕様]
- responseSchemaに厳密準拠。
- JSONのみ返す。
- catchphrase: 18〜34文字、覚えやすく鮮明。
- witLine: 35〜90文字、知的で軽いユーモアの一言。
- deepAnalysis: 900〜1400文字。
- hybridSynthesis: 500〜850文字。
- hiddenDesire: 500〜900文字。
- big5Interpretation: 280〜480文字。
- riasecInterpretation: 280〜480文字。
- evidenceSummary: 220〜420文字。根拠と不確実性を分けて示す。`;

      const schema = {
        type: "OBJECT",
        properties: {
          catchphrase: { type: "STRING" },
          witLine: { type: "STRING" },
          deepAnalysis: { type: "STRING" },
          hybridSynthesis: { type: "STRING" },
          hiddenDesire: { type: "STRING" },
          big5Interpretation: { type: "STRING" },
          riasecInterpretation: { type: "STRING" },
          evidenceSummary: { type: "STRING" }
        }
      };

      try {
        const { data: aiProfile, meta } = await fetchGemini(prompt, schema, { temperature: 0.72 });
        finalProfile = {
          ...aiProfile,
          scoring: {
            big5: { ...baseScores },
            riasec: { ...riasecScores }
          },
          generationMeta: {
            model: meta?.model || "",
            fallbackUsed: !!meta?.fallbackUsed,
            generatedAt: Date.now()
          },
          dynamicQuestions: dynamicQuestions.map((q) => ({ ...q })),
          dynamicAnswers: dynamicAnswerPayload,
          extraData: {}
        };
        
        // 解析完了後に自動保存
        await autoSaveToCloud(finalProfile);
        
        renderResult(finalProfile);
        showScreen('result');
      } catch (err) {
        console.error(err);
        showScreen('dynamic-question');
      } finally {
        isSubmittingProfile = false;
        refreshGeminiRateLimitUi();
      }
    };

    function resolveBig5ScoresFromItem(item) {
      const fromScoring = pickScoreSubset(item?.scoring?.big5, BIG5_TRAITS);
      if (Object.keys(fromScoring).length) return fromScoring;
      return pickScoreSubset(item?.adjustedScores, BIG5_TRAITS);
    }

    function computeDiagnosisConfidence(profile) {
      const answers = Array.isArray(profile?.dynamicAnswers) ? profile.dynamicAnswers : [];
      const lengths = answers
        .map((entry) => String(entry?.answer || "").trim().length)
        .filter((len) => len > 0);
      const avgLen = lengths.length
        ? lengths.reduce((sum, len) => sum + len, 0) / lengths.length
        : 0;

      let score = 48;
      if (lengths.length >= 3) score += 15;
      if (avgLen >= 90) score += 20;
      else if (avgLen >= 50) score += 12;
      else if (avgLen >= 25) score += 6;
      else score -= 8;

      const evidenceLen = String(profile?.evidenceSummary || "").trim().length;
      if (evidenceLen >= 180) score += 10;
      else if (evidenceLen >= 80) score += 5;

      if (profile?.generationMeta?.fallbackUsed) score -= 8;
      score = Math.max(0, Math.min(100, Math.round(score)));

      if (score >= 78) {
        return {
          score,
          level: "高",
          note: "回答の具体性と一貫性が高く、診断の解像度は高めです。"
        };
      }
      if (score >= 60) {
        return {
          score,
          level: "中",
          note: "傾向把握には十分ですが、具体例を増やすとさらに精度が上がります。"
        };
      }
      return {
        score,
        level: "低",
        note: "回答が短いか情報が不足しています。具体的な場面を補うと精度が改善します。"
      };
    }

    function renderHistoryComparison(currentScores, currentId) {
      const compareEl = document.getElementById('res-history-compare');
      if (!compareEl) return;

      const sorted = historyData
        .slice()
        .sort((a, b) => (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0));
      const previous = sorted.find((item) => item.id !== currentId && Object.keys(resolveBig5ScoresFromItem(item)).length);

      if (!previous) {
        compareEl.textContent = "比較できる過去データがまだありません。";
        return;
      }

      const prevScores = resolveBig5ScoresFromItem(previous);
      if (!Object.keys(prevScores).length || !Object.keys(currentScores).length) {
        compareEl.textContent = "比較に必要なスコアが不足しています。";
        return;
      }

      const changes = BIG5_TRAITS.map((trait) => {
        const current = Number(currentScores[trait] || 0);
        const prev = Number(prevScores[trait] || 0);
        return {
          trait,
          label: BIG5_LABELS[trait] || trait,
          delta: Math.round(current - prev)
        };
      })
        .filter((item) => Math.abs(item.delta) >= 1)
        .sort((a, b) => Math.abs(b.delta) - Math.abs(a.delta));

      const dateLabel = previous.createdAt?.seconds
        ? new Date(previous.createdAt.seconds * 1000).toLocaleDateString()
        : "前回";

      if (!changes.length) {
        compareEl.textContent = `${dateLabel}比で大きな変化はありません。`;
        return;
      }

      const summary = changes
        .slice(0, 3)
        .map((item) => `${item.label} ${item.delta >= 0 ? "+" : ""}${item.delta}`)
        .join(" / ");
      compareEl.textContent = `${dateLabel}比: ${summary}`;
    }

    function renderConfidenceAndModel(profile) {
      const confidence = computeDiagnosisConfidence(profile);
      const levelEl = document.getElementById('res-confidence-level');
      const noteEl = document.getElementById('res-confidence-note');
      const modelEl = document.getElementById('res-model-used');
      if (levelEl) levelEl.textContent = `${confidence.level} (${confidence.score}/100)`;
      if (noteEl) noteEl.textContent = confidence.note;

      const model = String(profile?.generationMeta?.model || "").trim();
      const fallbackUsed = !!profile?.generationMeta?.fallbackUsed;
      if (modelEl) {
        modelEl.textContent = model
          ? `使用モデル: ${model}${fallbackUsed ? "（フォールバック利用）" : ""}`
          : "使用モデル: 不明";
      }
    }

    function renderResult(data) {
      const storedBig5 = pickScoreSubset(data?.scoring?.big5, BIG5_TRAITS);
      const storedRiasec = pickScoreSubset(data?.scoring?.riasec, RIASEC_TRAITS);
      const legacyBig5 = pickScoreSubset(data?.adjustedScores, BIG5_TRAITS);
      const legacyRiasec = pickScoreSubset(data?.adjustedScores, RIASEC_TRAITS);
      const liveBig5 = pickScoreSubset(baseScores, BIG5_TRAITS);
      const liveRiasec = pickScoreSubset(riasecScores, RIASEC_TRAITS);
      const big5ForDisplay = Object.keys(storedBig5).length
        ? storedBig5
        : (Object.keys(legacyBig5).length ? legacyBig5 : liveBig5);
      const riasecForDisplay = Object.keys(storedRiasec).length
        ? storedRiasec
        : (Object.keys(legacyRiasec).length ? legacyRiasec : liveRiasec);

      baseScores = { ...big5ForDisplay };
      riasecScores = { ...riasecForDisplay };

      document.getElementById('res-catchphrase').textContent = data.catchphrase || '';
      const witEl = document.getElementById('res-wit');
      if (witEl) {
        witEl.textContent = data.witLine || '';
        witEl.classList.toggle('hidden', !data.witLine);
      }
      document.getElementById('res-analysis').textContent = data.deepAnalysis || '';
      document.getElementById('res-hybrid').textContent = data.hybridSynthesis || data.deepAnalysis || '';
      document.getElementById('res-hidden').textContent = data.hiddenDesire || '';
      const evidenceEl = document.getElementById('res-evidence');
      if (evidenceEl) {
        evidenceEl.textContent = data.evidenceSummary ? `Evidence Note: ${data.evidenceSummary}` : '';
        evidenceEl.classList.toggle('hidden', !data.evidenceSummary);
      }

      const chartCont = document.getElementById('radar-chart-container');
      chartCont.innerHTML = generateRadar(big5ForDisplay);

      renderConfidenceAndModel(data);
      renderHistoryComparison(big5ForDisplay, data?.id || currentDocId);
      renderBig5Scores(big5ForDisplay);
      renderRiasecScores(riasecForDisplay);
      
      // 追加項目の描画
      renderExtraTopics();

      lucide.createIcons();
    }

    function renderScoreBars(containerId, items, scores, theme) {
      const container = document.getElementById(containerId);
      if (!container) return;
      container.innerHTML = items.map((item) => {
        const raw = Number(scores[item.key]);
        const value = Number.isFinite(raw) ? Math.max(0, Math.min(100, Math.round(raw))) : 0;
        const valueClass = theme === 'sky' ? 'text-sky-700' : 'text-emerald-700';
        const railClass = theme === 'sky' ? 'bg-sky-100' : 'bg-emerald-100';
        const fillClass = theme === 'sky'
          ? 'bg-gradient-to-r from-sky-400 to-indigo-500'
          : 'bg-gradient-to-r from-emerald-400 to-teal-500';
        return `
          <div class="bg-white/80 rounded-xl border border-slate-100 p-3">
            <div class="flex items-center justify-between text-xs font-bold text-slate-600">
              <span>${item.label}</span>
              <span class="${valueClass}">${value}</span>
            </div>
            <div class="mt-2 h-2 ${railClass} rounded-full overflow-hidden">
              <div class="h-full ${fillClass}" style="width:${value}%"></div>
            </div>
          </div>
        `;
      }).join('');
    }

    function renderBig5Scores(scores) {
      const items = [
        { key: 'Openness', label: '開放性' },
        { key: 'Conscientiousness', label: '誠実性' },
        { key: 'Extraversion', label: '外向性' },
        { key: 'Agreeableness', label: '協調性' },
        { key: 'Neuroticism', label: '神経傾向' }
      ];
      renderScoreBars('res-big5', items, scores, 'sky');
    }

    function renderRiasecScores(scores) {
      const items = [
        { key: 'Realistic', label: 'Realistic' },
        { key: 'Investigative', label: 'Investigative' },
        { key: 'Artistic', label: 'Artistic' },
        { key: 'Social', label: 'Social' },
        { key: 'Enterprising', label: 'Enterprising' },
        { key: 'Conventional', label: 'Conventional' }
      ];
      renderScoreBars('res-riasec', items, scores, 'emerald');
    }

    function renderExtraTopics() {
      const container = document.getElementById('extra-topics-container');
      container.innerHTML = '';
      
      const extraData = finalProfile.extraData || {};

      EXTRA_TOPICS.forEach(topic => {
        const hasData = !!extraData[topic.id];
        
        const div = document.createElement('div');
        div.className = "bg-gradient-to-br from-white to-indigo-50 p-6 rounded-[2rem] shadow-lg border border-indigo-100 flex flex-col justify-between";
        div.id = `topic-card-${topic.id}`;
        
        let contentHtml = '';
        if (hasData) {
          contentHtml = `<p class="text-sm text-indigo-700 leading-relaxed mt-4 fade-in">${extraData[topic.id]}</p>`;
        } else {
          contentHtml = `
            <div class="mt-4">
              <button id="btn-gen-${topic.id}" onclick="generateExtraTopic('${topic.id}')" class="w-full bg-violet-50 hover:bg-violet-100 text-violet-700 font-bold py-3 px-4 rounded-xl flex items-center justify-center gap-2 transition-colors border border-violet-200">
                <i data-lucide="zap" class="w-4 h-4"></i>
                AIで詳細を解析する
              </button>
              <div id="loading-${topic.id}" class="hidden w-full py-3 flex items-center justify-center gap-2 text-violet-600 font-bold text-sm">
                <i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i> 思考を巡らせています...
              </div>
            </div>
          `;
        }

        div.innerHTML = `
          <div>
            <div class="flex items-center gap-3 mb-2">
              <div class="w-10 h-10 rounded-xl bg-gradient-to-br from-pink-100 to-indigo-100 text-indigo-600 flex items-center justify-center border border-indigo-100">
                <i data-lucide="${topic.icon}" class="w-5 h-5"></i>
              </div>
              <h4 class="font-bold text-indigo-800">${topic.title}</h4>
            </div>
          </div>
          <div id="content-${topic.id}" class="flex-grow flex flex-col justify-end">
            ${contentHtml}
          </div>
        `;
        container.appendChild(div);
      });
      lucide.createIcons();
    }

    window.generateExtraTopic = async (topicId) => {
      const topic = EXTRA_TOPICS.find(t => t.id === topicId);
      const btn = document.getElementById(`btn-gen-${topicId}`);
      const loader = document.getElementById(`loading-${topicId}`);
      const contentDiv = document.getElementById(`content-${topicId}`);

      btn.classList.add('hidden');
      loader.classList.remove('hidden');

      const prompt = `あなたは世界トップクラスの深層心理アナリストです。
      以下のプロファイルデータを基に、ユーザーの【${topic.title}】について詳細な分析を生成してください。

      [キャッチコピー]: ${finalProfile.catchphrase}
      [ベース分析]: ${finalProfile.deepAnalysis}
      [ハイブリッド統合]: ${finalProfile.hybridSynthesis || finalProfile.deepAnalysis}
      [隠された欲求]: ${finalProfile.hiddenDesire}
      [BIG5スコア]: ${JSON.stringify(finalProfile.scoring?.big5 || baseScores)}
      [RIASECスコア]: ${JSON.stringify(finalProfile.scoring?.riasec || riasecScores)}

      指示:
      ・${topic.prompt}
      ・最低でも700文字以上、最大1200文字程度で出力してください。
      ・ユーザーが読んで深く納得し、時にハッとするような鋭い洞察を含めてください。
      ・分析は「傾向の説明」だけでなく、「起こりやすい具体場面」「回避策/活用策」まで書いてください。
      ・回答は指定テーマの分析テキストのみをプレーンテキストで出力してください。`;

      const schema = {
        type: "OBJECT",
        properties: {
          analysisText: { type: "STRING" }
        }
      };

      try {
        const { data } = await fetchGemini(prompt, schema, { temperature: 0.66 });
        const resultText = data.analysisText;
        
        // Update local state
        finalProfile.extraData = finalProfile.extraData || {};
        finalProfile.extraData[topicId] = resultText;
        
        // Update UI
        contentDiv.innerHTML = `<p class="text-sm text-slate-700 leading-relaxed mt-4 fade-in font-medium">${resultText}</p>`;
        
        // Update Cloud automatically
        if (user && currentDocId) {
          const docRef = doc(db, 'artifacts', appId, 'users', user.uid, 'history', currentDocId);
          await updateDoc(docRef, { [`extraData.${topicId}`]: resultText });
        }
      } catch (err) {
        console.error("Generate Extra Topic Error:", err);
        btn.classList.remove('hidden');
        loader.classList.add('hidden');
        btn.innerHTML = `<i data-lucide="refresh-cw" class="w-4 h-4"></i> エラーが発生しました。再試行`;
        lucide.createIcons();
      }
    };

    function generateRadar(scores) {
      const size = 320;
      const center = size / 2;
      const radius = 110;
      const labels = ['開放', '誠実', '外向', '協調', '神経'];
      const keys = ['Openness', 'Conscientiousness', 'Extraversion', 'Agreeableness', 'Neuroticism'];

      const getXY = (val, i) => {
        const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
        const safeVal = Number.isFinite(Number(val)) ? Number(val) : 0;
        const r = (Math.max(0, Math.min(100, safeVal)) / 100) * radius;
        return { x: center + r * Math.cos(angle), y: center + r * Math.sin(angle) };
      };

      const points = keys.map((k, i) => getXY(scores[k], i));
      const polyStr = points.map(p => `${p.x},${p.y}`).join(' ');

      let grids = "";
      [0.2, 0.4, 0.6, 0.8, 1].forEach(l => {
        const gp = keys.map((_, i) => getXY(100 * l, i));
        grids += `<polygon points="${gp.map(p => `${p.x},${p.y}`).join(' ')}" fill="none" stroke="#f1f5f9" stroke-width="1"/>`;
      });

      let axis = "";
      keys.forEach((_, i) => {
        const p = getXY(100, i);
        const lp = getXY(125, i);
        axis += `<line x1="${center}" y1="${center}" x2="${p.x}" y2="${p.y}" stroke="#f1f5f9"/>`;
        axis += `<text x="${lp.x}" y="${lp.y}" text-anchor="middle" dominant-baseline="middle" font-size="10" font-weight="900" fill="#94a3b8">${labels[i]}</text>`;
      });

      return `
        <svg viewBox="0 0 ${size} ${size}" class="w-full h-full overflow-visible">
          ${grids} ${axis}
          <polygon points="${polyStr}" class="radar-polygon" fill="rgba(99, 102, 241, 0.15)" stroke="#6366f1" stroke-width="3"/>
          ${points.map(p => `<circle cx="${p.x}" cy="${p.y}" r="4" fill="#6366f1"/>`).join('')}
        </svg>
      `;
    }

    function renderHistoryList() {
      const container = document.getElementById('history-list');
      if (historyData.length === 0) {
        container.innerHTML = `<div class="p-12 text-center text-slate-400 italic bg-white rounded-3xl border border-dashed border-slate-200">履歴がありません。</div>`;
        return;
      }

      container.innerHTML = historyData
        .sort((a, b) => (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0))
        .slice(0, 3)
        .map(item => `
        <div onclick='openHistoryItem("${item.id}")' class="bg-white p-6 rounded-2xl border border-slate-100 shadow-sm hover:shadow-md transition-all cursor-pointer group flex items-center justify-between">
          <div class="space-y-1">
            <span class="text-[10px] font-bold text-indigo-500 uppercase tracking-widest">${new Date(item.createdAt?.seconds * 1000).toLocaleDateString()}</span>
            <h4 class="font-bold text-slate-800 group-hover:text-indigo-600 transition-colors">${item.catchphrase}</h4>
          </div>
          <i data-lucide="arrow-right" class="w-5 h-5 text-slate-300 group-hover:text-indigo-600 transition-all group-hover:translate-x-1"></i>
        </div>
      `).join('');
      lucide.createIcons();
    }

    window.openHistoryItem = (id) => {
      const item = historyData.find(h => h.id === id);
      if (item) {
        currentDocId = item.id; // Set ID so extra topics save to correct doc
        const historyBig5 = pickScoreSubset(item?.scoring?.big5, BIG5_TRAITS);
        const historyRiasec = pickScoreSubset(item?.scoring?.riasec, RIASEC_TRAITS);
        const legacyBig5 = pickScoreSubset(item?.adjustedScores, BIG5_TRAITS);
        const legacyRiasec = pickScoreSubset(item?.adjustedScores, RIASEC_TRAITS);
        if (Object.keys(historyBig5).length) baseScores = historyBig5;
        else if (Object.keys(legacyBig5).length) baseScores = legacyBig5;
        if (Object.keys(historyRiasec).length) riasecScores = historyRiasec;
        else if (Object.keys(legacyRiasec).length) riasecScores = legacyRiasec;
        finalProfile = item;
        renderResult(item);
        showScreen('result');
        window.scrollTo(0, 0);
      }
    };

    // 初期起動
    lucide.createIcons();
    showScreen('intro');

  </script>
</body>
</html>
