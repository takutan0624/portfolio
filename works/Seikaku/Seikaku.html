<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DeepProfile AI | 超精密性格プロファイリング</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=Noto+Sans+JP:wght@400;500;700;900&display=swap');
    
    body {
      font-family: 'Inter', 'Noto Sans JP', sans-serif;
    }

    .glass {
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .fade-in { animation: fadeIn 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
    .slide-up { animation: slideUp 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards; }

    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes slideUp { 
      from { opacity: 0; transform: translateY(20px); } 
      to { opacity: 1; transform: translateY(0); } 
    }

    .loader-ring {
      border: 3px solid rgba(99, 102, 241, 0.1);
      border-top: 3px solid #6366f1;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      animation: spin 1s cubic-bezier(0.55, 0.1, 0.15, 0.9) infinite;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    .radar-polygon {
      transition: all 0.5s ease;
    }

    .panel-strong {
      border: 1px solid rgba(148, 163, 184, 0.35);
      box-shadow:
        0 28px 64px -34px rgba(15, 23, 42, 0.62),
        inset 0 1px 0 rgba(255, 255, 255, 0.95);
    }

    .feature-card {
      position: relative;
      background: rgba(255, 255, 255, 0.88);
      border: 1px solid rgba(148, 163, 184, 0.3);
      box-shadow: 0 22px 48px -30px rgba(15, 23, 42, 0.58);
    }

    #app-container .shadow-sm,
    #app-container .shadow-md,
    #app-container .shadow-lg,
    #app-container .shadow-xl,
    #app-container .shadow-2xl {
      box-shadow:
        var(--tw-ring-offset-shadow, 0 0 #0000),
        var(--tw-ring-shadow, 0 0 #0000),
        var(--tw-shadow),
        0 24px 56px -34px rgba(15, 23, 42, 0.62) !important;
    }

    .feature-card::before {
      content: "";
      position: absolute;
      top: 0.7rem;
      left: 1rem;
      right: 1rem;
      height: 3px;
      border-radius: 999px;
      background: var(--feature-accent, #6366f1);
      opacity: 0.9;
    }

    .mode-tab {
      border: 1px solid transparent;
      background: transparent;
      color: #64748b;
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.05em;
      border-radius: 0.75rem;
      padding: 0.6rem 0.9rem;
      transition: all 0.2s ease;
    }

    .mode-tab:hover {
      color: #334155;
      background: #f8fafc;
    }

    .mode-tab.is-active {
      background: white;
      color: #4f46e5;
      border-color: #e0e7ff;
      box-shadow: 0 6px 16px -10px rgba(79, 70, 229, 0.7);
    }

    .fortune-shell {
      position: relative;
      overflow: hidden;
      background:
        radial-gradient(circle at 15% 18%, rgba(251, 191, 36, 0.28), transparent 45%),
        radial-gradient(circle at 82% 12%, rgba(244, 114, 182, 0.22), transparent 40%),
        linear-gradient(135deg, #fffbeb 0%, #fff7ed 45%, #eef2ff 100%);
      border: 1px solid rgba(251, 191, 36, 0.26);
    }

    .fortune-stars {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .fortune-stars span {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.08);
      animation: twinkle 2.8s ease-in-out infinite;
    }

    .fortune-stars span:nth-child(1) { top: 14%; left: 12%; animation-delay: 0s; }
    .fortune-stars span:nth-child(2) { top: 28%; left: 78%; animation-delay: 0.6s; }
    .fortune-stars span:nth-child(3) { top: 65%; left: 18%; animation-delay: 1.2s; }
    .fortune-stars span:nth-child(4) { top: 74%; left: 68%; animation-delay: 1.8s; }

    .fortune-orbit {
      position: absolute;
      width: 240px;
      height: 240px;
      border-radius: 999px;
      border: 1px solid rgba(79, 70, 229, 0.12);
      top: -70px;
      right: -80px;
      animation: slow-spin 18s linear infinite;
      pointer-events: none;
    }

    @keyframes twinkle {
      0%, 100% { opacity: 0.35; transform: scale(0.9); }
      50% { opacity: 0.95; transform: scale(1.1); }
    }

    @keyframes slow-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body class="min-h-screen bg-[#f8fafc] text-slate-900 selection:bg-indigo-100 overflow-x-hidden relative">
  
  <!-- Background Decorations -->
  <div class="fixed inset-0 -z-10 overflow-hidden pointer-events-none">
    <div class="absolute -top-[10%] -left-[10%] w-[40%] h-[40%] bg-indigo-100 rounded-full blur-[120px] opacity-50"></div>
    <div class="absolute top-[40%] -right-[10%] w-[35%] h-[35%] bg-purple-100 rounded-full blur-[120px] opacity-40"></div>
  </div>

  <div class="max-w-4xl mx-auto px-4 py-8 md:py-12">
    
    <!-- Header -->
    <header class="flex items-center justify-between mb-10 slide-up">
      <div class="flex items-center gap-3">
        <div class="bg-indigo-600 p-2.5 rounded-2xl text-white shadow-lg shadow-indigo-200 cursor-pointer" onclick="resetApp()">
          <i data-lucide="brain-circuit" class="w-6 h-6"></i>
        </div>
        <div>
          <h1 class="text-xl font-black tracking-tight text-slate-800">DeepProfile <span class="text-indigo-600">AI</span></h1>
          <p class="text-[10px] font-bold text-slate-400 uppercase tracking-widest leading-none mt-1">Version 3.0 Auto-Sync</p>
        </div>
      </div>
      
      <div id="user-status" class="flex items-center gap-3">
        <button id="auth-btn" class="px-3 py-1.5 rounded-lg border border-slate-200 text-xs font-bold text-slate-700 hover:bg-slate-50 transition-colors">
          Googleでログイン
        </button>
        <div class="hidden sm:flex flex-col items-end">
          <span class="text-[10px] font-bold text-slate-400 uppercase tracking-tighter">Your ID</span>
          <span id="display-uid" class="text-[11px] font-mono text-slate-500 bg-slate-100 px-2 py-0.5 rounded">Connecting...</span>
        </div>
        <div id="phase-badge" class="hidden text-xs font-bold text-indigo-600 bg-indigo-50 border border-indigo-100 px-4 py-1.5 rounded-full">
          Phase 1
        </div>
      </div>
    </header>

    <main id="app-container" class="transition-all duration-500">

      <div class="mb-8">
        <div class="inline-flex items-center gap-2 bg-slate-100 border border-slate-200 rounded-2xl p-1.5">
          <button id="tab-profile" class="mode-tab is-active" onclick="switchMainTab('profile')" aria-selected="true">
            <span class="flex items-center gap-2">
              <i data-lucide="brain-circuit" class="w-4 h-4"></i>
              プロファイリング
            </span>
          </button>
          <button id="tab-fortune" class="mode-tab" onclick="switchMainTab('fortune')" aria-selected="false">
            <span class="flex items-center gap-2">
              <i data-lucide="sparkles" class="w-4 h-4"></i>
              占いモード
            </span>
          </button>
        </div>
      </div>
      
      <!-- Screen: Intro -->
      <div id="screen-intro" class="fade-in space-y-8">
        <div class="bg-white rounded-[2.5rem] p-8 md:p-12 shadow-xl shadow-indigo-100/50 border border-slate-100 relative overflow-hidden panel-strong">
          <div class="absolute top-0 right-0 p-8 opacity-10">
            <i data-lucide="sparkles" class="w-32 h-32 text-indigo-600"></i>
          </div>

          <div class="relative z-10 space-y-6 max-w-2xl">
            <h2 class="text-4xl md:text-5xl font-black tracking-tight text-slate-900 leading-[1.1]">
              MBTIをヒントに、<br/><span class="text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-purple-600">あなたらしさをやさしく読み解く。</span>
            </h2>
            <p class="text-slate-500 leading-relaxed text-lg">
              最新のBIG5理論とAI解析を統合。<span id="intro-question-count">22</span>問の設問と、AIがあなた専用に生成する「深層質問」への回答から、あなたに最適なかたちで診断結果をお届けします。
            </p>
            
            <div class="flex flex-col sm:flex-row gap-4 pt-4">
              <button onclick="startAssessment()" class="flex-1 bg-slate-900 hover:bg-slate-800 text-white font-bold py-5 px-8 rounded-2xl flex items-center justify-center gap-3 transition-all active:scale-[0.98] shadow-xl shadow-slate-200">
                プロファイリングを開始
                <i data-lucide="chevron-right" class="w-5 h-5"></i>
              </button>
              <button onclick="toggleHistory()" class="flex-1 bg-white hover:bg-slate-50 text-slate-700 border-2 border-slate-100 font-bold py-5 px-8 rounded-2xl flex items-center justify-center gap-3 transition-all active:scale-[0.98]">
                <i data-lucide="history" class="w-5 h-5"></i>
                診断履歴を見る
              </button>
            </div>
          </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
          <div class="feature-card p-6 rounded-[2rem] flex flex-col gap-3" style="--feature-accent: linear-gradient(90deg, #6366f1, #3b82f6);">
            <i data-lucide="fingerprint" class="text-indigo-600 w-8 h-8"></i>
            <h3 class="font-bold text-slate-800">唯一無二の分析</h3>
            <p class="text-sm text-slate-500 leading-relaxed">ありきたりな16タイプに当てはめるのではなく、あなたの言葉をAIが直接読み解きます。</p>
          </div>
          <div class="feature-card p-6 rounded-[2rem] flex flex-col gap-3" style="--feature-accent: linear-gradient(90deg, #8b5cf6, #ec4899);">
            <i data-lucide="database" class="text-purple-600 w-8 h-8"></i>
            <h3 class="font-bold text-slate-800">深層質問エンジン</h3>
            <p class="text-sm text-slate-500 leading-relaxed">回答傾向をもとに、次に答えるべき問いをAIが再構成し、診断の解像度を高めます。</p>
          </div>
          <div class="feature-card p-6 rounded-[2rem] flex flex-col gap-3" style="--feature-accent: linear-gradient(90deg, #f59e0b, #fb7185);">
            <i data-lucide="shield-check" class="text-amber-600 w-8 h-8"></i>
            <h3 class="font-bold text-slate-800">心理学的な裏付け</h3>
            <p class="text-sm text-slate-500 leading-relaxed">世界で最も信頼される性格特性論「BIG5」をベースにアルゴリズムを構築。</p>
          </div>
        </div>
      </div>

      <!-- Screen: Fortune -->
      <div id="screen-fortune" class="hidden fade-in space-y-8">
        <div class="fortune-shell rounded-[2.5rem] p-8 md:p-12 shadow-xl relative">
          <div class="fortune-stars">
            <span></span>
            <span></span>
            <span></span>
            <span></span>
          </div>
          <div class="fortune-orbit"></div>
          <i data-lucide="sun-moon" class="absolute -top-5 -right-5 w-32 h-32 text-amber-300 opacity-70"></i>
          <div class="relative z-10 max-w-2xl space-y-4">
            <span class="inline-flex items-center gap-2 px-4 py-1 rounded-full bg-white/85 border border-amber-200 text-amber-700 text-[10px] font-black uppercase tracking-[0.2em]">Fortune Mode</span>
            <h2 class="text-3xl md:text-4xl font-black text-slate-900 leading-tight">
              今年の流れを、<br/>立体的に読み解く。
            </h2>
            <p class="text-slate-600 leading-relaxed">
              星座・四柱推命・統計推定を統合し、今年の総合運と項目別AI分析を表示します。
            </p>
          </div>
        </div>

        <div class="bg-white/90 rounded-[2rem] p-6 md:p-8 border border-amber-100 shadow-lg space-y-5">
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <label class="space-y-2">
              <span class="text-xs font-black text-slate-500 uppercase tracking-widest">生年月日</span>
              <input id="fortune-birthdate" type="date" class="w-full bg-slate-50 border-2 border-slate-100 rounded-xl px-4 py-3 text-sm focus:outline-none focus:border-indigo-400 focus:bg-white transition-colors">
            </label>
            <label class="space-y-2">
              <span class="text-xs font-black text-slate-500 uppercase tracking-widest">出生時刻（任意）</span>
              <input id="fortune-birthtime" type="time" step="3600" class="w-full bg-slate-50 border-2 border-slate-100 rounded-xl px-4 py-3 text-sm focus:outline-none focus:border-indigo-400 focus:bg-white transition-colors">
            </label>
            <label class="space-y-2">
              <span class="text-xs font-black text-slate-500 uppercase tracking-widest">星座</span>
              <select id="fortune-sign" class="w-full bg-slate-50 border-2 border-slate-100 rounded-xl px-4 py-3 text-sm focus:outline-none focus:border-indigo-400 focus:bg-white transition-colors">
                <option value="aries">牡羊座</option>
                <option value="taurus">牡牛座</option>
                <option value="gemini">双子座</option>
                <option value="cancer">蟹座</option>
                <option value="leo">獅子座</option>
                <option value="virgo">乙女座</option>
                <option value="libra">天秤座</option>
                <option value="scorpio">蠍座</option>
                <option value="sagittarius">射手座</option>
                <option value="capricorn">山羊座</option>
                <option value="aquarius">水瓶座</option>
                <option value="pisces">魚座</option>
              </select>
            </label>
          </div>

          <button id="fortune-generate-btn" onclick="generateFortune()" class="w-full bg-slate-900 hover:bg-slate-800 text-white font-bold py-4 rounded-2xl flex items-center justify-center gap-2 transition-colors active:scale-[0.98]">
            <i data-lucide="stars" class="w-5 h-5 text-amber-300"></i>
            今年の総合運を診断する
          </button>

          <p id="fortune-save-status" class="text-xs font-semibold text-slate-500"></p>
          <p class="text-xs text-slate-400">※ この結果はエンタメ目的です。最終判断はご自身の意思を優先してください。</p>
        </div>

        <div id="fortune-result" class="hidden bg-gradient-to-br from-white via-rose-50/40 to-indigo-50 rounded-[2rem] p-6 md:p-8 border border-indigo-100 shadow-lg space-y-6">
          <div class="flex flex-wrap items-center justify-between gap-3">
            <span id="fortune-badge" class="inline-flex items-center gap-2 px-4 py-1 rounded-full border text-sm font-black"></span>
            <span id="fortune-date" class="text-xs font-bold text-slate-500"></span>
          </div>

          <div class="space-y-2">
            <p id="fortune-score" class="text-3xl md:text-4xl font-black text-indigo-700"></p>
            <div class="h-2 bg-indigo-100 rounded-full overflow-hidden">
              <div id="fortune-score-bar" class="h-full bg-gradient-to-r from-amber-400 via-rose-400 to-indigo-500 transition-all duration-500" style="width: 0%"></div>
            </div>
          </div>

          <div class="bg-white rounded-xl border border-slate-100 p-5 space-y-2">
            <p id="fortune-seijin" class="text-xl md:text-2xl font-black text-indigo-700"></p>
            <p id="fortune-seijin-sub" class="text-sm text-slate-600 leading-relaxed"></p>
            <p id="fortune-pillars" class="text-xs font-mono text-slate-500"></p>
          </div>

          <div class="bg-indigo-50 rounded-xl border border-indigo-100 p-4 space-y-2">
            <p class="text-[11px] font-black uppercase tracking-widest text-indigo-500">統計推定</p>
            <p id="fortune-stat" class="text-sm text-indigo-800 leading-relaxed"></p>
          </div>

          <p id="fortune-main" class="text-slate-700 leading-relaxed"></p>

          <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
            <div class="bg-white rounded-xl border border-slate-100 p-4 space-y-2">
              <p class="text-[10px] font-black uppercase tracking-widest text-indigo-500">四半期見通し</p>
              <p id="fortune-quarterly" class="text-sm text-slate-700 leading-relaxed"></p>
            </div>
            <div class="bg-white rounded-xl border border-slate-100 p-4 space-y-2">
              <p class="text-[10px] font-black uppercase tracking-widest text-emerald-500">追い風シグナル</p>
              <p id="fortune-opportunity" class="text-sm text-slate-700 leading-relaxed"></p>
            </div>
            <div class="bg-white rounded-xl border border-slate-100 p-4 space-y-2">
              <p class="text-[10px] font-black uppercase tracking-widest text-rose-500">注意シナリオ</p>
              <p id="fortune-risk" class="text-sm text-slate-700 leading-relaxed"></p>
            </div>
            <div class="bg-white rounded-xl border border-slate-100 p-4 space-y-2">
              <p class="text-[10px] font-black uppercase tracking-widest text-violet-500">開運ルーティン</p>
              <p id="fortune-routine" class="text-sm text-slate-700 leading-relaxed"></p>
            </div>
            <div class="bg-white rounded-xl border border-slate-100 p-4 space-y-2">
              <p class="text-[10px] font-black uppercase tracking-widest text-cyan-500">転機ポイント</p>
              <p id="fortune-turning" class="text-sm text-slate-700 leading-relaxed"></p>
            </div>
            <div class="bg-white rounded-xl border border-slate-100 p-4 space-y-2">
              <p class="text-[10px] font-black uppercase tracking-widest text-amber-500">確率レンジ</p>
              <p id="fortune-probability" class="text-sm text-slate-700 leading-relaxed"></p>
            </div>
          </div>

          <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
            <div class="bg-white rounded-xl border border-slate-100 p-4 space-y-1">
              <p class="text-[10px] font-black uppercase tracking-widest text-slate-400">ラッキーカラー</p>
              <p id="fortune-color" class="text-sm font-bold text-slate-700"></p>
            </div>
            <div class="bg-white rounded-xl border border-slate-100 p-4 space-y-1">
              <p class="text-[10px] font-black uppercase tracking-widest text-slate-400">ラッキーアイテム</p>
              <p id="fortune-item" class="text-sm font-bold text-slate-700"></p>
            </div>
            <div class="bg-white rounded-xl border border-slate-100 p-4 space-y-1">
              <p class="text-[10px] font-black uppercase tracking-widest text-slate-400">ラッキータイム</p>
              <p id="fortune-time" class="text-sm font-bold text-slate-700"></p>
            </div>
          </div>

          <div class="bg-white rounded-xl border border-slate-100 p-5 space-y-3">
            <p class="text-xs font-black uppercase tracking-widest text-indigo-500">行動アドバイス</p>
            <p id="fortune-action" class="text-sm text-slate-700 leading-relaxed"></p>
            <p class="text-xs font-black uppercase tracking-widest text-rose-500 pt-2 border-t border-slate-100">注意点</p>
            <p id="fortune-caution" class="text-sm text-slate-600 leading-relaxed"></p>
          </div>

          <div class="pt-2 space-y-4">
            <div class="flex items-center gap-2">
              <i data-lucide="sparkles" class="w-5 h-5 text-violet-500"></i>
              <h4 class="text-sm font-black uppercase tracking-widest text-violet-600">AI詳細占い</h4>
            </div>
            <div id="fortune-topics-container" class="grid grid-cols-1 md:grid-cols-2 gap-4">
              <!-- Deep topic cards injected here -->
            </div>
          </div>
        </div>

        <div class="bg-white/90 rounded-[2rem] p-6 md:p-8 border border-slate-100 shadow-lg space-y-4">
          <div class="flex items-center justify-between">
            <h3 class="text-lg font-black text-slate-800 flex items-center gap-2">
              <i data-lucide="clock-3" class="w-5 h-5 text-indigo-500"></i>
              占い履歴
            </h3>
            <span class="text-[11px] font-bold text-slate-400 uppercase tracking-widest">クラウド保存</span>
          </div>
          <div id="fortune-history-list" class="grid grid-cols-1 gap-3">
            <div class="p-6 text-center text-slate-400 italic bg-slate-50 rounded-2xl border border-dashed border-slate-200">
              ログインすると占い履歴がここに表示されます。
            </div>
          </div>
        </div>
      </div>

      <!-- Screen: History -->
      <div id="screen-history" class="hidden fade-in space-y-6">
        <div class="flex items-center justify-between">
          <h2 class="text-2xl font-black text-slate-800 flex items-center gap-3">
            <i data-lucide="history" class="text-indigo-600"></i>
            診断履歴
          </h2>
          <button onclick="showScreen('intro')" class="text-sm font-bold text-slate-500 hover:text-indigo-600 transition-colors">
            トップに戻る
          </button>
        </div>
        
        <div id="history-list" class="grid grid-cols-1 gap-4">
          <!-- History items will be injected here -->
          <div class="p-12 text-center text-slate-400 italic bg-white rounded-3xl border border-dashed border-slate-200">
            履歴がありません。まずは診断を受けてみましょう。
          </div>
        </div>
      </div>

      <!-- Screen: Questions -->
      <div id="screen-questions" class="hidden glass rounded-[2.5rem] p-8 md:p-12 shadow-2xl space-y-10">
        <div class="space-y-4">
          <div class="flex justify-between items-end">
            <span class="text-xs font-black uppercase tracking-[0.2em] text-indigo-600">Phase 1: Base Analysis</span>
            <span id="q-progress-text" class="text-sm font-mono font-bold text-slate-400">01 / 16</span>
          </div>
          <div class="w-full bg-slate-100 rounded-full h-1.5 overflow-hidden">
            <div id="q-progress-bar" class="bg-indigo-600 h-full transition-all duration-500 ease-out" style="width: 0%"></div>
          </div>
        </div>

        <div class="min-h-[140px] flex items-center">
          <h3 id="question-text" class="text-2xl md:text-3xl font-black text-slate-800 leading-tight"></h3>
        </div>

        <div class="grid grid-cols-1 gap-3" id="options-container">
          <!-- Options injected here -->
        </div>
      </div>

      <!-- Screen: Dynamic Question (Generating & Answering) -->
      <div id="screen-generating-q" class="hidden flex flex-col items-center justify-center py-24 space-y-8 text-center bg-white rounded-[2.5rem] shadow-xl">
        <div id="dynamic-q-loading" class="flex flex-col items-center justify-center space-y-8 text-center">
          <div class="loader-ring"></div>
          <div class="space-y-2">
            <h3 class="text-2xl font-black text-slate-800">あなたの思考をトレース中</h3>
            <p class="text-slate-500">回答パターンから、あなた向けの3問を生成しています...</p>
          </div>
        </div>
        <div id="dynamic-q-error" class="hidden w-full max-w-xl px-6">
          <div class="bg-rose-50 border border-rose-100 rounded-2xl p-6 space-y-5">
            <div class="space-y-2">
              <h3 class="text-xl font-black text-rose-700">質問の生成に失敗しました</h3>
              <p id="dynamic-q-error-text" class="text-sm text-rose-700"></p>
              <p id="dynamic-q-retry-countdown" class="hidden text-xs font-bold text-rose-600"></p>
            </div>
            <div class="flex flex-col sm:flex-row gap-3">
              <button id="dynamic-q-retry-btn" onclick="retryDynamicQuestions()" class="flex-1 bg-rose-600 hover:bg-rose-700 text-white font-bold py-3 px-4 rounded-xl transition-colors disabled:opacity-60 disabled:cursor-not-allowed">
                再問い合わせする
              </button>
              <button onclick="showScreen('questions')" class="flex-1 bg-white hover:bg-slate-50 text-slate-700 border border-slate-200 font-bold py-3 px-4 rounded-xl transition-colors">
                戻る
              </button>
            </div>
          </div>
        </div>
      </div>

      <div id="screen-dynamic-question" class="hidden space-y-8">
        <div class="bg-indigo-600 text-white p-8 rounded-[2.5rem] shadow-xl relative overflow-hidden">
          <i data-lucide="sparkles" class="absolute -bottom-4 -right-4 w-32 h-32 opacity-20"></i>
          <div class="relative z-10">
            <span class="inline-block px-3 py-1 bg-white/20 rounded-lg text-[10px] font-bold uppercase tracking-widest mb-4">Phase 2: Deep Dive</span>
            <h2 class="text-2xl md:text-3xl font-black">AIが生成した「3つの鍵」</h2>
            <p class="text-indigo-100 mt-2 text-sm md:text-base">これらの問いにどう答えるかで、あなたの輪郭が決定します。</p>
          </div>
        </div>

        <div id="dynamic-questions-container" class="space-y-6">
          <!-- Dynamic questions injected here -->
        </div>

        <div id="gemini-status-bar" class="hidden bg-amber-50 border border-amber-100 rounded-xl px-4 py-3">
          <p id="gemini-status-text" class="text-sm font-bold text-amber-700"></p>
        </div>

        <button id="analyze-btn" onclick="submitFreeText()" class="w-full bg-slate-900 hover:bg-slate-800 text-white font-bold py-5 rounded-2xl flex items-center justify-center gap-3 shadow-xl transition-all active:scale-[0.98] disabled:opacity-50 disabled:cursor-not-allowed">
          最終解析を実行する
          <i data-lucide="zap" class="w-5 h-5 text-amber-400 fill-amber-400"></i>
        </button>
      </div>

      <!-- Screen: Analyzing -->
      <div id="screen-analyzing" class="hidden flex flex-col items-center justify-center py-24 space-y-8 text-center bg-slate-900 rounded-[2.5rem] shadow-2xl text-white">
        <div class="loader-ring !border-white/10 !border-top-white"></div>
        <div class="space-y-3">
          <h3 class="text-2xl font-black">ディーププロファイリング中</h3>
          <p class="text-slate-400 max-w-sm mx-auto">100億通りの性格マトリックスと照合し、<br/>あなただけの定義を構築しています...</p>
        </div>
      </div>

      <!-- Screen: Result -->
      <div id="screen-result" class="hidden space-y-10">
        <!-- Hero Catchphrase -->
        <div class="bg-gradient-to-br from-pink-50 via-violet-50 to-sky-50 rounded-[2.5rem] p-10 md:p-16 text-center space-y-6 shadow-xl border border-violet-100 relative overflow-hidden">
          <div class="absolute inset-0 bg-gradient-to-b from-white/40 to-transparent"></div>
          <div class="relative z-10 space-y-4">
            <span class="inline-block px-4 py-1 rounded-full bg-white/80 border border-violet-200 text-violet-500 font-bold text-[10px] tracking-[0.3em] uppercase">Result Identity</span>
            <h2 id="res-catchphrase" class="text-3xl md:text-6xl font-black text-transparent bg-clip-text bg-gradient-to-r from-fuchsia-500 via-indigo-500 to-sky-500 animate-gradient pb-2"></h2>
            <p id="res-wit" class="hidden text-sm md:text-base font-semibold text-indigo-700"></p>
          </div>
        </div>

        <!-- Metrics & Main Analysis -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
          <div class="bg-gradient-to-br from-cyan-50 to-indigo-50 rounded-[2.5rem] p-8 shadow-xl border border-cyan-100 flex flex-col items-center">
            <h3 class="text-xs font-black text-cyan-600 uppercase tracking-widest mb-8">Personality Spectrum</h3>
            <div id="radar-chart-container" class="w-full aspect-square max-w-[320px]"></div>
          </div>

          <div class="space-y-6">
            <div class="bg-gradient-to-br from-violet-300 to-indigo-300 text-white rounded-[2rem] p-8 shadow-lg relative overflow-hidden h-full">
              <i data-lucide="quote" class="absolute top-4 right-6 w-12 h-12 opacity-25"></i>
              <h3 class="text-lg font-bold mb-4 flex items-center gap-2">
                <i data-lucide="scan-face" class="w-5 h-5"></i>
                Base Insight
              </h3>
              <p id="res-analysis" class="text-white/95 leading-relaxed font-medium"></p>
            </div>
          </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <div class="bg-gradient-to-br from-sky-50 to-indigo-50 rounded-[2rem] p-8 border border-sky-100 space-y-5">
            <h4 class="text-sky-700 font-black flex items-center gap-2">
              <i data-lucide="activity" class="w-5 h-5"></i>
              BIG5 Scores
            </h4>
            <div id="res-big5" class="grid grid-cols-1 md:grid-cols-2 gap-3"></div>
          </div>

          <div class="bg-gradient-to-br from-emerald-50 to-teal-50 rounded-[2rem] p-8 border border-emerald-100 space-y-5">
            <h4 class="text-emerald-700 font-black flex items-center gap-2">
              <i data-lucide="compass" class="w-5 h-5"></i>
              RIASEC Aptitude
            </h4>
            <div id="res-riasec" class="grid grid-cols-1 md:grid-cols-2 gap-3"></div>
          </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <div class="bg-gradient-to-r from-emerald-50 to-cyan-50 rounded-[2rem] p-8 border border-emerald-100 space-y-3">
            <h4 class="text-emerald-700 font-black flex items-center gap-2">
              <i data-lucide="badge-check" class="w-5 h-5"></i>
              診断の信頼度
            </h4>
            <p id="res-confidence-level" class="text-2xl font-black text-emerald-700"></p>
            <p id="res-confidence-note" class="text-sm text-emerald-700 leading-relaxed"></p>
            <p id="res-model-used" class="text-xs text-emerald-700/90 font-semibold"></p>
          </div>
          <div class="bg-gradient-to-r from-slate-50 to-indigo-50 rounded-[2rem] p-8 border border-slate-200 space-y-3">
            <h4 class="text-slate-700 font-black flex items-center gap-2">
              <i data-lucide="git-compare-arrows" class="w-5 h-5"></i>
              前回からの変化
            </h4>
            <p id="res-history-compare" class="text-sm text-slate-700 leading-relaxed"></p>
          </div>
        </div>

        <div class="bg-gradient-to-r from-indigo-50 to-cyan-50 rounded-[2rem] p-8 border border-indigo-100 space-y-4">
          <h4 class="text-indigo-700 font-black flex items-center gap-2">
            <i data-lucide="git-merge" class="w-5 h-5"></i>
            Hybrid Synthesis (BIG5 × RIASEC × Deep Answers)
          </h4>
          <p id="res-hybrid" class="text-indigo-800 text-sm md:text-base leading-relaxed"></p>
          <p id="res-evidence" class="text-xs md:text-sm text-indigo-600/90 leading-relaxed"></p>
        </div>

        <div class="bg-gradient-to-r from-amber-50 to-rose-50 rounded-[2rem] p-8 border border-amber-100 space-y-4">
          <h4 class="text-rose-700 font-black flex items-center gap-2">
            <i data-lucide="eye" class="w-5 h-5"></i>
            Hidden Self (隠された欲求)
          </h4>
          <p id="res-hidden" class="text-rose-700 text-sm md:text-base leading-relaxed"></p>
        </div>

        <!-- Extra Topics Generation -->
        <div class="space-y-6 pt-8">
          <div class="flex items-center gap-3 px-2">
            <div class="bg-gradient-to-br from-fuchsia-100 to-indigo-100 p-2 rounded-xl border border-fuchsia-200">
              <i data-lucide="layers" class="w-5 h-5 text-fuchsia-600"></i>
            </div>
            <div>
              <h3 class="text-xl md:text-2xl font-black text-indigo-700">Deep Exploration</h3>
              <p class="text-xs font-bold text-indigo-400 mt-0.5">知りたい項目を選んでAIに深く掘り下げさせましょう</p>
            </div>
          </div>
          
          <div id="extra-topics-container" class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <!-- Topics injected here -->
          </div>
        </div>

        <!-- Actions -->
        <div class="flex flex-col sm:flex-row gap-4 justify-center pt-10 border-t border-indigo-100">
          <button onclick="toggleHistory()" class="bg-indigo-50 hover:bg-indigo-100 text-indigo-700 border-2 border-indigo-100 font-bold py-4 px-8 rounded-2xl flex items-center justify-center gap-3 transition-all active:scale-[0.98]">
            <i data-lucide="list" class="w-5 h-5"></i>
            履歴一覧を見る
          </button>
          <button onclick="resetApp()" class="bg-gradient-to-r from-violet-500 to-indigo-500 hover:from-violet-600 hover:to-indigo-600 text-white font-bold py-4 px-8 rounded-2xl flex items-center justify-center gap-3 transition-all active:scale-[0.98]">
            <i data-lucide="rotate-ccw" class="w-5 h-5"></i>
            新しく診断する
          </button>
        </div>
      </div>

    </main>

    <!-- Footer -->
    <footer class="mt-16 text-center text-slate-400 text-xs pb-10 space-y-2">
      <p>&copy; 2024 DeepProfile AI. All rights reserved.</p>
      <p class="font-mono opacity-50">Experimental Cognitive Analysis Model v3.0</p>
    </footer>
  </div>

  <script type="module">
    import { initializeApp, getApp, getApps } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, collection, onSnapshot, addDoc, updateDoc, serverTimestamp, query, orderBy, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- Config & Globals ---
    const GEMINI_PROXY_ENDPOINT = "/api/gemini-seikaku";
    
    const FIREBASE_CONFIG_ENDPOINTS = ["/api/firebase-config-antiage", "/api/firebase-config-mental"];
    const FIREBASE_APP_NAME = "antiage-auth";
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const HISTORY_LIMIT = 10;
    const FORTUNE_HISTORY_LIMIT = 10;

    let app = null;
    let auth = null;
    let db = null;
    let authProvider = null;
    let user = null;
    let historyUnsub = null;
    let historyData = [];
    let fortuneHistoryUnsub = null;
    let fortuneHistoryData = [];
    let currentFortuneRecord = null;
    let currentFortuneDocId = null;
    let currentDocId = null; // To track currently viewed/saved document

    // --- State & Constants ---
    const QUESTIONS = [
      { id: 'O1', type: 'Openness', text: '新しいやり方を試すのが好きだ。' },
      { id: 'O2', type: 'Openness', text: '慣れた方法より、未知の方法にわくわくする。' },

      { id: 'C1', type: 'Conscientiousness', text: '締切から逆算して行動するほうだ。' },
      { id: 'C2', type: 'Conscientiousness', text: '面倒な作業でも最後までやり切る。' },

      { id: 'E1', type: 'Extraversion', text: '初対面でも自分から話しかけやすい。' },
      { id: 'E2', type: 'Extraversion', text: '大人数の場に行くとエネルギーが上がる。' },

      { id: 'AG1', type: 'Agreeableness', text: '意見が違っても相手の立場を考えて話す。' },
      { id: 'AG2', type: 'Agreeableness', text: '対立よりも合意点を探すほうだ。' },

      { id: 'N1', type: 'Neuroticism', text: '小さな失敗を長く気にしやすい。' },
      { id: 'N2', type: 'Neuroticism', text: '予想外の出来事で気持ちが乱れやすい。' },

      { id: 'R1', type: 'Realistic', text: '手を動かして形にする作業が好きだ。' },
      { id: 'R2', type: 'Realistic', text: '体を使う実務のほうが集中しやすい。' },

      { id: 'I1', type: 'Investigative', text: '原因を分析して筋道で考えるのが好きだ。' },
      { id: 'I2', type: 'Investigative', text: 'データや根拠を調べて判断したい。' },

      { id: 'AR1', type: 'Artistic', text: '文章やデザインで自分らしさを表現したい。' },
      { id: 'AR2', type: 'Artistic', text: '正解のない課題を工夫するのが好きだ。' },

      { id: 'S1', type: 'Social', text: '人の相談に乗るとやりがいを感じる。' },
      { id: 'S2', type: 'Social', text: '誰かの成長を支える役割が向いている。' },

      { id: 'EN1', type: 'Enterprising', text: '目標達成のために周囲を動かすのが得意だ。' },
      { id: 'EN2', type: 'Enterprising', text: '提案や交渉の場で前に出るほうだ。' },

      { id: 'CV1', type: 'Conventional', text: '手順やルールに沿って正確に進めるのが得意だ。' },
      { id: 'CV2', type: 'Conventional', text: '記録や整理をきちんと行うと安心する。' }
    ];

    const introQuestionCountEl = document.getElementById('intro-question-count');
    if (introQuestionCountEl) {
      introQuestionCountEl.textContent = String(QUESTIONS.length);
    }

    const OPTIONS = [
      { label: '全くない', value: 1, color: 'bg-rose-50 text-rose-700 hover:bg-rose-100 border-rose-200' },
      { label: 'あまりない', value: 2, color: 'bg-orange-50 text-orange-700 hover:bg-orange-100 border-orange-200' },
      { label: 'どちらでもない', value: 3, color: 'bg-slate-50 text-slate-700 hover:bg-slate-100 border-slate-200' },
      { label: 'ややある', value: 4, color: 'bg-emerald-50 text-emerald-700 hover:bg-emerald-100 border-emerald-200' },
      { label: '非常にある', value: 5, color: 'bg-indigo-50 text-indigo-700 hover:bg-indigo-100 border-indigo-200' }
    ];

    const BIG5_TRAITS = ['Openness', 'Conscientiousness', 'Extraversion', 'Agreeableness', 'Neuroticism'];
    const BIG5_LABELS = {
      Openness: '開放性',
      Conscientiousness: '誠実性',
      Extraversion: '外向性',
      Agreeableness: '協調性',
      Neuroticism: '神経傾向'
    };

    const RIASEC_TRAITS = ['Realistic', 'Investigative', 'Artistic', 'Social', 'Enterprising', 'Conventional'];
    const RIASEC_LABELS = {
      Realistic: 'Realistic',
      Investigative: 'Investigative',
      Artistic: 'Artistic',
      Social: 'Social',
      Enterprising: 'Enterprising',
      Conventional: 'Conventional'
    };

    const EXTRA_TOPICS = [
      { id: 'romance', title: '恋愛・パートナーシップ', icon: 'heart', prompt: 'この人物の恋愛傾向、惹かれる相手のタイプ、パートナーとしてうまくいくための条件を詳細に分析してください。（700〜1000字程度）' },
      { id: 'career', title: '天職とキャリア', icon: 'briefcase', prompt: 'この人物の才能が最も活きる職業環境、絶対に避けるべき職場、リーダーシップのスタイルについて詳細に分析してください。（700〜1000字程度）' },
      { id: 'stress', title: 'ストレスと地雷ポイント', icon: 'bomb', prompt: 'この人物が密かにストレスを抱える要因、激怒する・あるいは心を閉ざす「地雷」ポイントとその対処法を詳細に分析してください。（700〜1000字程度）' },
      { id: 'talent', title: '隠された才能', icon: 'sparkles', prompt: '本人がまだ自覚していない可能性が高い、他の人にはない特異な才能やポテンシャルについて詳細に分析してください。（700〜1000字程度）' },
      { id: 'money', title: '金銭感覚とリスク', icon: 'coins', prompt: 'この人物のお金に対する価値観、浪費しやすいポイント、リスクを取る際の思考回路について詳細に分析してください。（700〜1000字程度）' },
      { id: 'darkside', title: '人間関係のダークサイド', icon: 'moon', prompt: '極限のストレス下や絶望した時に現れる「闇落ち」した姿（シャドウ）と、他者を無意識にコントロールしようとする際の癖について詳細に分析してください。（700〜1000字程度）' },
      { id: 'growth', title: '人生最大の壁と突破口', icon: 'mountain', prompt: 'この人物が人生で何度もぶつかるであろう本質的な「壁」と、それを乗り越えるための具体的な突破口について詳細に分析してください。（700〜1000字程度）' },
      { id: 'lifestyle', title: '究極の理想のライフスタイル', icon: 'coffee', prompt: 'この人物が心からの安らぎと充実を感じる、究極的に理想とする生活環境や日常のルーティンについて詳細に分析してください。（700〜1000字程度）' }
    ];

    const FORTUNE_SIGN_LABELS = {
      aries: '牡羊座',
      taurus: '牡牛座',
      gemini: '双子座',
      cancer: '蟹座',
      leo: '獅子座',
      virgo: '乙女座',
      libra: '天秤座',
      scorpio: '蠍座',
      sagittarius: '射手座',
      capricorn: '山羊座',
      aquarius: '水瓶座',
      pisces: '魚座'
    };

    const FORTUNE_FOCUS_LABELS = {
      overall: '総合運',
      work: '仕事運',
      love: '恋愛運',
      money: '金運',
      health: '健康運',
      relationship: '対人運'
    };

    const FORTUNE_MESSAGES = {
      overall: [
        '今年は「先に小さく動く」ほど流れが整います。完璧な準備より、着手の速さが追い風になります。',
        '周囲のペースより、自分の集中リズムを優先するほど、年間の成果が安定します。',
        '迷ったらシンプルな選択が吉。情報を増やすより、判断基準をひとつに絞ると運が開きます。'
      ],
      work: [
        '詰まりやすい案件ほど、最初に論点を3つに整理すると一気に進みます。',
        '頼まれごとは抱え込まず、期限と期待値を先に合わせるほど年間評価が上がります。',
        '判断は「今決めること」と「後で決めること」を分けると、仕事運が安定します。'
      ],
      love: [
        '言葉より温度感が伝わる年です。短いメッセージでも、素直さを添えると好印象です。',
        '相手を変えるより、自分の期待値を明確にすると関係が整いやすくなります。',
        '距離を詰めるなら、結論より「最近どう？」の軽い対話が吉です。'
      ],
      money: [
        '衝動買いより比較検討が効く日。欲しい理由を一晩寝かせると判断精度が上がります。',
        '固定費を一つ見直すだけで運気が整います。大きな節約より継続がカギです。',
        '得する話ほど条件確認を丁寧に。小さな注意で大きなロスを回避できます。'
      ],
      health: [
        '集中力は高めですが、疲労のサインを見逃しやすい日。こまめな水分補給が吉です。',
        '睡眠の質が運気を左右します。就寝前30分のスマホ時間を短くすると安定します。',
        '軽いストレッチで気分が切り替わります。身体を先に動かすと心も整います。'
      ],
      relationship: [
        '意見が違う場面ほど、相手の意図を一度言い換えると関係運が上向きます。',
        '今年は聞き役が効く局面が増えます。アドバイスより共感の一言が信頼を深めます。',
        'やり取りの齟齬は早めの確認で解決できます。曖昧なまま進めないのが吉です。'
      ]
    };

    const FORTUNE_ACTION_TIPS = [
      '毎週「最重要タスク」を1つだけ先に終える。',
      '週1回、机やデスクトップを整理して思考をクリアにする。',
      '連絡は短く具体的に。締切と目的を一文で添える。',
      '判断に迷ったら、信頼できる人に論点を1点だけ相談する。',
      '月初に翌週の準備を先に1つ済ませる習慣を作る。'
    ];

    const FORTUNE_CAUTIONS = [
      '急ぎの返答ほど語尾が強くなりやすい日。送信前に一度読み返すと安心です。',
      '予定を詰め込みすぎると判断が粗くなります。余白を30分確保すると安定します。',
      '疲れているときの即断は避けるのが吉。大事な決定は時間を置いて。',
      '「なんとなく不安」で先延ばししがち。最初の3分だけ着手すると流れが戻ります。',
      '他人のペースに合わせすぎると消耗します。自分の優先順位を再確認してください。'
    ];

    const FORTUNE_LUCKY_COLORS = [
      'インディゴ', 'コーラル', 'ミントグリーン', 'サンドベージュ', 'ネイビー', 'ローズピンク'
    ];

    const FORTUNE_LUCKY_ITEMS = [
      '白いノート', 'ステンレスボトル', 'イヤホン', 'ハンドクリーム', '小さめのポーチ', '付箋'
    ];

    const FORTUNE_LUCKY_TIMES = [
      '07:40〜08:20', '10:10〜10:40', '12:30〜13:00', '15:10〜15:50', '18:20〜19:00', '21:10〜21:40'
    ];

    const HEAVENLY_STEMS = ['甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸'];
    const EARTHLY_BRANCHES = ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥'];
    const TRAIT_LABELS = ['推進力', '論理性', '共感性', '安定性', '創造性', '適応力'];

    const STEM_TRAIT_MAP = {
      甲: [0.82, 0.34, -0.08, 0.21, 0.44, 0.52],
      乙: [0.28, 0.49, 0.42, 0.36, 0.62, 0.46],
      丙: [0.9, 0.22, 0.27, -0.12, 0.72, 0.37],
      丁: [0.36, 0.43, 0.58, 0.18, 0.82, 0.24],
      戊: [0.45, 0.56, 0.02, 0.86, 0.11, -0.18],
      己: [0.16, 0.63, 0.29, 0.9, 0.06, -0.08],
      庚: [0.74, 0.86, -0.19, 0.52, 0.21, 0.14],
      辛: [0.34, 0.74, 0.14, 0.66, 0.49, 0.06],
      壬: [0.67, 0.62, 0.18, -0.02, 0.58, 0.9],
      癸: [0.18, 0.7, 0.48, 0.08, 0.42, 0.84]
    };

    const BRANCH_TRAIT_MAP = {
      子: [0.58, 0.63, 0.21, 0.1, 0.4, 0.88],
      丑: [0.11, 0.57, 0.26, 0.9, 0.05, -0.08],
      寅: [0.86, 0.42, 0.04, 0.2, 0.49, 0.55],
      卯: [0.24, 0.38, 0.64, 0.3, 0.71, 0.43],
      辰: [0.42, 0.72, 0.2, 0.59, 0.32, 0.39],
      巳: [0.69, 0.67, 0.12, 0.11, 0.61, 0.51],
      午: [0.92, 0.24, 0.29, -0.09, 0.73, 0.33],
      未: [0.15, 0.44, 0.62, 0.73, 0.41, 0.22],
      申: [0.63, 0.86, 0.03, 0.38, 0.34, 0.57],
      酉: [0.27, 0.77, 0.15, 0.68, 0.54, 0.07],
      戌: [0.46, 0.59, 0.11, 0.84, 0.23, 0.16],
      亥: [0.35, 0.54, 0.53, 0.12, 0.57, 0.82]
    };

    const SIGN_TRAIT_BONUS = {
      aries: [0.12, -0.03, -0.04, -0.01, 0.03, 0.06],
      taurus: [-0.04, 0.02, 0.04, 0.08, -0.01, -0.02],
      gemini: [0.04, 0.08, 0.03, -0.05, 0.07, 0.09],
      cancer: [-0.02, -0.03, 0.1, 0.05, 0.03, 0.04],
      leo: [0.1, -0.02, 0.02, -0.03, 0.09, 0.03],
      virgo: [-0.03, 0.1, 0.02, 0.09, -0.02, -0.01],
      libra: [0.02, 0.03, 0.11, 0.01, 0.05, 0.04],
      scorpio: [0.05, 0.05, 0.01, 0.03, 0.04, 0.06],
      sagittarius: [0.09, 0.02, 0.01, -0.04, 0.08, 0.11],
      capricorn: [0.03, 0.08, -0.02, 0.11, -0.03, -0.04],
      aquarius: [0.04, 0.06, 0.05, -0.03, 0.1, 0.12],
      pisces: [-0.01, 0.01, 0.12, 0.02, 0.06, 0.08]
    };

    const SEIJIN_ARCHETYPES = [
      { id: 'mercury', name: '水星星人', vector: [0.88, 0.52, 0.14, 0.28, 0.44, 0.51], desc: '判断と着手が速く、流れを先に作るタイプ。' },
      { id: 'venus', name: '金星星人', vector: [0.42, 0.9, 0.12, 0.62, 0.32, 0.28], desc: '設計力とバランス感覚で成果を積み上げるタイプ。' },
      { id: 'earth', name: '地球星人', vector: [0.16, 0.38, 0.92, 0.56, 0.42, 0.33], desc: '共感と安定感で周囲との調和を育てるタイプ。' },
      { id: 'mars', name: '火星星人', vector: [0.24, 0.72, 0.22, 0.92, 0.2, 0.14], desc: '粘り強くやり切り、結果に結びつけるタイプ。' },
      { id: 'jupiter', name: '木星星人', vector: [0.52, 0.58, 0.24, 0.1, 0.84, 0.93], desc: '拡張思考と柔軟性で可能性を広げるタイプ。' },
      { id: 'saturn', name: '土星星人', vector: [0.69, 0.3, 0.46, 0.09, 0.95, 0.4], desc: '表現力と一貫性で信頼を獲得するタイプ。' },
      { id: 'uranus', name: '天王星星人', vector: [0.2, 0.49, 0.77, 0.84, 0.18, 0.19], desc: '秩序を守りつつ、関係性を安定化させるタイプ。' },
      { id: 'neptune', name: '海王星星人', vector: [0.37, 0.87, 0.29, 0.29, 0.57, 0.71], desc: '直感と分析を往復して本質へ迫るタイプ。' }
    ];

    const FOCUS_WEIGHTS = {
      overall: [0.2, 0.2, 0.2, 0.15, 0.1, 0.15],
      work: [0.24, 0.24, 0.08, 0.24, 0.08, 0.12],
      love: [0.08, 0.08, 0.35, 0.12, 0.12, 0.25],
      money: [0.15, 0.3, 0.05, 0.35, 0.05, 0.1],
      health: [0.12, 0.12, 0.17, 0.34, 0.05, 0.2],
      relationship: [0.1, 0.15, 0.36, 0.18, 0.08, 0.13]
    };

    const FORTUNE_DEEP_TOPICS = [
      { id: "love", title: "恋愛運", icon: "heart", prompt: "今年の恋愛運。出会い・関係維持・避けるべきパターン・具体行動を詳述。" },
      { id: "money", title: "金運", icon: "coins", prompt: "今年の金運。収支改善・投資/消費判断・損失回避の具体策を詳述。" },
      { id: "work", title: "仕事運", icon: "briefcase", prompt: "今年の仕事運。成果を出しやすい局面、昇進/転職判断、注意点を詳述。" },
      { id: "health", title: "健康運", icon: "activity", prompt: "今年の健康運。コンディション管理、崩れやすい時期、実行しやすい習慣を詳述。" },
      { id: "relationship", title: "対人運", icon: "users", prompt: "今年の対人運。人間関係の伸ばし方、衝突回避、信頼構築の実践策を詳述。" },
      { id: "growth", title: "開運戦略", icon: "mountain", prompt: "今年を伸ばす戦略。上半期/下半期の勝ち筋、優先順位、行動計画を詳述。" }
    ];

    let currentQIndex = 0;
    let answers = {};
    let baseScores = {};
    let riasecScores = {};
    let dynamicQuestions = [];
    let finalProfile = null;
    let isAnswering = false;
    let isGeneratingDynamicQuestions = false;
    let isSubmittingProfile = false;
    let geminiCooldownUntilMs = 0;
    let geminiCooldownTimer = null;
    let lastGeminiMeta = { model: "", fallbackUsed: false, at: 0 };

    // --- Firebase Auth ---
    function parseFirebaseConfigCandidate(candidate) {
      if (!candidate) return null;
      if (typeof candidate === "string") {
        try {
          return JSON.parse(candidate);
        } catch {
          return null;
        }
      }
      if (typeof candidate === "object") return candidate;
      return null;
    }

    function isValidFirebaseConfig(config) {
      return !!(config && config.apiKey && config.projectId && config.authDomain);
    }

    function readFirebaseConfigRuntime() {
      const direct = parseFirebaseConfigCandidate(typeof __firebase_config !== "undefined" ? __firebase_config : null);
      if (isValidFirebaseConfig(direct)) return direct;

      const fromWindow = parseFirebaseConfigCandidate(window.__FIREBASE_CONFIG__);
      if (isValidFirebaseConfig(fromWindow)) return fromWindow;

      const meta = document.querySelector('meta[name="firebase-config"]');
      const fromMeta = parseFirebaseConfigCandidate(meta?.content);
      if (isValidFirebaseConfig(fromMeta)) return fromMeta;
      return null;
    }

    async function fetchFirebaseConfigFromServer() {
      for (const endpoint of FIREBASE_CONFIG_ENDPOINTS) {
        try {
          const res = await fetch(endpoint, { method: "GET", cache: "no-store" });
          if (!res.ok) continue;
          const data = await res.json();
          if (isValidFirebaseConfig(data)) return data;
        } catch {}
      }
      return null;
    }

    function updateAuthUi() {
      const authBtn = document.getElementById("auth-btn");
      const uidEl = document.getElementById("display-uid");
      if (!authBtn || !uidEl) return;
      if (user) {
        authBtn.textContent = "ログアウト";
        uidEl.textContent = `${user.uid.substring(0, 8)}...`;
      } else {
        authBtn.textContent = "Googleでログイン";
        uidEl.textContent = "ログインが必要です";
      }
    }

    async function initFirebaseAuth() {
      const firebaseConfig = readFirebaseConfigRuntime() || await fetchFirebaseConfigFromServer();
      if (!isValidFirebaseConfig(firebaseConfig)) {
        throw new Error("Firebase設定が見つかりません。/api/firebase-config-antiage を確認してください。");
      }

      app = getApps().some((a) => a.name === FIREBASE_APP_NAME)
        ? getApp(FIREBASE_APP_NAME)
        : initializeApp(firebaseConfig, FIREBASE_APP_NAME);
      auth = getAuth(app);
      db = getFirestore(app);
      authProvider = new GoogleAuthProvider();
      authProvider.setCustomParameters({ prompt: "select_account" });

      onAuthStateChanged(auth, (u) => {
        user = u || null;
        currentFortuneRecord = null;
        currentDocId = null;
        currentFortuneDocId = null;
        if (historyUnsub) {
          historyUnsub();
          historyUnsub = null;
        }
        if (fortuneHistoryUnsub) {
          fortuneHistoryUnsub();
          fortuneHistoryUnsub = null;
        }
        if (user) {
          loadHistory();
          loadFortuneHistory();
          updateFortuneSaveStatus("");
        } else {
          historyData = [];
          fortuneHistoryData = [];
          renderHistoryList();
          renderFortuneHistoryList();
          updateFortuneSaveStatus("ログインすると占い履歴をクラウド保存できます。");
        }
        updateAuthUi();
      });

      const authBtn = document.getElementById("auth-btn");
      authBtn?.addEventListener("click", async () => {
        if (!auth) return;
        authBtn.disabled = true;
        try {
          if (user) {
            await signOut(auth);
          } else {
            await signInWithPopup(auth, authProvider);
          }
        } catch (err) {
          console.error("Auth Error:", err);
          alert("ログイン処理でエラーが発生しました。時間をおいて再試行してください。");
        } finally {
          authBtn.disabled = false;
        }
      });

      updateAuthUi();
    }

    initFirebaseAuth().catch((err) => {
      console.error("Firebase Init Error:", err);
      const uidEl = document.getElementById("display-uid");
      if (uidEl) uidEl.textContent = "設定エラー";
      const authBtn = document.getElementById("auth-btn");
      if (authBtn) authBtn.disabled = true;
      alert("Firebase設定の取得に失敗しました。管理者設定を確認してください。");
    });

    // --- Firestore Functions ---
    function loadHistory() {
      if (!user) return;
      const historyCol = collection(db, 'artifacts', appId, 'users', user.uid, 'history');
      historyUnsub = onSnapshot(historyCol, (snapshot) => {
        historyData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        renderHistoryList();
      }, (err) => console.error("Firestore Error:", err));
    }

    async function autoSaveToCloud(profileData) {
      if (!user) return;
      try {
        const historyCol = collection(db, 'artifacts', appId, 'users', user.uid, 'history');
        const docRef = await addDoc(historyCol, {
          ...profileData,
          extraData: {}, // 追加項目の格納用
          createdAt: serverTimestamp()
        });
        currentDocId = docRef.id;
        await pruneHistoryToLastTen();
      } catch (err) {
        console.error("Auto Save Error:", err);
      }
    }

    function loadFortuneHistory() {
      if (!user) return;
      const historyCol = collection(db, 'artifacts', appId, 'users', user.uid, 'fortune-history');
      fortuneHistoryUnsub = onSnapshot(historyCol, (snapshot) => {
        fortuneHistoryData = snapshot.docs.map((fortuneDoc) => ({ id: fortuneDoc.id, ...fortuneDoc.data() }));
        renderFortuneHistoryList();
      }, (err) => console.error("Fortune Firestore Error:", err));
    }

    async function autoSaveFortuneToCloud(record) {
      if (!user) return null;
      try {
        const historyCol = collection(db, 'artifacts', appId, 'users', user.uid, 'fortune-history');
        const docRef = await addDoc(historyCol, {
          ...record,
          createdAt: serverTimestamp()
        });
        currentFortuneDocId = docRef.id;
        await pruneFortuneHistoryToLastTen();
        return docRef.id;
      } catch (err) {
        console.error("Fortune Auto Save Error:", err);
        return null;
      }
    }

    async function pruneHistoryToLastTen() {
      if (!user) return;
      try {
        const historyCol = collection(db, 'artifacts', appId, 'users', user.uid, 'history');
        const q = query(historyCol, orderBy("createdAt", "desc"));
        const snap = await getDocs(q);
        const docs = snap.docs;
        if (docs.length <= HISTORY_LIMIT) return;
        const staleDocs = docs.slice(HISTORY_LIMIT);
        await Promise.all(staleDocs.map((d) => deleteDoc(d.ref)));
      } catch (err) {
        console.error("History prune error:", err);
      }
    }

    async function pruneFortuneHistoryToLastTen() {
      if (!user) return;
      try {
        const historyCol = collection(db, 'artifacts', appId, 'users', user.uid, 'fortune-history');
        const q = query(historyCol, orderBy("createdAt", "desc"));
        const snap = await getDocs(q);
        const docs = snap.docs;
        if (docs.length <= FORTUNE_HISTORY_LIMIT) return;
        const staleDocs = docs.slice(FORTUNE_HISTORY_LIMIT);
        await Promise.all(staleDocs.map((d) => deleteDoc(d.ref)));
      } catch (err) {
        console.error("Fortune history prune error:", err);
      }
    }

    // --- Navigation ---
    function updateModeTabs(mode) {
      const profileTab = document.getElementById('tab-profile');
      const fortuneTab = document.getElementById('tab-fortune');
      const isFortune = mode === 'fortune';
      if (profileTab) {
        profileTab.classList.toggle('is-active', !isFortune);
        profileTab.setAttribute('aria-selected', isFortune ? 'false' : 'true');
      }
      if (fortuneTab) {
        fortuneTab.classList.toggle('is-active', isFortune);
        fortuneTab.setAttribute('aria-selected', isFortune ? 'true' : 'false');
      }
    }

    window.switchMainTab = (mode) => {
      if (mode === 'fortune') {
        showScreen('fortune');
        return;
      }
      showScreen('intro');
    };

    window.showScreen = (screenId) => {
      const screens = ['intro', 'fortune', 'history', 'questions', 'generating-q', 'dynamic-question', 'analyzing', 'result'];
      screens.forEach((s) => {
        const el = document.getElementById(`screen-${s}`);
        if (el) el.classList.add('hidden');
      });
      const targetScreen = document.getElementById(`screen-${screenId}`);
      if (targetScreen) targetScreen.classList.remove('hidden');
      
      const badge = document.getElementById('phase-badge');
      if (screenId === 'questions') {
        badge.classList.remove('hidden');
        badge.textContent = 'Phase 1';
      } else if (screenId === 'dynamic-question') {
        badge.classList.remove('hidden');
        badge.textContent = 'Phase 2';
      } else {
        badge.classList.add('hidden');
      }
      updateModeTabs(screenId === 'fortune' ? 'fortune' : 'profile');
      refreshGeminiRateLimitUi();
      window.scrollTo(0, 0);
    };

    window.toggleHistory = () => showScreen('history');

    function ensureSignedIn() {
      if (user) return true;
      alert("先にGoogleでログインしてください。");
      return false;
    }
    
    window.resetApp = () => {
      currentQIndex = 0;
      answers = {};
      finalProfile = null;
      currentFortuneRecord = null;
      currentDocId = null;
      currentFortuneDocId = null;
      isAnswering = false;
      isGeneratingDynamicQuestions = false;
      isSubmittingProfile = false;
      updateFortuneSaveStatus("");
      lucide.createIcons();
      showScreen('intro');
    };

    // --- Core Logic ---
    window.startAssessment = () => {
      if (!ensureSignedIn()) return;
      currentQIndex = 0;
      answers = {};
      isAnswering = false;
      isGeneratingDynamicQuestions = false;
      isSubmittingProfile = false;
      renderQuestion();
      showScreen('questions');
    };

    function renderQuestion() {
      const q = QUESTIONS[currentQIndex];
      const progress = ((currentQIndex + 1) / QUESTIONS.length) * 100;
      
      document.getElementById('q-progress-text').textContent = `${(currentQIndex + 1).toString().padStart(2, '0')} / ${QUESTIONS.length}`;
      document.getElementById('q-progress-bar').style.width = `${progress}%`;
      
      const qText = document.getElementById('question-text');
      qText.classList.remove('fade-in');
      void qText.offsetWidth;
      qText.textContent = q.text;
      qText.classList.add('fade-in');

      const container = document.getElementById('options-container');
      container.innerHTML = '';
      OPTIONS.forEach(opt => {
        const btn = document.createElement('button');
        btn.className = `p-5 border-2 rounded-2xl text-left font-bold transition-all active:scale-[0.97] flex justify-between items-center ${opt.color}`;
        btn.innerHTML = `<span>${opt.label}</span> <i data-lucide="circle" class="w-4 h-4 opacity-30"></i>`;
        btn.onclick = () => handleAnswer(opt.value);
        container.appendChild(btn);
      });
      lucide.createIcons();
    }

    async function handleAnswer(val) {
      if (isAnswering || isGeneratingDynamicQuestions) return;
      isAnswering = true;
      const optionButtons = document.querySelectorAll('#options-container button');
      optionButtons.forEach((btn) => { btn.disabled = true; });
      answers[QUESTIONS[currentQIndex].id] = val;
      if (currentQIndex < QUESTIONS.length - 1) {
        currentQIndex++;
        renderQuestion();
        isAnswering = false;
      } else {
        try {
          await generateDynamicQuestions();
        } finally {
          isAnswering = false;
        }
      }
    }

    function calculateNormalizedScores(traits) {
      const scores = {};
      traits.forEach((trait) => {
        const subset = QUESTIONS.filter((q) => q.type === trait);
        const sum = subset.reduce((acc, q) => acc + (answers[q.id] || 3), 0);
        scores[trait] = Math.round((sum / (subset.length * 5)) * 100);
      });
      return scores;
    }

    function getTopTraits(scores, labels, topN = 2) {
      return Object.entries(scores)
        .sort((a, b) => b[1] - a[1])
        .slice(0, topN)
        .map(([key, value]) => `${labels[key] || key}(${value})`)
        .join(' / ');
    }

    function getBottomTraits(scores, labels, bottomN = 2) {
      return Object.entries(scores)
        .sort((a, b) => a[1] - b[1])
        .slice(0, bottomN)
        .map(([key, value]) => `${labels[key] || key}(${value})`)
        .join(' / ');
    }

    function normalizeText(value, fallback = "") {
      return typeof value === "string" && value.trim().length > 0 ? value.trim() : fallback;
    }

    function normalizeStringArray(value) {
      if (!Array.isArray(value)) return [];
      return value
        .map((v) => (typeof v === "string" ? v.trim() : ""))
        .filter((v) => v.length > 0)
        .slice(0, 8);
    }

    function shortenQuestionText(value, fallback = "") {
      const source = normalizeText(value, fallback).replace(/\s+/g, " ").trim();
      if (!source) return fallback;
      const firstSentence = source.split(/[。！？\n]/).map((s) => s.trim()).find(Boolean) || source;
      const short = firstSentence.length > 42 ? `${firstSentence.slice(0, 42)}…` : firstSentence;
      if (/[？?]$/.test(short)) return short;
      return `${short}？`;
    }

    function normalizeDynamicQuestion(raw) {
      const requiredPoints = normalizeStringArray(raw?.required_points || raw?.requiredPoints);
      const targetTraits = normalizeStringArray(raw?.rubric?.target_traits || raw?.rubric?.targetTraits);
      const confirmSignals = normalizeStringArray(raw?.rubric?.confirm_signals || raw?.rubric?.confirmSignals);
      const contradictSignals = normalizeStringArray(raw?.rubric?.contradict_signals || raw?.rubric?.contradictSignals);
      const text = shortenQuestionText(raw?.text, "");
      if (!text) return null;

      return {
        theme: normalizeText(raw?.theme, "Deep Dive"),
        role: normalizeText(raw?.role, "probe"),
        objective: normalizeText(raw?.objective, ""),
        text,
        requiredPoints,
        rubric: {
          targetTraits,
          confirmSignals,
          contradictSignals
        }
      };
    }

    function setDynamicQuestionGenerationUi({ loading, errorMessage = "" }) {
      const loadingEl = document.getElementById('dynamic-q-loading');
      const errorEl = document.getElementById('dynamic-q-error');
      const errorTextEl = document.getElementById('dynamic-q-error-text');
      if (loadingEl) loadingEl.classList.toggle('hidden', !loading);
      if (errorEl) errorEl.classList.toggle('hidden', loading);
      if (errorTextEl) {
        errorTextEl.textContent = loading
          ? ""
          : (errorMessage || "質問の生成に失敗しました。再問い合わせしてください。");
      }
      refreshGeminiRateLimitUi();
    }

    function getGeminiCooldownRemainingSec() {
      return Math.max(0, Math.ceil((geminiCooldownUntilMs - Date.now()) / 1000));
    }

    function clearGeminiCooldownTicker() {
      if (!geminiCooldownTimer) return;
      clearInterval(geminiCooldownTimer);
      geminiCooldownTimer = null;
    }

    function refreshGeminiRateLimitUi() {
      const remainingSec = getGeminiCooldownRemainingSec();
      const statusBar = document.getElementById('gemini-status-bar');
      const statusText = document.getElementById('gemini-status-text');
      const retryCountdown = document.getElementById('dynamic-q-retry-countdown');
      const retryBtn = document.getElementById('dynamic-q-retry-btn');
      const analyzeBtn = document.getElementById('analyze-btn');

      if (statusBar && statusText) {
        if (remainingSec > 0) {
          statusBar.classList.remove('hidden');
          statusText.textContent = `API制限中です。再試行まで ${remainingSec}s`;
        } else {
          statusBar.classList.add('hidden');
          statusText.textContent = "";
        }
      }

      if (retryCountdown) {
        if (remainingSec > 0) {
          retryCountdown.classList.remove('hidden');
          retryCountdown.textContent = `再問い合わせは ${remainingSec}s 後に可能です。`;
        } else {
          retryCountdown.classList.add('hidden');
          retryCountdown.textContent = "";
        }
      }

      if (retryBtn) {
        retryBtn.disabled = remainingSec > 0 || isGeneratingDynamicQuestions;
      }

      if (analyzeBtn) {
        const canSubmit = isDynamicAnswersReady(1) && !isSubmittingProfile;
        analyzeBtn.disabled = remainingSec > 0 || !canSubmit;
      }

      if (remainingSec <= 0) {
        clearGeminiCooldownTicker();
      }
    }

    function startGeminiCooldownTicker() {
      refreshGeminiRateLimitUi();
      if (getGeminiCooldownRemainingSec() <= 0) return;
      if (geminiCooldownTimer) return;
      geminiCooldownTimer = setInterval(() => {
        refreshGeminiRateLimitUi();
      }, 1000);
    }

    window.retryDynamicQuestions = async () => {
      if (isGeneratingDynamicQuestions) return;
      if (getGeminiCooldownRemainingSec() > 0) {
        refreshGeminiRateLimitUi();
        return;
      }
      await generateDynamicQuestions();
    };

    function pickScoreSubset(source, traits) {
      const result = {};
      if (!source || typeof source !== 'object') return result;
      traits.forEach((trait) => {
        const raw = Number(source[trait]);
        if (Number.isFinite(raw)) {
          result[trait] = Math.max(0, Math.min(100, Math.round(raw)));
        }
      });
      return result;
    }

    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function extractRetryAfterSec(text) {
      if (typeof text !== 'string') return 0;
      const match = text.match(/(\d+)\s*s\b/i);
      if (!match) return 0;
      const sec = Number(match[1]);
      return Number.isFinite(sec) && sec > 0 ? sec : 0;
    }

    function hashString(input) {
      const text = String(input || "");
      let hash = 2166136261;
      for (let i = 0; i < text.length; i += 1) {
        hash ^= text.charCodeAt(i);
        hash = Math.imul(hash, 16777619);
      }
      return hash >>> 0;
    }

    function pickBySeed(list, seed) {
      if (!Array.isArray(list) || list.length === 0) return "";
      const index = Math.abs(Number(seed) || 0) % list.length;
      return list[index];
    }

    function mod(value, divisor) {
      return ((value % divisor) + divisor) % divisor;
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function dotProduct(a, b) {
      const len = Math.min(a.length, b.length);
      let sum = 0;
      for (let i = 0; i < len; i += 1) {
        sum += Number(a[i] || 0) * Number(b[i] || 0);
      }
      return sum;
    }

    function vectorMagnitude(vec) {
      return Math.sqrt(dotProduct(vec, vec));
    }

    function cosineSimilarity(a, b) {
      const mag = vectorMagnitude(a) * vectorMagnitude(b);
      if (mag <= 1e-9) return 0;
      return dotProduct(a, b) / mag;
    }

    function toSoftmax(values, temperature = 1) {
      if (!Array.isArray(values) || values.length === 0) return [];
      const safeTemp = Math.max(0.0001, Number(temperature) || 1);
      const maxVal = Math.max(...values);
      const expValues = values.map((v) => Math.exp((v - maxVal) / safeTemp));
      const sum = expValues.reduce((acc, v) => acc + v, 0);
      if (sum <= 1e-9) return values.map(() => 1 / values.length);
      return expValues.map((v) => v / sum);
    }

    function parseBirthDate(value) {
      const text = normalizeText(value, "");
      if (!/^\d{4}-\d{2}-\d{2}$/.test(text)) return null;
      const [y, m, d] = text.split("-").map((v) => Number(v));
      const date = new Date(y, m - 1, d, 12, 0, 0, 0);
      if (date.getFullYear() !== y || date.getMonth() !== m - 1 || date.getDate() !== d) {
        return null;
      }
      return date;
    }

    function parseBirthTime(value) {
      const text = normalizeText(value, "");
      if (!/^\d{2}:\d{2}$/.test(text)) return null;
      const [hour, minute] = text.split(":").map((v) => Number(v));
      if (!Number.isFinite(hour) || !Number.isFinite(minute)) return null;
      if (hour < 0 || hour > 23 || minute < 0 || minute > 59) return null;
      return { hour, minute };
    }

    function detectSignFromBirthDate(date) {
      if (!(date instanceof Date)) return null;
      const m = date.getMonth() + 1;
      const d = date.getDate();
      const code = m * 100 + d;
      if (code >= 321 && code <= 419) return "aries";
      if (code >= 420 && code <= 520) return "taurus";
      if (code >= 521 && code <= 621) return "gemini";
      if (code >= 622 && code <= 722) return "cancer";
      if (code >= 723 && code <= 822) return "leo";
      if (code >= 823 && code <= 922) return "virgo";
      if (code >= 923 && code <= 1023) return "libra";
      if (code >= 1024 && code <= 1122) return "scorpio";
      if (code >= 1123 && code <= 1221) return "sagittarius";
      if (code >= 1222 || code <= 119) return "capricorn";
      if (code >= 120 && code <= 218) return "aquarius";
      return "pisces";
    }

    function getMonthBranchIndex(date) {
      const code = (date.getMonth() + 1) * 100 + date.getDate();
      if (code >= 204 && code < 306) return 2; // 寅
      if (code >= 306 && code < 405) return 3; // 卯
      if (code >= 405 && code < 506) return 4; // 辰
      if (code >= 506 && code < 606) return 5; // 巳
      if (code >= 606 && code < 707) return 6; // 午
      if (code >= 707 && code < 808) return 7; // 未
      if (code >= 808 && code < 908) return 8; // 申
      if (code >= 908 && code < 1008) return 9; // 酉
      if (code >= 1008 && code < 1107) return 10; // 戌
      if (code >= 1107 && code < 1207) return 11; // 亥
      if (code >= 1207 || code < 106) return 0; // 子
      return 1; // 丑
    }

    function getAdjustedFortuneYear(date) {
      const code = (date.getMonth() + 1) * 100 + date.getDate();
      return code >= 204 ? date.getFullYear() : date.getFullYear() - 1;
    }

    function getYearPillar(date) {
      const adjustedYear = getAdjustedFortuneYear(date);
      const stemIndex = mod(adjustedYear - 4, 10);
      const branchIndex = mod(adjustedYear - 4, 12);
      return {
        stemIndex,
        branchIndex,
        stem: HEAVENLY_STEMS[stemIndex],
        branch: EARTHLY_BRANCHES[branchIndex]
      };
    }

    function getMonthPillar(date, yearStemIndex) {
      const monthBranchIndex = getMonthBranchIndex(date);
      const monthOrder = mod(monthBranchIndex - 2, 12); // 寅月を起点
      const firstStemIndex = mod((mod(yearStemIndex, 5) * 2) + 2, 10);
      const stemIndex = mod(firstStemIndex + monthOrder, 10);
      return {
        stemIndex,
        branchIndex: monthBranchIndex,
        stem: HEAVENLY_STEMS[stemIndex],
        branch: EARTHLY_BRANCHES[monthBranchIndex]
      };
    }

    function getDayPillar(date) {
      const baseDate = new Date(1984, 1, 2, 12, 0, 0, 0); // 近似的な甲子日基準
      const target = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0, 0);
      const diffDays = Math.floor((target.getTime() - baseDate.getTime()) / 86400000);
      const stemIndex = mod(diffDays, 10);
      const branchIndex = mod(diffDays, 12);
      return {
        stemIndex,
        branchIndex,
        stem: HEAVENLY_STEMS[stemIndex],
        branch: EARTHLY_BRANCHES[branchIndex]
      };
    }

    function getHourBranchIndex(hour) {
      if (hour === 23 || hour === 0) return 0;
      return mod(Math.floor((hour + 1) / 2), 12);
    }

    function getHourPillar(dayStemIndex, timeInfo) {
      const hour = Number.isFinite(timeInfo?.hour) ? Number(timeInfo.hour) : 12;
      const branchIndex = getHourBranchIndex(hour);
      const firstStemIndex = mod(mod(dayStemIndex, 5) * 2, 10);
      const stemIndex = mod(firstStemIndex + branchIndex, 10);
      return {
        stemIndex,
        branchIndex,
        stem: HEAVENLY_STEMS[stemIndex],
        branch: EARTHLY_BRANCHES[branchIndex]
      };
    }

    function deriveFourPillars(birthDate, birthTime) {
      if (!(birthDate instanceof Date)) return null;
      const yearPillar = getYearPillar(birthDate);
      const monthPillar = getMonthPillar(birthDate, yearPillar.stemIndex);
      const dayPillar = getDayPillar(birthDate);
      const hourPillar = getHourPillar(dayPillar.stemIndex, birthTime);
      const timeKnown = !!birthTime;

      return {
        timeKnown,
        year: `${yearPillar.stem}${yearPillar.branch}`,
        month: `${monthPillar.stem}${monthPillar.branch}`,
        day: `${dayPillar.stem}${dayPillar.branch}`,
        hour: `${hourPillar.stem}${hourPillar.branch}`,
        indices: {
          year: yearPillar,
          month: monthPillar,
          day: dayPillar,
          hour: hourPillar
        }
      };
    }

    function getPillarVector(pillar) {
      const stemVec = STEM_TRAIT_MAP[pillar?.stem] || [0, 0, 0, 0, 0, 0];
      const branchVec = BRANCH_TRAIT_MAP[pillar?.branch] || [0, 0, 0, 0, 0, 0];
      return stemVec.map((v, i) => (v + Number(branchVec[i] || 0)) / 2);
    }

    function getFourPillarVector(fourPillars) {
      const dims = TRAIT_LABELS.length;
      const vector = Array.from({ length: dims }, () => 0);
      if (!fourPillars?.indices) return vector;

      const pillars = [
        fourPillars.indices.year,
        fourPillars.indices.month,
        fourPillars.indices.day,
        fourPillars.indices.hour
      ];
      const baseWeights = fourPillars.timeKnown
        ? [0.18, 0.29, 0.37, 0.16]
        : [0.24, 0.35, 0.41, 0];

      pillars.forEach((pillar, idx) => {
        const weight = Number(baseWeights[idx] || 0);
        if (weight <= 0) return;
        const pVec = getPillarVector(pillar);
        for (let i = 0; i < dims; i += 1) {
          vector[i] += pVec[i] * weight;
        }
      });
      return vector;
    }

    function applySignAdjustment(vector, sign) {
      const bonus = SIGN_TRAIT_BONUS[sign] || [0, 0, 0, 0, 0, 0];
      return vector.map((v, i) => v + Number(bonus[i] || 0) * 0.35);
    }

    function classifySeijin(vector) {
      const scored = SEIJIN_ARCHETYPES.map((archetype) => ({
        ...archetype,
        similarity: cosineSimilarity(vector, archetype.vector)
      }));
      const probabilities = toSoftmax(scored.map((s) => s.similarity), 0.28);
      const merged = scored.map((item, idx) => ({
        ...item,
        probability: probabilities[idx]
      })).sort((a, b) => b.probability - a.probability);
      return merged;
    }

    function computeFocusPotential(vector, focus) {
      const weights = FOCUS_WEIGHTS[focus] || FOCUS_WEIGHTS.overall;
      const sumWeight = weights.reduce((acc, v) => acc + v, 0) || 1;
      const value = vector.reduce((acc, v, idx) => {
        const normalized = (Number(v || 0) + 1) / 2;
        return acc + clamp(normalized, 0, 1) * Number(weights[idx] || 0);
      }, 0);
      return Math.round((value / sumWeight) * 100);
    }

    function getTraitScores(vector) {
      const scores = {};
      TRAIT_LABELS.forEach((label, idx) => {
        scores[label] = clamp(Math.round(((Number(vector[idx] || 0) + 1) / 2) * 100), 0, 100);
      });
      return scores;
    }

    function formatTopTraits(scores, topN = 2) {
      return Object.entries(scores)
        .sort((a, b) => Number(b[1]) - Number(a[1]))
        .slice(0, topN)
        .map(([label, val]) => `${label}${val}`)
        .join(" / ");
    }

    function buildStatSummary(classified, fourPillars, traitScores) {
      const top = classified[0];
      const second = classified[1] || top;
      const third = classified[2] || second;
      const topRate = Math.round((top?.probability || 0) * 1000) / 10;
      const secondRate = Math.round((second?.probability || 0) * 1000) / 10;
      const thirdRate = Math.round((third?.probability || 0) * 1000) / 10;
      const separation = (top?.probability || 0) - (second?.probability || 0);
      const confidence = clamp(Math.round(56 + separation * 240 + (fourPillars?.timeKnown ? 8 : -4)), 42, 96);
      const margin = fourPillars?.timeKnown ? 6 : 11;
      const topTraits = formatTopTraits(traitScores, 2);
      return `推定適合率: ${topRate}%（次点 ${secondRate}% / 3位 ${thirdRate}%）。信頼係数 ${confidence}/100、想定誤差 ±${margin}pt。高スコア特性: ${topTraits}。※古典理論を数値化した推定値です。`;
    }

    function getFortuneGrade(score) {
      if (score >= 90) return { label: '大吉', badgeClass: 'bg-amber-100 text-amber-700 border-amber-200' };
      if (score >= 78) return { label: '中吉', badgeClass: 'bg-rose-100 text-rose-700 border-rose-200' };
      if (score >= 64) return { label: '小吉', badgeClass: 'bg-indigo-100 text-indigo-700 border-indigo-200' };
      if (score >= 52) return { label: '末吉', badgeClass: 'bg-sky-100 text-sky-700 border-sky-200' };
      return { label: '凶', badgeClass: 'bg-slate-200 text-slate-700 border-slate-300' };
    }

    function formatFortuneDate(date) {
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, '0');
      const d = String(date.getDate()).padStart(2, '0');
      return `${y}.${m}.${d}`;
    }

    function updateFortuneSaveStatus(message = "", tone = "muted") {
      const statusEl = document.getElementById('fortune-save-status');
      if (!statusEl) return;
      const toneClass = tone === "success"
        ? "text-emerald-600"
        : (tone === "error" ? "text-rose-600" : "text-slate-500");
      statusEl.className = `text-xs font-semibold ${toneClass}`;
      statusEl.textContent = message;
    }

    function getFortuneRecordDate(record) {
      const createdAtSec = Number(record?.createdAt?.seconds || 0);
      if (createdAtSec > 0) return new Date(createdAtSec * 1000);
      const generatedAtMs = Number(record?.generatedAtMs || 0);
      if (generatedAtMs > 0) return new Date(generatedAtMs);
      const dateKey = normalizeText(record?.dateKey, "");
      if (/^\d{4}\.\d{2}\.\d{2}$/.test(dateKey)) {
        const [y, m, d] = dateKey.split(".").map((v) => Number(v));
        if (Number.isFinite(y) && Number.isFinite(m) && Number.isFinite(d)) {
          return new Date(y, m - 1, d);
        }
      }
      return new Date();
    }

    function normalizeFortuneDeepEntry(raw) {
      if (!raw || typeof raw !== "object") {
        return { analysisText: "", signalList: [], actionList: [], cautionList: [], timingNote: "" };
      }
      const analysisText = normalizeText(raw.analysisText || raw.analysis || raw.text, "");
      const signalList = normalizeStringArray(raw.signalList || raw.signals || raw.indicatorList).slice(0, 6);
      const actionList = normalizeStringArray(raw.actionList || raw.actions || raw.tips).slice(0, 7);
      const cautionList = normalizeStringArray(raw.cautionList || raw.riskList || raw.warnings).slice(0, 7);
      const timingNote = normalizeText(raw.timingNote || raw.bestTiming || raw.timing, "");
      return { analysisText, signalList, actionList, cautionList, timingNote };
    }

    function renderFortuneDeepTopicContent(entry) {
      const normalized = normalizeFortuneDeepEntry(entry);
      const analysisHtml = escapeHtml(normalized.analysisText).replace(/\n/g, "<br>");
      const timingHtml = normalized.timingNote
        ? `<p class="text-xs font-bold text-violet-600 bg-violet-50 border border-violet-100 rounded-lg px-3 py-2">ベストタイミング: ${escapeHtml(normalized.timingNote)}</p>`
        : "";
      const signalHtml = normalized.signalList.length
        ? `
          <div class="mt-3 pt-3 border-t border-sky-100">
            <p class="text-[10px] font-black uppercase tracking-widest text-sky-500">重要シグナル</p>
            <ul class="mt-2 space-y-1">
              ${normalized.signalList.map((tip) => `<li class="text-xs text-slate-700 leading-relaxed">・${escapeHtml(tip)}</li>`).join("")}
            </ul>
          </div>
        `
        : "";
      const actionsHtml = normalized.actionList.length
        ? `
          <div class="mt-3 pt-3 border-t border-violet-100">
            <p class="text-[10px] font-black uppercase tracking-widest text-violet-500">行動プラン</p>
            <ul class="mt-2 space-y-1">
              ${normalized.actionList.map((tip) => `<li class="text-xs text-slate-700 leading-relaxed">・${escapeHtml(tip)}</li>`).join("")}
            </ul>
          </div>
        `
        : "";
      const cautionHtml = normalized.cautionList.length
        ? `
          <div class="mt-3 pt-3 border-t border-rose-100">
            <p class="text-[10px] font-black uppercase tracking-widest text-rose-500">注意アラート</p>
            <ul class="mt-2 space-y-1">
              ${normalized.cautionList.map((tip) => `<li class="text-xs text-slate-700 leading-relaxed">・${escapeHtml(tip)}</li>`).join("")}
            </ul>
          </div>
        `
        : "";
      return `
        <div class="mt-3">
          <p class="text-sm text-slate-700 leading-relaxed">${analysisHtml}</p>
          ${timingHtml}
          ${signalHtml}
          ${actionsHtml}
          ${cautionHtml}
        </div>
      `;
    }

    function renderFortuneTopics(record) {
      const container = document.getElementById("fortune-topics-container");
      if (!container) return;

      const deepTopics = (record && typeof record === "object" && record.deepTopics && typeof record.deepTopics === "object")
        ? record.deepTopics
        : {};

      container.innerHTML = FORTUNE_DEEP_TOPICS.map((topic) => {
        const entry = normalizeFortuneDeepEntry(deepTopics[topic.id]);
        const hasData = !!entry.analysisText;
        const contentHtml = hasData
          ? renderFortuneDeepTopicContent(entry)
          : `
            <div class="mt-3">
              <button id="fortune-topic-btn-${topic.id}" onclick="generateFortuneTopic('${topic.id}')" class="w-full bg-violet-50 hover:bg-violet-100 text-violet-700 font-bold py-2.5 px-4 rounded-xl text-sm flex items-center justify-center gap-2 border border-violet-200 transition-colors">
                <i data-lucide="wand-sparkles" class="w-4 h-4"></i>
                AIで詳細分析
              </button>
              <div id="fortune-topic-loading-${topic.id}" class="hidden w-full py-2.5 flex items-center justify-center gap-2 text-violet-600 text-sm font-bold">
                <i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i>
                解析中...
              </div>
            </div>
          `;
        return `
          <div class="bg-white rounded-xl border border-slate-100 p-4 flex flex-col">
            <div class="flex items-center gap-2">
              <div class="w-8 h-8 rounded-lg bg-violet-50 text-violet-600 border border-violet-100 flex items-center justify-center">
                <i data-lucide="${topic.icon}" class="w-4 h-4"></i>
              </div>
              <h5 class="text-sm font-black text-slate-800">${topic.title}</h5>
            </div>
            <div id="fortune-topic-content-${topic.id}" class="flex-1">
              ${contentHtml}
            </div>
          </div>
        `;
      }).join("");
      lucide.createIcons();
    }

    function buildFortuneTopicFallback(topicTitle) {
      return {
        analysisText: `${topicTitle}は「先回り準備」と「検証サイクル」で底上げしやすい局面です。短期的な勢いに頼るより、毎週の点検で再現性を作るほど成果が安定します。特に上半期は土台作り、下半期は成果化に焦点を移すと効率が上がります。`,
        signalList: [
          "勢いが出る直前は、予定より先に準備が完了している。",
          "他者からの相談や依頼が増える時期は追い風サイン。",
          "判断に迷いが増えた時は優先順位の再設定が必要。"
        ],
        actionList: [
          `${topicTitle}に関する目標を1つだけ決める。`,
          "週1回、結果と原因を3行で記録する。",
          "予定を詰め込みすぎず、余白を確保する。",
          "月1回、戦略の前提を見直す。",
          "進捗が鈍い時ほど、作業を30分単位に分解して再始動する。"
        ],
        cautionList: [
          "成果を急ぎすぎて基礎の確認を飛ばさない。",
          "情報過多で判断が遅れる状態を避ける。",
          "短期成果だけで方向転換しすぎない。",
          "他人の期待値を背負いすぎて自分の優先順位を失わない。"
        ],
        timingNote: "毎週前半に計画、後半に検証を置く。"
      };
    }

    function renderFortuneResult(record) {
      if (!record || typeof record !== "object") return;
      currentFortuneRecord = {
        ...record,
        deepTopics: { ...(record.deepTopics || {}) }
      };

      const badgeEl = document.getElementById('fortune-badge');
      const dateEl = document.getElementById('fortune-date');
      const scoreEl = document.getElementById('fortune-score');
      const scoreBarEl = document.getElementById('fortune-score-bar');
      const mainEl = document.getElementById('fortune-main');
      const seijinEl = document.getElementById('fortune-seijin');
      const seijinSubEl = document.getElementById('fortune-seijin-sub');
      const pillarsEl = document.getElementById('fortune-pillars');
      const statEl = document.getElementById('fortune-stat');
      const quarterlyEl = document.getElementById('fortune-quarterly');
      const opportunityEl = document.getElementById('fortune-opportunity');
      const riskEl = document.getElementById('fortune-risk');
      const routineEl = document.getElementById('fortune-routine');
      const turningEl = document.getElementById('fortune-turning');
      const probabilityEl = document.getElementById('fortune-probability');
      const colorEl = document.getElementById('fortune-color');
      const itemEl = document.getElementById('fortune-item');
      const timeEl = document.getElementById('fortune-time');
      const actionEl = document.getElementById('fortune-action');
      const cautionEl = document.getElementById('fortune-caution');
      const resultEl = document.getElementById('fortune-result');

      if (!badgeEl || !dateEl || !scoreEl || !scoreBarEl || !mainEl || !seijinEl || !seijinSubEl || !pillarsEl || !statEl || !quarterlyEl || !opportunityEl || !riskEl || !routineEl || !turningEl || !probabilityEl || !colorEl || !itemEl || !timeEl || !actionEl || !cautionEl || !resultEl) {
        return;
      }

      const rawScore = Number(record?.score);
      const score = Number.isFinite(rawScore) ? Math.max(1, Math.min(100, Math.round(rawScore))) : 50;
      const grade = getFortuneGrade(score);
      const sign = normalizeText(record?.sign, 'aries');
      const signLabel = normalizeText(record?.signLabel, FORTUNE_SIGN_LABELS[sign] || 'あなたの星座');
      const gradeLabel = normalizeText(record?.grade, grade.label);
      const displayDate = formatFortuneDate(getFortuneRecordDate(record));
      const targetYear = Number(record?.targetYear || new Date().getFullYear());

      badgeEl.className = `inline-flex items-center gap-2 px-4 py-1 rounded-full border text-sm font-black ${grade.badgeClass}`;
      badgeEl.textContent = `${targetYear}年 総合運 ${gradeLabel}`;
      dateEl.textContent = `${displayDate} / ${signLabel}`;
      scoreEl.textContent = `年運スコア ${score}/100`;
      scoreBarEl.style.width = `${score}%`;
      seijinEl.textContent = normalizeText(record?.seijinType, "解析中星人");
      seijinSubEl.textContent = normalizeText(record?.seijinDesc, "生年月日から行動傾向を推定しました。");
      const p = record?.pillars || {};
      pillarsEl.textContent = p.year && p.month && p.day && p.hour
        ? `年柱 ${p.year} / 月柱 ${p.month} / 日柱 ${p.day} / 時柱 ${p.hour}${p.timeKnown ? "" : "（時刻未入力補正）"}`
        : "四柱: 生年月日を入力すると表示されます。";
      statEl.textContent = normalizeText(record?.statSummary, "統計推定は占い実行後に表示されます。");
      mainEl.textContent = normalizeText(record?.message, '今年は丁寧な一歩が運の鍵です。');
      quarterlyEl.textContent = normalizeText(record?.quarterlyForecast, "四半期ごとの詳細は診断後に表示されます。");
      opportunityEl.textContent = normalizeText(record?.opportunitySignals, "追い風シグナルは診断後に表示されます。");
      riskEl.textContent = normalizeText(record?.riskScenarios, "注意局面は診断後に表示されます。");
      routineEl.textContent = normalizeText(record?.unlockRoutine, "開運ルーチンは診断後に表示されます。");
      turningEl.textContent = normalizeText(record?.turningPoints, "転機ポイントは診断後に表示されます。");
      probabilityEl.textContent = normalizeText(record?.probabilityWindow, "確率レンジは診断後に表示されます。");
      colorEl.textContent = normalizeText(record?.luckyColor, 'インディゴ');
      itemEl.textContent = normalizeText(record?.luckyItem, '白いノート');
      timeEl.textContent = normalizeText(record?.luckyTime, '10:10〜10:40');
      actionEl.textContent = normalizeText(record?.action, '小さなタスクを1つだけ先に終える。');
      cautionEl.textContent = normalizeText(record?.caution, '焦ると判断が粗くなります。深呼吸してから進めましょう。');
      resultEl.classList.remove('hidden');
      renderFortuneTopics(currentFortuneRecord);
      lucide.createIcons();
    }

    window.generateFortune = async () => {
      if (!ensureSignedIn()) return;

      const birthDateText = normalizeText(document.getElementById('fortune-birthdate')?.value, '');
      const birthTimeText = normalizeText(document.getElementById('fortune-birthtime')?.value, '');
      const birthDate = parseBirthDate(birthDateText);
      const birthTime = parseBirthTime(birthTimeText);
      if (!birthDate) {
        alert("四柱推命を組み合わせるため、生年月日を入力してください。");
        return;
      }

      const detectedSign = detectSignFromBirthDate(birthDate);
      const signSelect = document.getElementById('fortune-sign');
      if (signSelect && detectedSign) signSelect.value = detectedSign;
      const sign = normalizeText(detectedSign || document.getElementById('fortune-sign')?.value, 'aries');
      const focus = "overall";
      const now = new Date();
      const targetYear = now.getFullYear();
      const todayKey = formatFortuneDate(now);
      const fourPillars = deriveFourPillars(birthDate, birthTime);
      const baseVector = getFourPillarVector(fourPillars);
      const combinedVector = applySignAdjustment(baseVector, sign);
      const traitScores = getTraitScores(combinedVector);
      const classified = classifySeijin(combinedVector);
      const topType = classified[0] || SEIJIN_ARCHETYPES[0];
      const focusPotential = computeFocusPotential(combinedVector, focus);
      const statSummary = buildStatSummary(classified, fourPillars, traitScores);
      const topCandidates = classified.slice(0, 3).map((entry) => ({
        id: entry.id,
        name: entry.name,
        probability: Math.round((entry.probability || 0) * 1000) / 1000
      }));
      const signLabel = FORTUNE_SIGN_LABELS[sign] || "あなたの星座";
      const focusLabel = FORTUNE_FOCUS_LABELS.overall;

      const prompt = `あなたは「占術統計融合モデル」です。四柱推命の構造情報、星人分類確率、特性スコアを統合し、${targetYear}年の総合運を高解像度で作成してください。

[入力データ]
生年月日: ${birthDateText}
出生時刻: ${birthTimeText || "不明"}
星座: ${signLabel}
注目観点: 総合運（固定）
四柱: ${JSON.stringify({
  year: fourPillars?.year || "",
  month: fourPillars?.month || "",
  day: fourPillars?.day || "",
  hour: fourPillars?.hour || "",
  timeKnown: !!fourPillars?.timeKnown
})}
星人分類候補: ${JSON.stringify(topCandidates)}
主要星人: ${topType.name}
主要特性スコア: ${JSON.stringify(traitScores)}
統計要約: ${statSummary}
統計ポテンシャル: ${focusPotential}

[分析ポリシー]
1. 断定を避け、確率的・条件付きで述べる。
2. 「根拠 -> 解釈 -> 行動」の順に整理する。
3. 一般論を減らし、入力データの固有性を優先する。
4. ユニークな比喩や言い回しを使うが、実務上の意味が伝わる表現にする。
5. 年間運勢は時系列（四半期）で具体化する。
6. 四柱・特性スコア・星人候補の数値を本文へ具体引用する。
7. セクションごとに観点と語彙を変え、重複表現を減らす。
8. 不確実性が高い部分は「条件付きシナリオ」として分岐提示する。

[出力仕様]
- annualScore: 1-100の整数。
- annualGrade: 大吉/中吉/小吉/末吉/凶 のいずれか。
- annualSummary: 1800〜3200文字。
- statConclusion: 800〜1400文字。
- quarterlyForecast: 1200〜2200文字。第1〜第4四半期を必ず含める。
- opportunitySignals: 800〜1400文字。
- riskScenarios: 800〜1400文字。
- unlockRoutine: 800〜1400文字。
- turningPoints: 700〜1200文字。上半期1件・下半期1件以上の転機を示す。
- probabilityWindow: 500〜900文字。主要シナリオごとに達成確率レンジを示す。
- actionTip: 260〜480文字。
- caution: 260〜480文字。
- seijinCatch: 260〜520文字。ユニークで印象に残る表現。
- luckyColor/luckyItem/luckyTime は具体的に。
- JSON以外を出力しない。`;

      const schema = {
        type: "OBJECT",
        properties: {
          annualScore: { type: "NUMBER" },
          annualGrade: { type: "STRING" },
          annualSummary: { type: "STRING" },
          quarterlyForecast: { type: "STRING" },
          opportunitySignals: { type: "STRING" },
          riskScenarios: { type: "STRING" },
          unlockRoutine: { type: "STRING" },
          turningPoints: { type: "STRING" },
          probabilityWindow: { type: "STRING" },
          actionTip: { type: "STRING" },
          caution: { type: "STRING" },
          luckyColor: { type: "STRING" },
          luckyItem: { type: "STRING" },
          luckyTime: { type: "STRING" },
          seijinCatch: { type: "STRING" },
          statConclusion: { type: "STRING" }
        },
        required: [
          "annualScore",
          "annualGrade",
          "annualSummary",
          "quarterlyForecast",
          "opportunitySignals",
          "riskScenarios",
          "unlockRoutine",
          "turningPoints",
          "probabilityWindow",
          "actionTip",
          "caution",
          "luckyColor",
          "luckyItem",
          "luckyTime",
          "seijinCatch",
          "statConclusion"
        ]
      };

      updateFortuneSaveStatus("Geminiで今年の総合運を解析中...");
      const fallbackSeed = hashString(`${todayKey}|${birthDateText}|${birthTimeText}|${sign}|${focus}|${topType.id}`);
      const fallbackScore = clamp(Math.round((45 + (fallbackSeed % 56)) * 0.45 + focusPotential * 0.55), 1, 100);
      const fallbackGrade = getFortuneGrade(fallbackScore).label;
      const fallbackMessage = `統計推定では${topType.name}傾向（${formatTopTraits(traitScores, 2)}）が強め。${targetYear}年は、先回りで計画しつつ小さな検証を重ねるほど運気が安定します。`;
      const fallbackQuarterly = `第1四半期: 土台形成期。情報整理と習慣化を優先。第2四半期: 伸長期。対外発信と協働で加速。第3四半期: 調整期。負荷分散と優先順位の再設計が鍵。第4四半期: 収穫期。成果の定着と来年への資産化を進める。`;
      const fallbackOpportunity = `追い風は「初動の速さ」「記録の継続」「対話の質」に現れます。小さな成功を可視化して再利用すると、運気の再現性が高まります。`;
      const fallbackRisk = `失速要因は「抱え込み」「判断の先送り」「目的の拡散」です。迷った時は選択肢を減らし、期限と評価軸を明示するとリスクを抑えられます。`;
      const fallbackRoutine = `週次で「振り返り15分 -> 翌週の重点1つ設定 -> 不要タスクを1つ削除」のルーチンを回してください。これが年間の運勢を底上げします。`;
      const fallbackTurning = `上半期は「優先順位を再設計する決断」が転機になります。下半期は「成果を外部へ見せる場」に乗るほど評価が伸びやすい局面です。`;
      const fallbackProbability = `現状維持シナリオは55〜65%、挑戦拡大型シナリオは35〜50%で成果が見込めます。準備量と検証頻度を増やすほど上振れ確率が高まります。`;

      let aiData = null;
      let overallMeta = null;
      try {
        const res = await fetchGemini(prompt, schema, { temperature: 0.72, maxAttempts: 2 });
        aiData = res?.data || null;
        overallMeta = res?.meta || null;
      } catch (err) {
        console.error("Fortune overall generation error:", err);
        updateFortuneSaveStatus("Gemini解析に失敗したため、推定値で表示します。", "error");
      }

      const score = clamp(Math.round(Number(aiData?.annualScore || fallbackScore)), 1, 100);
      const fortuneRecord = {
        birthDate: birthDateText,
        birthTime: birthTimeText,
        birthTimeKnown: !!birthTime,
        sign,
        signLabel,
        focus,
        focusLabel,
        targetYear,
        score,
        grade: normalizeText(aiData?.annualGrade, fallbackGrade),
        message: normalizeText(aiData?.annualSummary, fallbackMessage),
        quarterlyForecast: normalizeText(aiData?.quarterlyForecast, fallbackQuarterly),
        opportunitySignals: normalizeText(aiData?.opportunitySignals, fallbackOpportunity),
        riskScenarios: normalizeText(aiData?.riskScenarios, fallbackRisk),
        unlockRoutine: normalizeText(aiData?.unlockRoutine, fallbackRoutine),
        turningPoints: normalizeText(aiData?.turningPoints, fallbackTurning),
        probabilityWindow: normalizeText(aiData?.probabilityWindow, fallbackProbability),
        action: normalizeText(aiData?.actionTip, pickBySeed(FORTUNE_ACTION_TIPS, hashString(`${fallbackSeed}|action`))),
        caution: normalizeText(aiData?.caution, pickBySeed(FORTUNE_CAUTIONS, hashString(`${fallbackSeed}|caution`))),
        seijinType: topType.name,
        seijinTypeId: topType.id,
        seijinDesc: normalizeText(aiData?.seijinCatch, normalizeText(topType?.desc, "四柱の傾向を数値化したタイプです。")),
        statSummary: normalizeText(aiData?.statConclusion, statSummary),
        traitScores,
        topCandidates,
        pillars: {
          year: fourPillars?.year || "",
          month: fourPillars?.month || "",
          day: fourPillars?.day || "",
          hour: fourPillars?.hour || "",
          timeKnown: !!fourPillars?.timeKnown
        },
        deepTopics: {},
        luckyColor: normalizeText(aiData?.luckyColor, pickBySeed(FORTUNE_LUCKY_COLORS, hashString(`${fallbackSeed}|color`))),
        luckyItem: normalizeText(aiData?.luckyItem, pickBySeed(FORTUNE_LUCKY_ITEMS, hashString(`${fallbackSeed}|item`))),
        luckyTime: normalizeText(aiData?.luckyTime, pickBySeed(FORTUNE_LUCKY_TIMES, hashString(`${fallbackSeed}|time`))),
        generationMeta: {
          model: normalizeText(overallMeta?.model, ""),
          fallbackUsed: !!overallMeta?.fallbackUsed,
          generatedAt: Date.now()
        },
        dateKey: todayKey,
        generatedAtMs: Date.now()
      };

      currentFortuneDocId = null;
      renderFortuneResult(fortuneRecord);

      updateFortuneSaveStatus("占い結果をクラウド保存中...");
      const savedId = await autoSaveFortuneToCloud(fortuneRecord);
      if (savedId) {
        currentFortuneDocId = savedId;
        currentFortuneRecord = { ...fortuneRecord, id: savedId, deepTopics: {} };
        updateFortuneSaveStatus("クラウドに保存しました。", "success");
      } else {
        currentFortuneRecord = { ...fortuneRecord, deepTopics: {} };
        updateFortuneSaveStatus("保存に失敗しました。時間をおいて再試行してください。", "error");
      }
    };

    window.generateFortuneTopic = async (topicId) => {
      if (!ensureSignedIn()) return;
      if (!currentFortuneRecord) {
        alert("先に今年の総合運を生成してください。");
        return;
      }

      const topic = FORTUNE_DEEP_TOPICS.find((item) => item.id === topicId);
      if (!topic) return;
      const btn = document.getElementById(`fortune-topic-btn-${topicId}`);
      const loading = document.getElementById(`fortune-topic-loading-${topicId}`);
      if (btn) btn.classList.add("hidden");
      if (loading) loading.classList.remove("hidden");

      const prompt = `あなたは占術データと行動科学を統合して分析するAIです。
対象者の${currentFortuneRecord.targetYear || new Date().getFullYear()}年運を、テーマ別に高解像度で深掘りしてください。

[対象者データ]
生年月日: ${currentFortuneRecord.birthDate}
出生時刻: ${currentFortuneRecord.birthTime || "不明"}
星座: ${currentFortuneRecord.signLabel}
四柱: ${JSON.stringify(currentFortuneRecord.pillars || {})}
星人タイプ: ${currentFortuneRecord.seijinType}
統計要約: ${currentFortuneRecord.statSummary}
総合運要約: ${currentFortuneRecord.message}
四半期見通し: ${currentFortuneRecord.quarterlyForecast || ""}
主要特性: ${JSON.stringify(currentFortuneRecord.traitScores || {})}

[依頼]
${topic.prompt}

[出力ルール]
- 根拠と具体行動を必ず紐づける。
- 一般論を減らし、対象者固有の傾向を反映する。
- 表現はユニークにしつつ、実務に使える具体性を保つ。
- analysisText: 1400〜2400文字。
- signalList: 4〜6項目（各25〜70文字）。追い風/失速の予兆を混在させる。
- actionList: 5〜7項目（各35〜90文字）。
- cautionList: 4〜7項目（各35〜90文字）。
- timingNote: 80〜180文字。
- 最低1回は「条件Aなら〜、条件Bなら〜」の分岐を書く。
- JSONのみ返す。`;

      const schema = {
        type: "OBJECT",
        properties: {
          analysisText: { type: "STRING" },
          signalList: {
            type: "ARRAY",
            items: { type: "STRING" }
          },
          actionList: {
            type: "ARRAY",
            items: { type: "STRING" }
          },
          cautionList: {
            type: "ARRAY",
            items: { type: "STRING" }
          },
          timingNote: { type: "STRING" }
        },
        required: [
          "analysisText",
          "signalList",
          "actionList",
          "cautionList",
          "timingNote"
        ]
      };

      let entry = null;
      try {
        const { data } = await fetchGemini(prompt, schema, { temperature: 0.78, maxAttempts: 2 });
        entry = normalizeFortuneDeepEntry(data);
        if (!entry.analysisText) {
          throw new Error("deep topic text is empty");
        }
      } catch (err) {
        console.error("Fortune topic generation error:", err);
        entry = buildFortuneTopicFallback(topic.title);
        updateFortuneSaveStatus(`${topic.title}は推定値で表示しています。`, "error");
      }

      currentFortuneRecord.deepTopics = currentFortuneRecord.deepTopics || {};
      currentFortuneRecord.deepTopics[topicId] = entry;
      renderFortuneTopics(currentFortuneRecord);

      if (user && currentFortuneDocId) {
        try {
          const docRef = doc(db, 'artifacts', appId, 'users', user.uid, 'fortune-history', currentFortuneDocId);
          await updateDoc(docRef, { [`deepTopics.${topicId}`]: entry });
          updateFortuneSaveStatus(`${topic.title}の詳細を保存しました。`, "success");
        } catch (err) {
          console.error("Fortune topic save error:", err);
          updateFortuneSaveStatus(`${topic.title}の保存に失敗しました。`, "error");
        }
      }
    };

    async function fetchGemini(prompt, schema, options = {}) {
      if (!user) {
        throw new Error("Not signed in");
      }
      
      let delay = 1200;
      const maxAttemptsRaw = Number(options?.maxAttempts);
      const maxAttempts = Number.isFinite(maxAttemptsRaw)
        ? Math.max(1, Math.min(4, Math.floor(maxAttemptsRaw)))
        : 2;
      for (let i = 0; i < maxAttempts; i++) {
        const now = Date.now();
        if (geminiCooldownUntilMs > now) {
          startGeminiCooldownTicker();
          await sleep(geminiCooldownUntilMs - now);
        }
        try {
          const token = await user.getIdToken();
          const res = await fetch(GEMINI_PROXY_ENDPOINT, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
              prompt,
              schema,
              temperature: Number.isFinite(Number(options?.temperature))
                ? Number(options.temperature)
                : undefined,
              model: typeof options?.model === "string" ? options.model : undefined
            })
          });
          const raw = await res.text();
          if (!res.ok) {
            let msg = "API Error";
            try {
              const parsed = JSON.parse(raw);
              msg = parsed?.error || msg;
            } catch {}
            const retryHeader = Number(res.headers.get("retry-after") || 0);
            const retryAfterSec = Math.max(
              Number.isFinite(retryHeader) && retryHeader > 0 ? Math.ceil(retryHeader) : 0,
              extractRetryAfterSec(msg)
            );
            const err = new Error(msg);
            err.status = res.status;
            err.retryAfterSec = retryAfterSec;
            throw err;
          }
          const parsed = JSON.parse(raw);
          if (!parsed?.ok || !parsed?.data) throw new Error("Invalid API response");
          lastGeminiMeta = {
            model: typeof parsed?.model === "string" ? parsed.model : "",
            fallbackUsed: !!parsed?.fallbackUsed,
            at: Date.now()
          };
          geminiCooldownUntilMs = 0;
          refreshGeminiRateLimitUi();
          return { data: parsed.data, meta: { ...lastGeminiMeta } };
        } catch (e) {
          const status = Number(e?.status || 0);
          if (status === 429) {
            const retrySec = Math.max(1, Number(e?.retryAfterSec || 0), Math.ceil(delay / 1000));
            geminiCooldownUntilMs = Date.now() + retrySec * 1000;
            startGeminiCooldownTicker();
            if (i === maxAttempts - 1) {
              const serverMessage = typeof e?.message === "string" ? e.message.trim() : "";
              throw new Error(serverMessage || `Rate limit reached. Please try again in ${retrySec}s.`);
            }
            await sleep(retrySec * 1000);
            continue;
          }
          if (i === maxAttempts - 1) throw e;
          await sleep(delay);
          delay = Math.min(delay * 2, 12000);
        }
      }
      throw new Error("Gemini request failed");
    }

    async function generateDynamicQuestions() {
      if (isGeneratingDynamicQuestions) return;
      isGeneratingDynamicQuestions = true;
      setDynamicQuestionGenerationUi({ loading: true, errorMessage: "" });
      showScreen('generating-q');
      
      // Calculate basic scores
      baseScores = calculateNormalizedScores(BIG5_TRAITS);
      riasecScores = calculateNormalizedScores(RIASEC_TRAITS);
      const topBig5 = getTopTraits(baseScores, BIG5_LABELS, 2);
      const topRiasec = getTopTraits(riasecScores, RIASEC_LABELS, 2);
      const bottomBig5 = getBottomTraits(baseScores, BIG5_LABELS, 2);
      const bottomRiasec = getBottomTraits(riasecScores, RIASEC_LABELS, 2);

      const prompt = `あなたはGemini向けの心理測定質問デザイナーです。
目的は、回答しやすさを保ちつつ「診断の弁別力」が高い3問を作ることです。

[入力データ]
BIG5: ${JSON.stringify(baseScores)}
RIASEC: ${JSON.stringify(riasecScores)}
BIG5上位: ${topBig5}
BIG5下位: ${bottomBig5}
RIASEC上位: ${topRiasec}
RIASEC下位: ${bottomRiasec}

[必須役割]
1. high_validation（強み確認）
2. low_validation（弱み確認）
3. contradiction_check（状況による揺れ確認）

[生成ルール]
- 各質問は20〜40文字程度、1文、平易な日本語。
- 誘導・断定・説教は禁止。
- 回答者が具体例を自然に書ける問いにする。
- 役割ごとに観点を重複させない。
- 各質問は「1つの特性差」と「1つの状況差」を見分けられるようにする。
- 曖昧で誰にでも当てはまる表現を避け、回答で個人差が出る問いにする。
- yes/noだけで終わらない、行動や判断の具体が出る問いにする。

[出力]
- responseSchemaに厳密準拠。
- questionsは3件固定。
- JSON以外を出力しない。`;

      const schema = {
        type: "OBJECT",
        properties: {
          questions: {
            type: "ARRAY",
            items: {
              type: "OBJECT",
              properties: {
                theme: { type: "STRING" },
                role: { type: "STRING" },
                objective: { type: "STRING" },
                text: { type: "STRING" },
                required_points: {
                  type: "ARRAY",
                  items: { type: "STRING" }
                },
                rubric: {
                  type: "OBJECT",
                  properties: {
                    target_traits: {
                      type: "ARRAY",
                      items: { type: "STRING" }
                    },
                    confirm_signals: {
                      type: "ARRAY",
                      items: { type: "STRING" }
                    },
                    contradict_signals: {
                      type: "ARRAY",
                      items: { type: "STRING" }
                    }
                  }
                }
              }
            }
          }
        }
      };

      try {
        const { data } = await fetchGemini(prompt, schema, { temperature: 0.42 });
        const generated = Array.isArray(data?.questions)
          ? data.questions.slice(0, 3).map((q) => normalizeDynamicQuestion(q)).filter(Boolean)
          : [];
        if (generated.length !== 3) {
          throw new Error("有効な3つの質問を生成できませんでした。");
        }
        dynamicQuestions = generated;
        renderDynamicQuestions();
        showScreen('dynamic-question');
      } catch (err) {
        console.error(err);
        const message = typeof err?.message === "string" && err.message.trim().length
          ? err.message.trim()
          : "質問の生成に失敗しました。";
        setDynamicQuestionGenerationUi({ loading: false, errorMessage: `${message} 「再問い合わせする」を押してください。` });
        showScreen('generating-q');
      } finally {
        isGeneratingDynamicQuestions = false;
        refreshGeminiRateLimitUi();
      }
    }

    function isDynamicAnswersReady(minChars = 1) {
      const inputs = document.querySelectorAll('#dynamic-questions-container textarea');
      if (inputs.length !== dynamicQuestions.length || inputs.length === 0) return false;
      return Array.from(inputs).every((ta) => ta.value.trim().length >= minChars);
    }

    function renderDynamicQuestions() {
      const container = document.getElementById('dynamic-questions-container');
      const analyzeBtn = document.getElementById('analyze-btn');
      container.innerHTML = '';
      dynamicQuestions.forEach((q, i) => {
        const div = document.createElement('div');
        div.className = "bg-white p-7 rounded-[2rem] shadow-lg border border-slate-100 space-y-4";
        div.innerHTML = `
          <div class="flex items-center gap-2">
            <span class="bg-indigo-100 text-indigo-600 px-3 py-1 rounded-lg text-[10px] font-black uppercase tracking-widest">${q.theme}</span>
          </div>
          <h4 class="font-bold text-slate-800 text-lg">${q.text}</h4>
          <textarea id="ans-${i}" class="w-full bg-slate-50 border-2 border-slate-100 rounded-xl p-4 text-sm focus:border-indigo-500 focus:outline-none focus:bg-white transition-all min-h-[120px]" placeholder="短くてもOKです。自由に書いてください。"></textarea>
        `;
        container.appendChild(div);
      });
      
      const inputs = container.querySelectorAll('textarea');
      if (analyzeBtn) analyzeBtn.disabled = true;
      const validate = () => {
        refreshGeminiRateLimitUi();
      };
      inputs.forEach((ta) => {
        ta.addEventListener('input', validate);
        ta.addEventListener('change', validate);
        ta.addEventListener('blur', validate);
        ta.addEventListener('keyup', validate);
      });
      validate();
    }

    window.submitFreeText = async () => {
      if (!ensureSignedIn()) return;
      if (isSubmittingProfile) return;
      const waitSec = getGeminiCooldownRemainingSec();
      if (waitSec > 0) {
        alert(`API制限中です。${waitSec}s 後に再実行してください。`);
        refreshGeminiRateLimitUi();
        return;
      }
      if (!isDynamicAnswersReady(1)) {
        alert("3つの質問すべてに回答してから進んでください。");
        const btn = document.getElementById('analyze-btn');
        if (btn) btn.disabled = !isDynamicAnswersReady(1);
        return;
      }
      isSubmittingProfile = true;
      const analyzeBtn = document.getElementById('analyze-btn');
      if (analyzeBtn) analyzeBtn.disabled = true;
      showScreen('analyzing');
      const dynamicAnswerPayload = dynamicQuestions.map((q, i) => ({
        theme: q.theme,
        role: q.role || "",
        question: q.text,
        answer: document.getElementById(`ans-${i}`).value.trim()
      }));
      const freeAnswers = dynamicAnswerPayload
        .map((entry) => `【${entry.theme}/${entry.role}】${entry.question}\n回答: ${entry.answer}`)
        .join('\n\n');
      
      const prompt = `あなたは心理測定（BIG5/RIASEC）と行動科学に精通し、知的ユーモアも扱える分析AIです。
以下のデータを統合し、専門性と実用性の高いハイブリッド診断を作成してください。

[入力]
BIG5: ${JSON.stringify(baseScores)}
RIASEC: ${JSON.stringify(riasecScores)}
質問設計: ${JSON.stringify(dynamicQuestions)}
回答: ${freeAnswers}

[分析方針]
- 数値は観測値として扱い、改変しない。
- 記述は「観測事実 -> 解釈 -> 実行示唆」の順で構成する。
- 一般論より、回答本文の具体記述を優先して解釈する。
- 強みだけでなく、弱み・トレードオフ・状況依存性を示す。
- BIG5とRIASECの交差作用を最低2点示す。
- 反証可能性（当てはまりにくい条件）を短く示す。
- 文章は知的で読みやすく、ユーモアは気づきを深める軽い一言に限定する。

[出力仕様]
- responseSchemaに厳密準拠。
- JSONのみ返す。
- catchphrase: 18〜34文字、覚えやすく鮮明。
- witLine: 35〜90文字、知的で軽いユーモアの一言。
- deepAnalysis: 900〜1400文字。中核パターン、トリガー、起こりやすい行動、実行策を含める。
- hybridSynthesis: 500〜850文字。BIG5×RIASECの交差作用と矛盾の統合を明示する。
- hiddenDesire: 500〜900文字。未充足欲求と防衛的パターンを示し、健全な満たし方を提案する。
- big5Interpretation: 280〜480文字。
- riasecInterpretation: 280〜480文字。
- evidenceSummary: 220〜420文字。根拠と不確実性を分け、最後に信頼度（高/中/低）を明記する。`;

      const schema = {
        type: "OBJECT",
        properties: {
          catchphrase: { type: "STRING" },
          witLine: { type: "STRING" },
          deepAnalysis: { type: "STRING" },
          hybridSynthesis: { type: "STRING" },
          hiddenDesire: { type: "STRING" },
          big5Interpretation: { type: "STRING" },
          riasecInterpretation: { type: "STRING" },
          evidenceSummary: { type: "STRING" }
        }
      };

      try {
        const { data: aiProfile, meta } = await fetchGemini(prompt, schema, { temperature: 0.64 });
        finalProfile = {
          ...aiProfile,
          scoring: {
            big5: { ...baseScores },
            riasec: { ...riasecScores }
          },
          generationMeta: {
            model: meta?.model || "",
            fallbackUsed: !!meta?.fallbackUsed,
            generatedAt: Date.now()
          },
          dynamicQuestions: dynamicQuestions.map((q) => ({ ...q })),
          dynamicAnswers: dynamicAnswerPayload,
          extraData: {}
        };
        
        // 解析完了後に自動保存
        await autoSaveToCloud(finalProfile);
        
        renderResult(finalProfile);
        showScreen('result');
      } catch (err) {
        console.error(err);
        showScreen('dynamic-question');
      } finally {
        isSubmittingProfile = false;
        refreshGeminiRateLimitUi();
      }
    };

    function resolveBig5ScoresFromItem(item) {
      const fromScoring = pickScoreSubset(item?.scoring?.big5, BIG5_TRAITS);
      if (Object.keys(fromScoring).length) return fromScoring;
      return pickScoreSubset(item?.adjustedScores, BIG5_TRAITS);
    }

    function computeDiagnosisConfidence(profile) {
      const answers = Array.isArray(profile?.dynamicAnswers) ? profile.dynamicAnswers : [];
      const lengths = answers
        .map((entry) => String(entry?.answer || "").trim().length)
        .filter((len) => len > 0);
      const avgLen = lengths.length
        ? lengths.reduce((sum, len) => sum + len, 0) / lengths.length
        : 0;

      let score = 48;
      if (lengths.length >= 3) score += 15;
      if (avgLen >= 90) score += 20;
      else if (avgLen >= 50) score += 12;
      else if (avgLen >= 25) score += 6;
      else score -= 8;

      const evidenceLen = String(profile?.evidenceSummary || "").trim().length;
      if (evidenceLen >= 180) score += 10;
      else if (evidenceLen >= 80) score += 5;

      if (profile?.generationMeta?.fallbackUsed) score -= 8;
      score = Math.max(0, Math.min(100, Math.round(score)));

      if (score >= 78) {
        return {
          score,
          level: "高",
          note: "回答の具体性と一貫性が高く、診断の解像度は高めです。"
        };
      }
      if (score >= 60) {
        return {
          score,
          level: "中",
          note: "傾向把握には十分ですが、具体例を増やすとさらに精度が上がります。"
        };
      }
      return {
        score,
        level: "低",
        note: "回答が短いか情報が不足しています。具体的な場面を補うと精度が改善します。"
      };
    }

    function renderHistoryComparison(currentScores, currentId) {
      const compareEl = document.getElementById('res-history-compare');
      if (!compareEl) return;

      const sorted = historyData
        .slice()
        .sort((a, b) => (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0));
      const previous = sorted.find((item) => item.id !== currentId && Object.keys(resolveBig5ScoresFromItem(item)).length);

      if (!previous) {
        compareEl.textContent = "比較できる過去データがまだありません。";
        return;
      }

      const prevScores = resolveBig5ScoresFromItem(previous);
      if (!Object.keys(prevScores).length || !Object.keys(currentScores).length) {
        compareEl.textContent = "比較に必要なスコアが不足しています。";
        return;
      }

      const changes = BIG5_TRAITS.map((trait) => {
        const current = Number(currentScores[trait] || 0);
        const prev = Number(prevScores[trait] || 0);
        return {
          trait,
          label: BIG5_LABELS[trait] || trait,
          delta: Math.round(current - prev)
        };
      })
        .filter((item) => Math.abs(item.delta) >= 1)
        .sort((a, b) => Math.abs(b.delta) - Math.abs(a.delta));

      const dateLabel = previous.createdAt?.seconds
        ? new Date(previous.createdAt.seconds * 1000).toLocaleDateString()
        : "前回";

      if (!changes.length) {
        compareEl.textContent = `${dateLabel}比で大きな変化はありません。`;
        return;
      }

      const summary = changes
        .slice(0, 3)
        .map((item) => `${item.label} ${item.delta >= 0 ? "+" : ""}${item.delta}`)
        .join(" / ");
      compareEl.textContent = `${dateLabel}比: ${summary}`;
    }

    function renderConfidenceAndModel(profile) {
      const confidence = computeDiagnosisConfidence(profile);
      const levelEl = document.getElementById('res-confidence-level');
      const noteEl = document.getElementById('res-confidence-note');
      const modelEl = document.getElementById('res-model-used');
      if (levelEl) levelEl.textContent = `${confidence.level} (${confidence.score}/100)`;
      if (noteEl) noteEl.textContent = confidence.note;

      const model = String(profile?.generationMeta?.model || "").trim();
      const fallbackUsed = !!profile?.generationMeta?.fallbackUsed;
      if (modelEl) {
        modelEl.textContent = model
          ? `使用モデル: ${model}${fallbackUsed ? "（フォールバック利用）" : ""}`
          : "使用モデル: 不明";
      }
    }

    function renderResult(data) {
      const storedBig5 = pickScoreSubset(data?.scoring?.big5, BIG5_TRAITS);
      const storedRiasec = pickScoreSubset(data?.scoring?.riasec, RIASEC_TRAITS);
      const legacyBig5 = pickScoreSubset(data?.adjustedScores, BIG5_TRAITS);
      const legacyRiasec = pickScoreSubset(data?.adjustedScores, RIASEC_TRAITS);
      const liveBig5 = pickScoreSubset(baseScores, BIG5_TRAITS);
      const liveRiasec = pickScoreSubset(riasecScores, RIASEC_TRAITS);
      const big5ForDisplay = Object.keys(storedBig5).length
        ? storedBig5
        : (Object.keys(legacyBig5).length ? legacyBig5 : liveBig5);
      const riasecForDisplay = Object.keys(storedRiasec).length
        ? storedRiasec
        : (Object.keys(legacyRiasec).length ? legacyRiasec : liveRiasec);

      baseScores = { ...big5ForDisplay };
      riasecScores = { ...riasecForDisplay };

      document.getElementById('res-catchphrase').textContent = data.catchphrase || '';
      const witEl = document.getElementById('res-wit');
      if (witEl) {
        witEl.textContent = data.witLine || '';
        witEl.classList.toggle('hidden', !data.witLine);
      }
      document.getElementById('res-analysis').textContent = data.deepAnalysis || '';
      document.getElementById('res-hybrid').textContent = data.hybridSynthesis || data.deepAnalysis || '';
      document.getElementById('res-hidden').textContent = data.hiddenDesire || '';
      const evidenceEl = document.getElementById('res-evidence');
      if (evidenceEl) {
        evidenceEl.textContent = data.evidenceSummary ? `Evidence Note: ${data.evidenceSummary}` : '';
        evidenceEl.classList.toggle('hidden', !data.evidenceSummary);
      }

      const chartCont = document.getElementById('radar-chart-container');
      chartCont.innerHTML = generateRadar(big5ForDisplay);

      renderConfidenceAndModel(data);
      renderHistoryComparison(big5ForDisplay, data?.id || currentDocId);
      renderBig5Scores(big5ForDisplay);
      renderRiasecScores(riasecForDisplay);
      
      // 追加項目の描画
      renderExtraTopics();

      lucide.createIcons();
    }

    function renderScoreBars(containerId, items, scores, theme) {
      const container = document.getElementById(containerId);
      if (!container) return;
      container.innerHTML = items.map((item) => {
        const raw = Number(scores[item.key]);
        const value = Number.isFinite(raw) ? Math.max(0, Math.min(100, Math.round(raw))) : 0;
        const valueClass = theme === 'sky' ? 'text-sky-700' : 'text-emerald-700';
        const railClass = theme === 'sky' ? 'bg-sky-100' : 'bg-emerald-100';
        const fillClass = theme === 'sky'
          ? 'bg-gradient-to-r from-sky-400 to-indigo-500'
          : 'bg-gradient-to-r from-emerald-400 to-teal-500';
        return `
          <div class="bg-white/80 rounded-xl border border-slate-100 p-3">
            <div class="flex items-center justify-between text-xs font-bold text-slate-600">
              <span>${item.label}</span>
              <span class="${valueClass}">${value}</span>
            </div>
            <div class="mt-2 h-2 ${railClass} rounded-full overflow-hidden">
              <div class="h-full ${fillClass}" style="width:${value}%"></div>
            </div>
          </div>
        `;
      }).join('');
    }

    function renderBig5Scores(scores) {
      const items = [
        { key: 'Openness', label: '開放性' },
        { key: 'Conscientiousness', label: '誠実性' },
        { key: 'Extraversion', label: '外向性' },
        { key: 'Agreeableness', label: '協調性' },
        { key: 'Neuroticism', label: '神経傾向' }
      ];
      renderScoreBars('res-big5', items, scores, 'sky');
    }

    function renderRiasecScores(scores) {
      const items = [
        { key: 'Realistic', label: 'Realistic' },
        { key: 'Investigative', label: 'Investigative' },
        { key: 'Artistic', label: 'Artistic' },
        { key: 'Social', label: 'Social' },
        { key: 'Enterprising', label: 'Enterprising' },
        { key: 'Conventional', label: 'Conventional' }
      ];
      renderScoreBars('res-riasec', items, scores, 'emerald');
    }

    function escapeHtml(value) {
      return String(value || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function normalizeExtraTopicEntry(raw) {
      if (typeof raw === 'string') {
        const text = raw.trim();
        return {
          analysisText: text,
          improvementAdvice: []
        };
      }
      if (!raw || typeof raw !== 'object') {
        return {
          analysisText: "",
          improvementAdvice: []
        };
      }
      const analysisText = normalizeText(raw.analysisText || raw.analysis || raw.text, "");
      const improvementAdvice = normalizeStringArray(raw.improvementAdvice || raw.advice || raw.tips).slice(0, 4);
      return { analysisText, improvementAdvice };
    }

    function renderExtraTopicContent(entry) {
      const normalized = normalizeExtraTopicEntry(entry);
      const analysisHtml = escapeHtml(normalized.analysisText).replace(/\n/g, '<br>');
      const adviceHtml = normalized.improvementAdvice.length
        ? `
          <div class="mt-4 pt-4 border-t border-indigo-100">
            <p class="text-xs font-black tracking-wide text-violet-700 uppercase">改善アドバイス</p>
            <ul class="mt-2 space-y-2">
              ${normalized.improvementAdvice.map((tip) => `<li class="text-sm text-slate-700 leading-relaxed">・${escapeHtml(tip)}</li>`).join('')}
            </ul>
          </div>
        `
        : '';
      return `
        <div class="mt-4 fade-in">
          <p class="text-sm text-indigo-700 leading-relaxed font-medium">${analysisHtml}</p>
          ${adviceHtml}
        </div>
      `;
    }

    function buildFallbackImprovementAdvice(topicTitle) {
      const title = normalizeText(topicTitle, "このテーマ");
      return [
        `${title}について、1日5分で振り返りメモを取り、行動パターンを可視化する。`,
        `次の1週間は「やらないこと」を1つ決め、余力を優先課題に集中させる。`,
        `週末に実行結果を点検し、続ける行動1つ・修正する行動1つを必ず決める。`
      ];
    }

    function renderExtraTopics() {
      const container = document.getElementById('extra-topics-container');
      container.innerHTML = '';
      
      const extraData = finalProfile.extraData || {};

      EXTRA_TOPICS.forEach(topic => {
        const entry = normalizeExtraTopicEntry(extraData[topic.id]);
        const hasData = !!entry.analysisText;
        
        const div = document.createElement('div');
        div.className = "bg-gradient-to-br from-white to-indigo-50 p-6 rounded-[2rem] shadow-lg border border-indigo-100 flex flex-col justify-between";
        div.id = `topic-card-${topic.id}`;
        
        let contentHtml = '';
        if (hasData) {
          contentHtml = renderExtraTopicContent(entry);
        } else {
          contentHtml = `
            <div class="mt-4">
              <button id="btn-gen-${topic.id}" onclick="generateExtraTopic('${topic.id}')" class="w-full bg-violet-50 hover:bg-violet-100 text-violet-700 font-bold py-3 px-4 rounded-xl flex items-center justify-center gap-2 transition-colors border border-violet-200">
                <i data-lucide="zap" class="w-4 h-4"></i>
                AIで詳細を解析する
              </button>
              <div id="loading-${topic.id}" class="hidden w-full py-3 flex items-center justify-center gap-2 text-violet-600 font-bold text-sm">
                <i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i> 思考を巡らせています...
              </div>
            </div>
          `;
        }

        div.innerHTML = `
          <div>
            <div class="flex items-center gap-3 mb-2">
              <div class="w-10 h-10 rounded-xl bg-gradient-to-br from-pink-100 to-indigo-100 text-indigo-600 flex items-center justify-center border border-indigo-100">
                <i data-lucide="${topic.icon}" class="w-5 h-5"></i>
              </div>
              <h4 class="font-bold text-indigo-800">${topic.title}</h4>
            </div>
          </div>
          <div id="content-${topic.id}" class="flex-grow flex flex-col justify-end">
            ${contentHtml}
          </div>
        `;
        container.appendChild(div);
      });
      lucide.createIcons();
    }

    window.generateExtraTopic = async (topicId) => {
      const topic = EXTRA_TOPICS.find(t => t.id === topicId);
      const btn = document.getElementById(`btn-gen-${topicId}`);
      const loader = document.getElementById(`loading-${topicId}`);
      const contentDiv = document.getElementById(`content-${topicId}`);

      btn.classList.add('hidden');
      loader.classList.remove('hidden');

      const prompt = `あなたは世界トップクラスの深層心理アナリストです。
      以下のプロファイルデータを基に、ユーザーの【${topic.title}】について詳細な分析を生成してください。

      [キャッチコピー]: ${finalProfile.catchphrase}
      [ベース分析]: ${finalProfile.deepAnalysis}
      [ハイブリッド統合]: ${finalProfile.hybridSynthesis || finalProfile.deepAnalysis}
      [隠された欲求]: ${finalProfile.hiddenDesire}
      [BIG5スコア]: ${JSON.stringify(finalProfile.scoring?.big5 || baseScores)}
      [RIASECスコア]: ${JSON.stringify(finalProfile.scoring?.riasec || riasecScores)}

      指示:
      ・${topic.prompt}
      ・analysisTextは最低700文字以上、最大1200文字程度で出力してください。
      ・ユーザーが読んで深く納得し、時にハッとするような鋭い洞察を含めてください。
      ・分析は「傾向の説明」だけでなく、「起こりやすい具体場面」「回避策/活用策」まで書いてください。
      ・improvementAdviceとして、明日から実行できる改善アドバイスを3つ、短く具体的に作ってください（1項目あたり30〜70文字）。
      ・responseSchemaに厳密準拠したJSONのみを返してください。`;

      const schema = {
        type: "OBJECT",
        properties: {
          analysisText: { type: "STRING" },
          improvementAdvice: {
            type: "ARRAY",
            items: { type: "STRING" }
          }
        },
        required: ["analysisText", "improvementAdvice"]
      };

      try {
        const { data } = await fetchGemini(prompt, schema, { temperature: 0.66, maxAttempts: 1 });
        const entry = normalizeExtraTopicEntry(data);
        if (!entry.analysisText) {
          throw new Error("追加診断の本文が空です。");
        }
        if (!entry.improvementAdvice.length) {
          entry.improvementAdvice = buildFallbackImprovementAdvice(topic.title);
        }
        
        // Update local state
        finalProfile.extraData = finalProfile.extraData || {};
        finalProfile.extraData[topicId] = entry;
        
        // Update UI
        contentDiv.innerHTML = renderExtraTopicContent(entry);
        
        // Update Cloud automatically
        if (user && currentDocId) {
          const docRef = doc(db, 'artifacts', appId, 'users', user.uid, 'history', currentDocId);
          await updateDoc(docRef, { [`extraData.${topicId}`]: entry });
        }
      } catch (err) {
        console.error("Generate Extra Topic Error:", err);
        btn.classList.remove('hidden');
        loader.classList.add('hidden');
        btn.innerHTML = `<i data-lucide="refresh-cw" class="w-4 h-4"></i> エラーが発生しました。再試行`;
        lucide.createIcons();
      }
    };

    function generateRadar(scores) {
      const size = 320;
      const center = size / 2;
      const radius = 110;
      const labels = ['開放', '誠実', '外向', '協調', '神経'];
      const keys = ['Openness', 'Conscientiousness', 'Extraversion', 'Agreeableness', 'Neuroticism'];

      const getXY = (val, i) => {
        const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
        const safeVal = Number.isFinite(Number(val)) ? Number(val) : 0;
        const r = (Math.max(0, Math.min(100, safeVal)) / 100) * radius;
        return { x: center + r * Math.cos(angle), y: center + r * Math.sin(angle) };
      };

      const points = keys.map((k, i) => getXY(scores[k], i));
      const polyStr = points.map(p => `${p.x},${p.y}`).join(' ');

      let grids = "";
      [0.2, 0.4, 0.6, 0.8, 1].forEach(l => {
        const gp = keys.map((_, i) => getXY(100 * l, i));
        grids += `<polygon points="${gp.map(p => `${p.x},${p.y}`).join(' ')}" fill="none" stroke="#f1f5f9" stroke-width="1"/>`;
      });

      let axis = "";
      keys.forEach((_, i) => {
        const p = getXY(100, i);
        const lp = getXY(125, i);
        axis += `<line x1="${center}" y1="${center}" x2="${p.x}" y2="${p.y}" stroke="#f1f5f9"/>`;
        axis += `<text x="${lp.x}" y="${lp.y}" text-anchor="middle" dominant-baseline="middle" font-size="10" font-weight="900" fill="#94a3b8">${labels[i]}</text>`;
      });

      return `
        <svg viewBox="0 0 ${size} ${size}" class="w-full h-full overflow-visible">
          ${grids} ${axis}
          <polygon points="${polyStr}" class="radar-polygon" fill="rgba(99, 102, 241, 0.15)" stroke="#6366f1" stroke-width="3"/>
          ${points.map(p => `<circle cx="${p.x}" cy="${p.y}" r="4" fill="#6366f1"/>`).join('')}
        </svg>
      `;
    }

    function renderHistoryList() {
      const container = document.getElementById('history-list');
      if (historyData.length === 0) {
        container.innerHTML = `<div class="p-12 text-center text-slate-400 italic bg-white rounded-3xl border border-dashed border-slate-200">履歴がありません。</div>`;
        return;
      }

      container.innerHTML = historyData
        .sort((a, b) => (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0))
        .slice(0, HISTORY_LIMIT)
        .map(item => `
        <div onclick='openHistoryItem("${item.id}")' class="bg-white p-6 rounded-2xl border border-slate-100 shadow-sm hover:shadow-md transition-all cursor-pointer group flex items-center justify-between">
          <div class="space-y-1">
            <span class="text-[10px] font-bold text-indigo-500 uppercase tracking-widest">${new Date(item.createdAt?.seconds * 1000).toLocaleDateString()}</span>
            <h4 class="font-bold text-slate-800 group-hover:text-indigo-600 transition-colors">${item.catchphrase}</h4>
          </div>
          <i data-lucide="arrow-right" class="w-5 h-5 text-slate-300 group-hover:text-indigo-600 transition-all group-hover:translate-x-1"></i>
        </div>
      `).join('');
      lucide.createIcons();
    }

    function renderFortuneHistoryList() {
      const container = document.getElementById('fortune-history-list');
      if (!container) return;

      if (!user) {
        container.innerHTML = `
          <div class="p-6 text-center text-slate-400 italic bg-slate-50 rounded-2xl border border-dashed border-slate-200">
            ログインすると占い履歴がここに表示されます。
          </div>
        `;
        return;
      }

      const sorted = fortuneHistoryData
        .slice()
        .sort((a, b) => {
          const aSec = Number(a?.createdAt?.seconds || Math.floor((Number(a?.generatedAtMs) || 0) / 1000));
          const bSec = Number(b?.createdAt?.seconds || Math.floor((Number(b?.generatedAtMs) || 0) / 1000));
          return bSec - aSec;
        })
        .slice(0, FORTUNE_HISTORY_LIMIT);

      if (!sorted.length) {
        container.innerHTML = `
          <div class="p-6 text-center text-slate-400 italic bg-slate-50 rounded-2xl border border-dashed border-slate-200">
            まだ占い履歴がありません。最初の1件を作ってみましょう。
          </div>
        `;
        return;
      }

      container.innerHTML = sorted.map((item) => {
        const score = Number.isFinite(Number(item?.score)) ? Math.max(1, Math.min(100, Math.round(Number(item.score)))) : 50;
        const grade = normalizeText(item?.grade, getFortuneGrade(score).label);
        const focus = normalizeText(item?.focus, 'overall');
        const focusLabel = normalizeText(item?.focusLabel, FORTUNE_FOCUS_LABELS[focus] || '総合運');
        const dateLabel = formatFortuneDate(getFortuneRecordDate(item));
        const signLabel = normalizeText(item?.signLabel, FORTUNE_SIGN_LABELS[normalizeText(item?.sign, 'aries')] || '星座');
        const seijinLabel = escapeHtml(normalizeText(item?.seijinType, '解析中星人'));

        return `
          <div onclick='openFortuneHistoryItem("${item.id}")' class="bg-white p-4 rounded-xl border border-slate-100 shadow-sm hover:shadow-md transition-all cursor-pointer group flex items-center justify-between gap-3">
            <div class="space-y-1">
              <p class="text-[10px] font-bold text-slate-400 uppercase tracking-widest">${dateLabel}</p>
              <h4 class="text-sm font-black text-slate-800 group-hover:text-indigo-600 transition-colors">${focusLabel} ${grade} / ${score}</h4>
              <p class="text-xs text-slate-500">${signLabel} ・ ${seijinLabel}</p>
            </div>
            <i data-lucide="arrow-up-right" class="w-4 h-4 text-slate-300 group-hover:text-indigo-500 transition-colors"></i>
          </div>
        `;
      }).join('');
      lucide.createIcons();
    }

    window.openHistoryItem = (id) => {
      const item = historyData.find(h => h.id === id);
      if (item) {
        currentDocId = item.id; // Set ID so extra topics save to correct doc
        const historyBig5 = pickScoreSubset(item?.scoring?.big5, BIG5_TRAITS);
        const historyRiasec = pickScoreSubset(item?.scoring?.riasec, RIASEC_TRAITS);
        const legacyBig5 = pickScoreSubset(item?.adjustedScores, BIG5_TRAITS);
        const legacyRiasec = pickScoreSubset(item?.adjustedScores, RIASEC_TRAITS);
        if (Object.keys(historyBig5).length) baseScores = historyBig5;
        else if (Object.keys(legacyBig5).length) baseScores = legacyBig5;
        if (Object.keys(historyRiasec).length) riasecScores = historyRiasec;
        else if (Object.keys(legacyRiasec).length) riasecScores = legacyRiasec;
        finalProfile = item;
        renderResult(item);
        showScreen('result');
        window.scrollTo(0, 0);
      }
    };

    window.openFortuneHistoryItem = (id) => {
      const item = fortuneHistoryData.find((record) => record.id === id);
      if (!item) return;
      currentFortuneDocId = item.id;

      const birthDateInput = document.getElementById('fortune-birthdate');
      const birthTimeInput = document.getElementById('fortune-birthtime');
      const signSelect = document.getElementById('fortune-sign');
      if (birthDateInput) birthDateInput.value = normalizeText(item?.birthDate, '');
      if (birthTimeInput) birthTimeInput.value = normalizeText(item?.birthTime, '');
      if (signSelect) signSelect.value = normalizeText(item?.sign, 'aries');

      renderFortuneResult(item);
      updateFortuneSaveStatus(`${formatFortuneDate(getFortuneRecordDate(item))} の履歴を表示中。`);
      showScreen('fortune');
      window.scrollTo(0, 0);
    };

    // 初期起動
    lucide.createIcons();
    renderFortuneHistoryList();
    showScreen('intro');

  </script>
</body>
</html>
