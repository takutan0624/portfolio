<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https: data:; img-src 'self' https: data:; style-src 'self' 'unsafe-inline' https:; script-src 'self' 'unsafe-inline' https:; font-src 'self' https: data:; connect-src 'self' https:; frame-src 'self' https:; object-src 'none'; base-uri 'self'; form-action 'self' https:; frame-ancestors 'none'; upgrade-insecure-requests;">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=(), payment=(), usb=(), interest-cohort=()">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Neon Tower</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    body {
      margin: 0;
      overflow: hidden;
      background-color: #111;
      color: #fff;
      font-family: 'Press Start 2P', cursive;
      touch-action: manipulation;
    }

    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
    }

    canvas {
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
    }

    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 20px;
      box-sizing: border-box;
    }

    #score-display {
      font-size: 40px;
      text-shadow: 2px 2px 0 #000;
      text-align: center;
      margin-top: 40px;
      opacity: 0.8;
    }

    #ready-indicator {
      position: absolute;
      top: 110px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      color: rgba(255, 255, 255, 0.85);
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
      opacity: 0;
      transition: opacity 0.15s linear;
    }

    #start-screen,
    #game-over-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      pointer-events: auto;
      backdrop-filter: blur(5px);
      z-index: 10;
    }

    .hidden {
      display: none !important;
    }

    h1 {
      font-size: 40px;
      color: #0ff;
      text-shadow: 0 0 10px #0ff;
      margin-bottom: 20px;
      text-align: center;
      line-height: 1.5;
    }

    p {
      font-size: 14px;
      color: #aaa;
      margin-bottom: 22px;
      text-align: center;
      line-height: 1.6;
    }

    .muted {
      color: rgba(255, 255, 255, 0.7);
      font-size: 12px;
      margin-top: 12px;
    }

    .btn {
      background: transparent;
      color: #fff;
      font-family: 'Press Start 2P', cursive;
      font-size: 16px;
      padding: 15px 30px;
      border: 2px solid #0ff;
      border-radius: 0;
      cursor: pointer;
      text-transform: uppercase;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
      transition: all 0.2s;
      animation: pulse 1.5s infinite;
    }

    .btn:hover {
      background: #0ff;
      color: #000;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
      }
      100% {
        transform: scale(1);
      }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
      <div id="score-display">0</div>
      <div id="ready-indicator">READY...</div>
      <div></div>
    </div>

    <div id="start-screen">
      <h1>NEON<br />TOWER</h1>
      <p>TAP OR CLICK TO PLACE BLOCKS<br />STACK AS HIGH AS YOU CAN</p>
      <button class="btn" id="start-btn">START GAME</button>
      <div class="muted">BEST: <span id="best-score-start">0</span></div>
    </div>

    <div id="game-over-screen" class="hidden">
      <h1 style="color: #ff0055; text-shadow: 0 0 10px #ff0055">GAME OVER</h1>
      <p>
        SCORE: <span id="final-score" style="color: #fff; font-size: 20px">0</span><br />
        <span class="muted">BEST: <span id="best-score-over">0</span></span><br />
        <span class="muted">HEIGHT: <span id="final-height">0</span></span>
      </p>
      <button class="btn" id="restart-btn">TRY AGAIN</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const scoreDisplay = document.getElementById('score-display');
    const finalScoreDisplay = document.getElementById('final-score');

    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');

    const startBtn = document.getElementById('start-btn');
    const restartBtn = document.getElementById('restart-btn');

    const readyIndicator = document.getElementById('ready-indicator');

    const bestScoreStart = document.getElementById('best-score-start');
    const bestScoreOver = document.getElementById('best-score-over');

    const finalHeightDisplay = document.getElementById('final-height');

    // ゲーム設定
    const CONFIG = {
      blockHeight: 30,
      baseWidth: 200,
      baseSpeed: 3,
      // ★要望: 速度上昇はしない（固定速度）
      speedIncrement: 0,
      colors: {
        bg: '#111',
      },
      debrisCullMargin: 240,
    };

    // ゲーム状態
    let state = {
      blocks: [],
      currentBlock: null,
      debris: [],
      score: 0,
      cameraY: 0,
      gameRunning: false,
      inputEnabled: false,
      hue: 0,
      // ★ゲームオーバー後のタワー閲覧モード
      postGameView: false,
      postGameTargetCameraY: 0,
    };

    let animationId;
    let postAnimationId; // ゲームオーバー後のカメラ演出用

    // 背景グリッドを事前描画（毎フレーム描かない）
    const gridCanvas = document.createElement('canvas');
    const gridCtx = gridCanvas.getContext('2d');

    function drawGrid() {
      gridCanvas.width = canvas.width;
      gridCanvas.height = canvas.height;

      gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

      // 背景クリア
      gridCtx.fillStyle = CONFIG.colors.bg;
      gridCtx.fillRect(0, 0, gridCanvas.width, gridCanvas.height);

      // グリッド
      gridCtx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
      gridCtx.lineWidth = 1;
      gridCtx.beginPath();
      for (let x = 0; x < gridCanvas.width; x += 50) {
        gridCtx.moveTo(x, 0);
        gridCtx.lineTo(x, gridCanvas.height);
      }
      gridCtx.stroke();
    }

    // ベストスコア
    const BEST_KEY = 'neon_tower_best';
    function getBestScore() {
      const v = Number(localStorage.getItem(BEST_KEY) || '0');
      return Number.isFinite(v) ? v : 0;
    }
    function setBestScoreIfNeeded(score) {
      const best = getBestScore();
      if (score > best) {
        localStorage.setItem(BEST_KEY, String(score));
        return score;
      }
      return best;
    }
    function syncBestUI() {
      const best = getBestScore();
      bestScoreStart.textContent = String(best);
      bestScoreOver.textContent = String(best);
    }

    // 画面サイズに合わせてキャンバス設定
    let prevW = 0;
    let prevH = 0;

    function shiftAllX(deltaX) {
      if (!deltaX) return;
      state.blocks.forEach((b) => (b.x += deltaX));
      if (state.currentBlock) state.currentBlock.x += deltaX;
      state.debris.forEach((d) => (d.x += deltaX));
    }

    function resize() {
      const oldW = canvas.width || window.innerWidth;
      const oldH = canvas.height || window.innerHeight;

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // ★改善: リサイズ時に横方向だけセンタリング補正（幅は変えない）
      if (prevW && state.blocks.length > 0) {
        const deltaX = (canvas.width - oldW) / 2;
        shiftAllX(deltaX);
      }

      prevW = canvas.width;
      prevH = canvas.height;

      drawGrid();

      if (!state.gameRunning && state.blocks.length === 0) {
        initGame();
      } else {
        render();
      }

      syncBestUI();
    }
    window.addEventListener('resize', resize);

    class Block {
      constructor(x, y, width, color) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = CONFIG.blockHeight;
        this.color = color;
        this.vx = 0;
      }

      draw() {
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.fillRect(this.x, this.y + state.cameraY, this.width, this.height);

        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(this.x, this.y + state.cameraY, this.width, 2);
      }

      update() {
        this.x += this.vx;

        // ★改善: 反射時に位置もクランプして「めり込み」を防ぐ
        if (this.x + this.width > canvas.width && this.vx > 0) {
          this.x = canvas.width - this.width;
          this.vx = -this.vx;
        } else if (this.x < 0 && this.vx < 0) {
          this.x = 0;
          this.vx = -this.vx;
        }
      }
    }

    class Debris {
      constructor(x, y, width, height, color) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.color = color;
        this.vy = 0;
        this.gravity = 0.5;
        this.life = 1.0;
      }

      update() {
        this.vy += this.gravity;
        this.y += this.vy;
        this.life -= 0.02;
      }

      draw() {
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fillRect(this.x, this.y + state.cameraY, this.width, this.height);
        ctx.restore();
      }

      isOffscreen() {
        // ★改善: 画面座標（y + cameraY）で判定して、カメラに影響されないようにする
        const screenY = this.y + state.cameraY;
        return screenY > canvas.height + CONFIG.debrisCullMargin;
      }
    }

    function cancelLoop() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    }

    function cancelPostLoop() {
      if (postAnimationId) {
        cancelAnimationFrame(postAnimationId);
        postAnimationId = null;
      }
    }

    function initGame() {
      cancelLoop();
      cancelPostLoop();
      state.postGameView = false;

      state.blocks = [];
      state.debris = [];
      state.score = 0;
      state.cameraY = 0;
      state.hue = 0;
      state.inputEnabled = false;

      scoreDisplay.innerText = '0';

      const baseBlock = new Block(
        (canvas.width - CONFIG.baseWidth) / 2,
        canvas.height - 100,
        CONFIG.baseWidth,
        `hsl(0, 100%, 50%)`
      );
      state.blocks.push(baseBlock);

      spawnBlock();
      render();
    }

    function spawnBlock() {
      const prevBlock = state.blocks[state.blocks.length - 1];
      const newColor = `hsl(${state.hue}, 100%, 60%)`;
      state.hue = (state.hue + 10) % 360;

      const newBlock = new Block(
        0,
        prevBlock.y - CONFIG.blockHeight,
        prevBlock.width,
        newColor
      );

      // ★要望: 速度固定
      const speed = CONFIG.baseSpeed;
      if (Math.random() < 0.5) {
        newBlock.x = -newBlock.width;
        newBlock.vx = speed;
      } else {
        newBlock.x = canvas.width;
        newBlock.vx = -speed;
      }

      state.currentBlock = newBlock;
    }

    function placeBlock() {
      if (!state.gameRunning) return;
      if (!state.currentBlock) return;

      const current = state.currentBlock;
      const prev = state.blocks[state.blocks.length - 1];
      current.vx = 0;

      const distance = current.x - prev.x;

      // ★改善: Perfect許容を固定pxではなく「ブロック幅に比例」させる
      const tolerance = Math.max(3, current.width * 0.02);

      let overhangWidth = 0;
      let overlapWidth = 0;

      if (Math.abs(distance) < tolerance) {
        current.x = prev.x;
        overlapWidth = current.width;
        scoreDisplay.style.color = '#fff';
        setTimeout(() => (scoreDisplay.style.color = ''), 200);
      } else {
        overlapWidth = current.width - Math.abs(distance);

        if (overlapWidth <= 0) {
          gameOver();
          return;
        }

        overhangWidth = Math.abs(distance);

        let debrisX;
        if (distance > 0) {
          debrisX = current.x + overlapWidth;
          current.width = overlapWidth;
        } else {
          debrisX = current.x;
          current.x = prev.x;
          current.width = overlapWidth;
        }

        state.debris.push(
          new Debris(debrisX, current.y, overhangWidth, CONFIG.blockHeight, current.color)
        );
      }

      state.blocks.push(current);
      state.score++;
      scoreDisplay.innerText = String(state.score);
      spawnBlock();
    }

    function computeTowerHeightText() {
      // 視覚的高さ（ブロック段数）を表示
      // state.score は「積めた数（ベース除く）」なので、段数としては score + 1（ベース含む）
      const totalLayers = Math.max(0, state.blocks.length); // ベース含む
      const heightPx = totalLayers * CONFIG.blockHeight;
      return `${totalLayers} blocks (${heightPx}px)`;
    }

    function startPostGameViewAnimation() {
      cancelPostLoop();

      // 目標カメラ位置を計算
      state.postGameTargetCameraY = computePostGameTargetCameraY();
      state.postGameView = true;

      let frames = 0;
      const maxFrames = 240; // 約4秒（60fps換算）: その後は停止

      const postLoop = () => {
        // ブロックは静止、カメラだけ動かす
        updateCamera();
        render();

        frames++;
        const diff = Math.abs(state.postGameTargetCameraY - state.cameraY);
        if (frames < maxFrames && diff > 0.5) {
          postAnimationId = requestAnimationFrame(postLoop);
        } else {
          cancelPostLoop();
        }
      };

      postAnimationId = requestAnimationFrame(postLoop);
    }

    function gameOver() {
      state.gameRunning = false;

      const current = state.currentBlock;
      if (current) {
        state.debris.push(
          new Debris(current.x, current.y, current.width, CONFIG.blockHeight, current.color)
        );
      }
      state.currentBlock = null;

      // ベスト更新
      const best = setBestScoreIfNeeded(state.score);
      bestScoreOver.textContent = String(best);
      bestScoreStart.textContent = String(best);

      // 高さ表示
      finalHeightDisplay.textContent = computeTowerHeightText();

      finalScoreDisplay.innerText = String(state.score);
      gameOverScreen.classList.remove('hidden');

      // ゲームループ停止（更新は止める）
      cancelLoop();

      // タワー全体が見える位置へカメラを移動して見せる
      startPostGameViewAnimation();
    }

    function computePostGameTargetCameraY() {
      // タワー全体をできるだけ見せるため、上端を画面内に収める方向へカメラを移動
      const marginTop = 80;
      const marginBottom = 80;

      if (state.blocks.length === 0) return 0;

      // 最上段（yが最小）
      let topY = Infinity;
      for (const b of state.blocks) topY = Math.min(topY, b.y);

      const base = state.blocks[0];
      const baseBottomY = base.y + CONFIG.blockHeight;

      // 上端が見えるように
      const wantCamForTop = marginTop - topY;
      // 土台が見える範囲にも収めたい（収まるなら）
      const maxCamForBottom = canvas.height - marginBottom - baseBottomY;

      // できるだけ「上を見せる」優先。ただし下も入るならその範囲にクランプ。
      // タワーが高すぎる場合は上優先で下は切れる。
      const desired = wantCamForTop;
      return Math.min(desired, maxCamForBottom);
    }

    function updateCamera() {
      if (state.postGameView) {
        // ★ゲームオーバー後: タワーを見せる位置へスムーズに移動
        state.cameraY += (state.postGameTargetCameraY - state.cameraY) * 0.08;
        return;
      }

      if (state.blocks.length > 5) {
        const targetOffset = (state.blocks.length - 5) * CONFIG.blockHeight;
        state.cameraY += (targetOffset - state.cameraY) * 0.1;
      } else {
        if (state.blocks.length <= 1) {
          state.cameraY += (0 - state.cameraY) * 0.1;
        }
      }
    }

    function render() {
      // ★改善: 事前描画した背景を貼る
      ctx.drawImage(gridCanvas, 0, 0);

      state.blocks.forEach((block) => block.draw());
      if (state.currentBlock) state.currentBlock.draw();
      state.debris.forEach((debris) => debris.draw());
    }

    function loop() {
      if (!state.gameRunning) return;

      if (state.currentBlock) state.currentBlock.update();

      for (let i = state.debris.length - 1; i >= 0; i--) {
        state.debris[i].update();
        if (state.debris[i].life <= 0 || state.debris[i].isOffscreen()) {
          state.debris.splice(i, 1);
        }
      }

      updateCamera();
      render();
      animationId = requestAnimationFrame(loop);
    }

    function showReady(on) {
      readyIndicator.style.opacity = on ? '1' : '0';
    }

    function handleInput(e) {
      if (e.target.tagName === 'BUTTON') return;
      if (!state.inputEnabled) return;

      if (state.gameRunning) {
        placeBlock();
        if (e.type === 'touchstart') e.preventDefault();
      }
    }

    window.addEventListener('mousedown', handleInput);
    window.addEventListener('touchstart', handleInput, { passive: false });
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'Enter') {
        if (state.gameRunning && state.inputEnabled) placeBlock();
      }
    });

    function startGame() {
      state.postGameView = false;
      cancelPostLoop();
      startScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');
      state.gameRunning = true;

      initGame();

      showReady(true);

      // 入力許可を少し遅らせて誤操作を防止
      setTimeout(() => {
        state.inputEnabled = true;
        showReady(false);
      }, 500);

      animationId = requestAnimationFrame(loop);
    }

    startBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      startGame();
    });

    restartBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      startGame();
    });

    // 初回セットアップ
    resize();
    syncBestUI();
    initGame();
  </script>
</body>
</html>
