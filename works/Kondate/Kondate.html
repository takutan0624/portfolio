<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>1週間献立メーカー</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <!-- Firebase (Compat) -->
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
  <style>
    /* フェードインアニメーション用 */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .animate-fade-in {
      animation: fadeIn 0.7s ease-out forwards;
    }
  </style>
</head>
<body class="min-h-screen bg-orange-50 font-sans text-gray-800">

  <!-- Header -->
  <header class="bg-white shadow-sm border-b border-orange-100 sticky top-0 z-10">
    <div class="max-w-4xl mx-auto px-4 py-4 flex items-center justify-center gap-3">
      <i data-lucide="chef-hat" class="text-orange-500 w-8 h-8"></i>
      <h1 class="text-2xl font-bold text-orange-800 tracking-tight">1週間献立メーカー</h1>
    </div>
  </header>

  <main class="max-w-4xl mx-auto px-4 py-8">
    <!-- Input Section -->
    <div class="bg-white rounded-2xl shadow-md p-6 mb-8 border border-orange-100">
      <div class="flex items-center gap-2 mb-4">
        <i data-lucide="shopping-bag" class="text-orange-500 w-5 h-5"></i>
        <h2 class="text-lg font-semibold text-gray-700">冷蔵庫にある食材・買ってきた食材を入力</h2>
      </div>
      
      <textarea
        id="ingredientsInput"
        placeholder="例:&#10;豚こま肉、鶏もも肉、鮭、キャベツ、玉ねぎ、にんじん、じゃがいも、卵"
        class="w-full h-32 p-4 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-300 focus:border-orange-500 outline-none resize-none mb-4 transition-all"
      ></textarea>

      <div class="mb-4 p-3 bg-orange-50 border border-orange-100 rounded-xl flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
        <p id="authStatus" class="text-sm text-orange-800">認証を初期化しています...</p>
        <button
          id="authBtn"
          class="w-full sm:w-auto px-4 py-2 bg-white border border-orange-300 text-orange-700 rounded-lg text-sm font-semibold hover:bg-orange-100 transition-colors disabled:opacity-60 disabled:cursor-not-allowed"
        >
          Googleでログイン
        </button>
      </div>
      
      <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
        <div class="flex flex-col items-start gap-1">
          <button
            id="sampleBtn"
            class="text-sm text-orange-600 hover:text-orange-800 underline underline-offset-2"
          >
            サンプルの食材を入力する
          </button>
          <button
            id="lastPlanBtn"
            class="text-sm text-slate-600 hover:text-slate-800 underline underline-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
            disabled
          >
            前回の献立を表示
          </button>
        </div>

        <div class="w-full sm:w-auto grid grid-cols-1 sm:grid-cols-3 gap-2">
          <button
            id="generateBtn"
            class="w-full px-4 py-3 bg-orange-500 hover:bg-orange-600 text-white rounded-xl font-bold shadow-sm flex items-center justify-center gap-2 transition-colors disabled:opacity-70 disabled:cursor-not-allowed"
          >
            <span id="btnIcon" class="flex items-center"><i data-lucide="utensils" class="w-5 h-5"></i></span>
            <span id="btnText">通常献立</span>
          </button>
          <button
            id="muscleBtn"
            class="w-full px-4 py-3 bg-emerald-500 hover:bg-emerald-600 text-white rounded-xl font-bold shadow-sm transition-colors disabled:opacity-70 disabled:cursor-not-allowed"
          >
            筋肉増量
          </button>
          <button
            id="dietBtn"
            class="w-full px-4 py-3 bg-sky-500 hover:bg-sky-600 text-white rounded-xl font-bold shadow-sm transition-colors disabled:opacity-70 disabled:cursor-not-allowed"
          >
            ダイエット
          </button>
        </div>
      </div>
      
      <!-- Error Message -->
      <div id="errorBox" class="hidden mt-4 p-4 bg-red-50 text-red-600 rounded-lg flex items-start gap-2 text-sm">
        <i data-lucide="info" class="w-5 h-5 flex-shrink-0"></i>
        <p id="errorText"></p>
      </div>
    </div>

    <!-- Results Section -->
    <div id="resultsSection" class="hidden space-y-6 animate-fade-in">
      
      <!-- Recommended Additional Ingredients -->
      <div id="recommendedSection" class="hidden bg-blue-50 border border-blue-200 rounded-2xl p-5">
        <div class="flex items-center gap-2 mb-3">
          <i data-lucide="sparkles" class="text-blue-500 w-5 h-5"></i>
          <h3 class="font-bold text-blue-800">栄養UP！おすすめ追加食材</h3>
        </div>
        <p class="text-sm text-blue-800 mb-3">
          入力された食材だけでは不足しがちな栄養素を補うため、以下の食材を買い足して献立に組み込んでいます。
        </p>
        <ul id="recommendedList" class="space-y-2">
          <!-- JSで追加 -->
        </ul>
      </div>

      <!-- Menu Grid -->
      <div class="flex items-center gap-2 mb-6 border-b border-orange-200 pb-2 pt-4">
        <i data-lucide="calendar-days" class="text-orange-500 w-6 h-6"></i>
        <h2 class="text-2xl font-bold text-gray-800">1週間の夕食プラン</h2>
      </div>

      <div id="menuGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <!-- JSで追加 -->
      </div>
    </div>
  </main>

  <script>
    lucide.createIcons();

    const FIREBASE_CONFIG_ENDPOINTS = ["/api/firebase-config-antiage", "/api/firebase-config-mental"];
    const FIREBASE_APP_NAME = "antiage-auth";
    const GROQ_ENDPOINT = "/api/groq-antiage";
    const GROQ_MODEL = "openai/gpt-oss-120b";
    const GROQ_FALLBACK_MODEL = "llama-3.3-70b-versatile";
    const GENERATION_TEMPERATURE = 0.55;
    const GENERATION_MAX_TOKENS = 3900;
    const MENU_RESPONSE_SCHEMA = {
      type: "object",
      additionalProperties: false,
      properties: {
        recommended_additional_ingredients: {
          type: "array",
          items: {
            type: "object",
            additionalProperties: false,
            properties: {
              ingredient: { type: "string", minLength: 1 },
              reason: { type: "string", minLength: 24 },
            },
            required: ["ingredient", "reason"],
          },
        },
        menu: {
          type: "array",
          minItems: 7,
          maxItems: 7,
          items: {
            type: "object",
            additionalProperties: false,
            properties: {
              day: { type: "string", minLength: 1 },
              style_tag: { type: "string", minLength: 1 },
              main_dish: { type: "string", minLength: 1 },
              side_dish: { type: "string", minLength: 1 },
              soup: { type: "string", minLength: 1 },
              used_ingredients: {
                type: "array",
                minItems: 2,
                items: { type: "string", minLength: 1 },
              },
              recommended_ingredients_used: {
                type: "array",
                items: { type: "string", minLength: 1 },
              },
              daily_total_kcal: { type: "integer", minimum: 250, maximum: 1800 },
              nutrition_point: { type: "string", minLength: 20 },
            },
            required: [
              "day",
              "style_tag",
              "main_dish",
              "side_dish",
              "soup",
              "used_ingredients",
              "recommended_ingredients_used",
              "daily_total_kcal",
              "nutrition_point",
            ],
          },
        },
      },
      required: ["recommended_additional_ingredients", "menu"],
    };
    const MAIN_RECIPE_RESPONSE_SCHEMA = {
      type: "object",
      additionalProperties: false,
      properties: {
        dish_name: { type: "string", minLength: 1 },
        servings: { type: "string", minLength: 1 },
        prep_time_min: { type: "integer", minimum: 1, maximum: 120 },
        cook_time_min: { type: "integer", minimum: 5, maximum: 180 },
        ingredients: {
          type: "array",
          minItems: 3,
          maxItems: 14,
          items: {
            type: "object",
            additionalProperties: false,
            properties: {
              name: { type: "string", minLength: 1 },
              amount: { type: "string", minLength: 1 },
            },
            required: ["name", "amount"],
          },
        },
        steps: {
          type: "array",
          minItems: 4,
          maxItems: 10,
          items: { type: "string", minLength: 10 },
        },
        tips: { type: "string", minLength: 8 },
      },
      required: ["dish_name", "servings", "prep_time_min", "cook_time_min", "ingredients", "steps", "tips"],
    };
    const sampleIngredients = "豚こま肉、鶏もも肉、鮭、キャベツ、玉ねぎ、にんじん、じゃがいも、卵";

    const ingredientsInput = document.getElementById('ingredientsInput');
    const sampleBtn = document.getElementById('sampleBtn');
    const generateBtn = document.getElementById('generateBtn');
    const muscleBtn = document.getElementById('muscleBtn');
    const dietBtn = document.getElementById('dietBtn');
    const btnIcon = document.getElementById('btnIcon');
    const btnText = document.getElementById('btnText');
    const errorBox = document.getElementById('errorBox');
    const errorText = document.getElementById('errorText');
    const resultsSection = document.getElementById('resultsSection');
    const recommendedSection = document.getElementById('recommendedSection');
    const recommendedList = document.getElementById('recommendedList');
    const menuGrid = document.getElementById('menuGrid');
    const authBtn = document.getElementById('authBtn');
    const authStatus = document.getElementById('authStatus');

    let authContextPromise = null;
    let currentUser = null;
    let clientCooldownUntil = 0;
    let renderedMenuForRecipe = [];
    let renderedGoalTypeForRecipe = "normal";
    const generatedRecipeMap = new Map();
    const COOLDOWN_STORAGE_KEY = "kondate_groq_cooldown_until";
    const LAST_PLAN_STORAGE_KEY = "kondate_last_plan_v1";

    function readCooldown() {
      try {
        const raw = localStorage.getItem(COOLDOWN_STORAGE_KEY);
        const n = Number(raw || "0");
        if (Number.isFinite(n) && n > 0) {
          clientCooldownUntil = Math.max(clientCooldownUntil, n);
        }
      } catch {}
    }

    function setCooldownUntil(ts) {
      const safeTs = Math.max(clientCooldownUntil, Math.floor(Number(ts) || 0));
      clientCooldownUntil = safeTs;
      try {
        localStorage.setItem(COOLDOWN_STORAGE_KEY, String(safeTs));
      } catch {}
    }

    readCooldown();
    const lastPlanBtn = document.getElementById('lastPlanBtn');

    sampleBtn.addEventListener('click', () => {
      ingredientsInput.value = sampleIngredients;
      clearError();
    });
    ingredientsInput.addEventListener('input', clearError);
    authBtn.addEventListener('click', handleAuthButtonClick);
    generateBtn.addEventListener('click', () => generateMenu("normal"));
    muscleBtn.addEventListener('click', () => generateMenu("muscle"));
    dietBtn.addEventListener('click', () => generateMenu("diet"));
    lastPlanBtn.addEventListener('click', loadLastPlan);
    menuGrid.addEventListener('click', (event) => {
      const target = event.target;
      const buttonEl = target instanceof Element ? target.closest('.generate-recipe-btn') : null;
      if (!buttonEl) return;
      event.preventDefault();
      handleGenerateRecipeButton(buttonEl);
    });
    refreshLastPlanButton();

    function saveLastPlan(data, goalType) {
      try {
        const payload = {
          data,
          goalType,
          savedAt: Date.now(),
        };
        localStorage.setItem(LAST_PLAN_STORAGE_KEY, JSON.stringify(payload));
      } catch {}
      refreshLastPlanButton();
    }

    function readLastPlan() {
      try {
        const raw = localStorage.getItem(LAST_PLAN_STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return null;
        if (!parsed.data || !Array.isArray(parsed.data.menu)) return null;
        return parsed;
      } catch {
        return null;
      }
    }

    function refreshLastPlanButton() {
      const lastPlan = readLastPlan();
      lastPlanBtn.disabled = !lastPlan;
      if (!lastPlan) {
        lastPlanBtn.textContent = "前回の献立を表示";
        return;
      }
      const savedAt = Number(lastPlan.savedAt || 0);
      if (Number.isFinite(savedAt) && savedAt > 0) {
        const dt = new Date(savedAt);
        const hh = String(dt.getHours()).padStart(2, "0");
        const mm = String(dt.getMinutes()).padStart(2, "0");
        lastPlanBtn.textContent = `前回の献立を表示 (${hh}:${mm}保存)`;
      } else {
        lastPlanBtn.textContent = "前回の献立を表示";
      }
    }

    function loadLastPlan() {
      const lastPlan = readLastPlan();
      if (!lastPlan) {
        showError("保存された献立が見つかりませんでした。");
        refreshLastPlanButton();
        return;
      }
      clearError();
      renderResults(lastPlan.data, lastPlan.goalType || "normal");
    }

    function showError(message) {
      errorText.textContent = message;
      errorBox.classList.remove('hidden');
    }

    function clearError() {
      errorBox.classList.add('hidden');
      errorText.textContent = "";
    }

    function getGoalLoadingText(goalType) {
      if (goalType === "muscle") return "AIが筋肉増量向け献立を考案中...";
      if (goalType === "diet") return "AIがダイエット向け献立を考案中...";
      return "AIが通常献立を考案中...";
    }

    function setLoading(isLoading, goalType = "normal") {
      if (isLoading) {
        generateBtn.disabled = true;
        muscleBtn.disabled = true;
        dietBtn.disabled = true;
        lastPlanBtn.disabled = true;
        ingredientsInput.disabled = true;
        sampleBtn.disabled = true;
        authBtn.disabled = true;
        btnIcon.innerHTML = `<i data-lucide="loader-2" class="w-5 h-5 animate-spin"></i>`;
        btnText.textContent = getGoalLoadingText(goalType);
        clearError();
        resultsSection.classList.add('hidden');
      } else {
        generateBtn.disabled = false;
        muscleBtn.disabled = false;
        dietBtn.disabled = false;
        ingredientsInput.disabled = false;
        sampleBtn.disabled = false;
        authBtn.disabled = false;
        refreshLastPlanButton();
        btnIcon.innerHTML = `<i data-lucide="utensils" class="w-5 h-5"></i>`;
        btnText.textContent = "通常献立";
      }
      updateAuthUI();
      lucide.createIcons();
    }

    function parseFirebaseConfigCandidate(candidate) {
      if (!candidate) return null;
      if (typeof candidate === "string") {
        try { return JSON.parse(candidate); } catch { return null; }
      }
      if (typeof candidate === "object") return candidate;
      return null;
    }

    function isValidFirebaseConfig(config) {
      return !!(config && config.apiKey && config.projectId && config.authDomain);
    }

    function readFirebaseConfigRuntime() {
      const direct = parseFirebaseConfigCandidate(typeof __firebase_config !== "undefined" ? __firebase_config : null);
      if (isValidFirebaseConfig(direct)) return direct;

      const fromWindow = parseFirebaseConfigCandidate(window.__FIREBASE_CONFIG__);
      if (isValidFirebaseConfig(fromWindow)) return fromWindow;

      const meta = document.querySelector('meta[name="firebase-config"]');
      const fromMeta = parseFirebaseConfigCandidate(meta?.content);
      if (isValidFirebaseConfig(fromMeta)) return fromMeta;
      return null;
    }

    async function fetchFirebaseConfigFromServer() {
      for (const endpoint of FIREBASE_CONFIG_ENDPOINTS) {
        try {
          const res = await fetch(endpoint, { method: "GET", cache: "no-store" });
          if (!res.ok) continue;
          const data = await res.json();
          if (isValidFirebaseConfig(data)) return data;
        } catch {}
      }
      return null;
    }

    async function initFirebaseAuth() {
      if (authContextPromise) return authContextPromise;
      authContextPromise = (async () => {
        if (typeof firebase === "undefined") {
          throw new Error("Firebase SDKの読み込みに失敗しました。");
        }
        const firebaseConfig = readFirebaseConfigRuntime() || await fetchFirebaseConfigFromServer();
        if (!isValidFirebaseConfig(firebaseConfig)) {
          throw new Error("Firebase設定が見つかりません。/api/firebase-config-antiage を確認してください。");
        }
        const existing = firebase.apps.find((app) => app.name === FIREBASE_APP_NAME);
        const app = existing || firebase.initializeApp(firebaseConfig, FIREBASE_APP_NAME);
        const auth = firebase.auth(app);
        const provider = new firebase.auth.GoogleAuthProvider();
        provider.setCustomParameters({ prompt: "select_account" });
        return { auth, provider };
      })();
      return authContextPromise;
    }

    function updateAuthUI() {
      if (currentUser) {
        const label = currentUser.displayName || currentUser.email || "ログイン中";
        authStatus.textContent = `ログイン中: ${label}`;
        authBtn.textContent = "ログアウト";
      } else {
        authStatus.textContent = "献立作成にはGoogleログインが必要です";
        authBtn.textContent = "Googleでログイン";
      }
    }

    async function initializeAuthState() {
      try {
        const { auth } = await initFirebaseAuth();
        auth.onAuthStateChanged((user) => {
          currentUser = user || null;
          updateAuthUI();
        });
      } catch (error) {
        console.error(error);
        authStatus.textContent = "ログイン設定の読み込みに失敗しました";
        authBtn.disabled = true;
        showError("Firebase設定の取得に失敗しました。管理者設定（firebase-config-antiage API / 環境変数）を確認してください。");
      }
    }

    async function handleAuthButtonClick() {
      clearError();
      try {
        const { auth, provider } = await initFirebaseAuth();
        authBtn.disabled = true;
        if (currentUser) {
          await auth.signOut();
        } else {
          await auth.signInWithPopup(provider);
        }
      } catch (error) {
        console.error(error);
        const msg = String(error?.message || "");
        if (msg.includes("popup")) {
          showError("ログインポップアップを確認して、再度お試しください。");
        } else {
          showError("ログイン処理でエラーが発生しました。時間をおいて再度お試しください。");
        }
      } finally {
        authBtn.disabled = false;
        updateAuthUI();
      }
    }

    function extractJsonObject(raw) {
      if (typeof raw !== "string") return null;
      const tagStart = raw.indexOf("<json>");
      const tagEnd = raw.indexOf("</json>");
      let candidate = raw;
      if (tagStart !== -1 && tagEnd !== -1 && tagEnd > tagStart) {
        candidate = raw.slice(tagStart + 6, tagEnd);
      } else {
        const start = raw.indexOf("{");
        const end = raw.lastIndexOf("}");
        if (start !== -1 && end !== -1 && end > start) {
          candidate = raw.slice(start, end + 1);
        }
      }
      try {
        return JSON.parse(candidate);
      } catch {
        return null;
      }
    }

    function extractTextContent(value) {
      if (typeof value === "string") return value.trim();
      if (Array.isArray(value)) {
        return value
          .map((part) => {
            if (typeof part === "string") return part;
            if (part && typeof part === "object") {
              if (typeof part.text === "string") return part.text;
              if (typeof part.content === "string") return part.content;
            }
            return "";
          })
          .join("\n")
          .trim();
      }
      if (value && typeof value === "object") {
        if (typeof value.text === "string") return value.text.trim();
        if (typeof value.content === "string") return value.content.trim();
      }
      return "";
    }

    function extractAssistantContent(payload) {
      if (!payload || typeof payload !== "object") return "";
      const candidates = [
        payload.content,
        payload.output_text,
        payload.text,
        payload.message,
        payload?.choices?.[0]?.message?.content,
        payload?.choices?.[0]?.text,
      ];
      for (const candidate of candidates) {
        const text = extractTextContent(candidate);
        if (text) return text;
      }
      return "";
    }

    function normalizeStringArray(value) {
      if (!Array.isArray(value)) return [];
      return value
        .map((item) => String(item || "").trim())
        .filter(Boolean);
    }

    function normalizeBoundedInt(value, min, max, fallback) {
      const n = Number(value);
      if (!Number.isFinite(n)) return fallback;
      return Math.min(max, Math.max(min, Math.round(n)));
    }

    function normalizeRecipeIngredients(value) {
      if (!Array.isArray(value)) return [];
      return value
        .map((item) => {
          if (!item) return null;
          if (typeof item === "string") {
            const text = item.trim();
            if (!text) return null;
            const split = text.match(/^(.+?)[\s:：]+(.+)$/);
            if (split) {
              return { name: split[1].trim(), amount: split[2].trim() };
            }
            return { name: text, amount: "適量" };
          }
          if (typeof item === "object") {
            const name = String(item.name || item.ingredient || "").trim();
            const amount = String(item.amount || item.quantity || "").trim();
            if (!name) return null;
            return { name, amount: amount || "適量" };
          }
          return null;
        })
        .filter(Boolean)
        .slice(0, 14);
    }

    function normalizeRecipeSteps(value) {
      if (Array.isArray(value)) {
        return value
          .map((step) => String(step || "").replace(/^\s*[0-9]+[.)、\s]+/, "").trim())
          .filter((step) => step.length >= 10)
          .slice(0, 10);
      }
      if (typeof value === "string") {
        return value
          .split(/\r?\n+/g)
          .map((step) => step.replace(/^\s*[0-9]+[.)、\s]+/, "").trim())
          .filter((step) => step.length >= 10)
          .slice(0, 10);
      }
      return [];
    }

    function getDishMeta(dayPlan, dishType) {
      if (dishType === "side") {
        return { type: "side", label: "副菜", name: String(dayPlan?.side_dish || "").trim() };
      }
      if (dishType === "soup") {
        return { type: "soup", label: "汁物", name: String(dayPlan?.soup || "").trim() };
      }
      return { type: "main", label: "主菜", name: String(dayPlan?.main_dish || "").trim() };
    }

    function getRecipeMinStepCount(dishType) {
      if (dishType === "main") return 6;
      if (dishType === "side") return 5;
      return 4;
    }

    function buildRecipeCacheKey(dayPlan, dayIndex, dishType, dishName) {
      return `${Number(dayIndex)}::${String(dishType || "main")}::${normalizeDishName(dishName)}::${normalizeDishName(dayPlan?.day)}`;
    }

    function normalizeGeneratedRecipe(payload) {
      return {
        dish_name: String(payload?.dish_name || "").trim(),
        servings: String(payload?.servings || "2人分").trim(),
        prep_time_min: normalizeBoundedInt(payload?.prep_time_min, 1, 120, 10),
        cook_time_min: normalizeBoundedInt(payload?.cook_time_min, 5, 180, 20),
        ingredients: normalizeRecipeIngredients(payload?.ingredients),
        steps: normalizeRecipeSteps(payload?.steps),
        tips: String(payload?.tips || "").trim(),
      };
    }

    function validateGeneratedRecipeConsistency(recipe, expectedDishName, dishLabel) {
      const expected = normalizeDishName(expectedDishName);
      const actual = normalizeDishName(recipe?.dish_name);
      if (expected && !actual) {
        throw new Error(`作り方の${dishLabel}名が不足しています。`);
      }
      if (expected && actual && expected !== actual && !actual.includes(expected) && !expected.includes(actual)) {
        throw new Error(`作り方と献立の${dishLabel}名が一致していません。`);
      }
    }

    function renderRecipeDetailHtml(recipe, dishLabel) {
      const ingredients = normalizeRecipeIngredients(recipe?.ingredients);
      const steps = normalizeRecipeSteps(recipe?.steps);
      const tips = String(recipe?.tips || "").trim();

      return `
        <div class="mt-2 p-3 bg-orange-50 border border-orange-100 rounded-lg">
          <div class="flex flex-wrap items-center gap-2 mb-2">
            <p class="text-xs font-bold text-orange-700">${escapeHtml(dishLabel)}の作り方</p>
            ${recipe?.dish_name ? `<span class="text-[11px] font-semibold text-orange-800 bg-white border border-orange-200 rounded-full px-2 py-0.5">${escapeHtml(recipe.dish_name)}</span>` : ``}
            <span class="text-[11px] font-semibold text-orange-800 bg-white border border-orange-200 rounded-full px-2 py-0.5">${escapeHtml(recipe?.servings || "2人分")}</span>
            <span class="text-[11px] font-semibold text-orange-800 bg-white border border-orange-200 rounded-full px-2 py-0.5">下準備 約${escapeHtml(recipe?.prep_time_min || 10)}分</span>
            <span class="text-[11px] font-semibold text-orange-800 bg-white border border-orange-200 rounded-full px-2 py-0.5">調理 約${escapeHtml(recipe?.cook_time_min || 20)}分</span>
          </div>
          ${ingredients.length > 0 ? `
            <div class="mb-2">
              <p class="text-[11px] font-bold text-orange-700 mb-1">材料</p>
              <ul class="space-y-1">
                ${ingredients.map((ingredient) => `
                  <li class="flex items-start justify-between gap-2 text-xs text-orange-900">
                    <span>${escapeHtml(ingredient.name)}</span>
                    <span class="font-medium text-orange-800">${escapeHtml(ingredient.amount)}</span>
                  </li>
                `).join('')}
              </ul>
            </div>
          ` : ``}
          ${steps.length > 0 ? `
            <p class="text-[11px] font-bold text-orange-700 mb-1">手順</p>
            <ol class="list-decimal list-inside space-y-1">
              ${steps.map((step) => `
                <li class="text-xs text-orange-900 leading-relaxed">${escapeHtml(step)}</li>
              `).join('')}
            </ol>
          ` : `
            <p class="text-xs text-orange-900 leading-relaxed">手順の生成に失敗しました。もう一度お試しください。</p>
          `}
          ${tips ? `
            <div class="mt-2">
              <p class="text-[11px] font-bold text-orange-700 mb-1">コツ</p>
              <p class="text-xs text-orange-900 leading-relaxed">${escapeHtml(tips)}</p>
            </div>
          ` : ``}
        </div>
      `;
    }

    function parseIngredientList(raw) {
      return Array.from(new Set(
        String(raw || "")
          .split(/[\n,、，]/g)
          .map((v) => v.trim())
          .filter((v) => v.length >= 2)
      ));
    }

    function normalizeDishName(value) {
      return String(value || "")
        .toLowerCase()
        .replace(/\s+/g, "")
        .replace(/[()（）「」『』・,，、]/g, "");
    }

    function containsAny(text, keywords) {
      return keywords.some((word) => text.includes(word));
    }

    function estimateDailyCalories(item) {
      const text = `${item?.main_dish || ""} ${item?.side_dish || ""} ${item?.soup || ""}`.toLowerCase();
      let kcal = 640;
      if (/(から揚げ|唐揚げ|とんかつ|フライ|天ぷら|揚げ)/.test(text)) kcal += 180;
      if (/(丼|カレー|パスタ|ラーメン|チャーハン|炒飯)/.test(text)) kcal += 140;
      if (/(サラダ|蒸し|茹で|豆腐|きのこ|海藻)/.test(text)) kcal -= 80;
      if (/(鶏むね|ささみ|白身魚)/.test(text)) kcal -= 60;
      if (/(牛|豚バラ|ベーコン|チーズ)/.test(text)) kcal += 90;
      return Math.max(250, Math.min(1800, Math.round(kcal)));
    }

    function validateMenuQuality(menu, inputIngredientsRaw) {
      const warnings = [];
      const mainSet = new Set(menu.map((item) => normalizeDishName(item.main_dish)).filter(Boolean));
      if (mainSet.size < 5) {
        warnings.push("主菜のバリエーションが不足しています。");
      }

      const sideSet = new Set(menu.map((item) => normalizeDishName(item.side_dish)).filter(Boolean));
      if (sideSet.size < 5) {
        warnings.push("副菜のバリエーションが不足しています。");
      }

      const soupSet = new Set(menu.map((item) => normalizeDishName(item.soup)).filter(Boolean));
      if (soupSet.size < 2) {
        warnings.push("汁物のバリエーションが不足しています。");
      }

      const proteinCategories = {
        fish: ["鮭", "さば", "鯖", "ぶり", "たら", "鱈", "まぐろ", "いわし", "あじ", "しらす", "えび", "海老", "いか", "たこ", "魚"],
        meat: ["鶏", "豚", "牛", "ひき肉", "ベーコン", "ハム", "ソーセージ", "肉"],
        egg: ["卵", "たまご", "玉子"],
        soy: ["豆腐", "納豆", "厚揚げ", "油揚げ", "高野豆腐", "大豆"],
      };
      const weeklyText = menu
        .map((item) => `${item.main_dish} ${item.side_dish} ${item.soup} ${item.used_ingredients.join(" ")}`)
        .join(" ");
      const usedProteinKinds = Object.entries(proteinCategories)
        .filter(([, words]) => containsAny(weeklyText, words))
        .map(([kind]) => kind);
      if (usedProteinKinds.length < 2) {
        warnings.push("たんぱく源のバリエーションが不足しています。");
      }

      const inputIngredients = parseIngredientList(inputIngredientsRaw);
      if (inputIngredients.length >= 4) {
        const textForCoverage = menu
          .map((item) => `${item.main_dish} ${item.side_dish} ${item.soup} ${item.used_ingredients.join(" ")}`)
          .join(" ");
        const covered = inputIngredients.filter((ing) => textForCoverage.includes(ing));
        const coverageRatio = covered.length / inputIngredients.length;
        if (coverageRatio < 0.30) {
          warnings.push("入力食材の反映率が低すぎます。");
        }
      }
      return warnings;
    }

    function validateGoalSpecific(menu, goalType) {
      const proteinWords = ["鶏", "豚", "牛", "鮭", "さば", "鯖", "まぐろ", "魚", "卵", "豆腐", "納豆", "大豆"];
      const carbWords = ["ご飯", "米", "玄米", "オートミール", "パスタ", "うどん", "そば", "パン", "じゃがいも", "さつまいも"];
      const fryWords = ["唐揚げ", "から揚げ", "とんかつ", "フライ", "天ぷら", "揚げ"];
      const veggieWords = ["野菜", "きのこ", "海藻", "食物繊維", "葉物", "根菜", "サラダ", "温野菜", "ブロッコリー", "キャベツ", "ほうれん草", "もやし", "ひじき", "わかめ"];
      const leanWords = ["脂質", "油", "低脂質", "塩分", "カロリー", "控えめ"];

      const dailyTexts = menu.map((item) => `${item.main_dish} ${item.side_dish} ${item.soup} ${item.used_ingredients.join(" ")} ${item.nutrition_point}`);
      if (goalType === "muscle") {
        const proteinDays = dailyTexts.filter((text) => containsAny(text, proteinWords)).length;
        if (proteinDays < 4) {
          throw new Error("筋肉増量向け条件: 高たんぱく要素が不足しています。");
        }
        const carbDays = dailyTexts.filter((text) => containsAny(text, carbWords)).length;
        if (carbDays < 2) {
          throw new Error("筋肉増量向け条件: 炭水化物が不足しています。");
        }
      }

      if (goalType === "diet") {
        const friedCount = dailyTexts.filter((text) => containsAny(text, fryWords)).length;
        if (friedCount > 2) {
          throw new Error("ダイエット向け条件: 揚げ物が多すぎます。");
        }
        const veggieDays = dailyTexts.filter((text) => containsAny(text, veggieWords)).length;
        if (veggieDays < 2) {
          throw new Error("ダイエット向け条件: 野菜・食物繊維要素が不足しています。");
        }
        const leanDays = dailyTexts.filter((text) => containsAny(text, leanWords)).length;
        if (leanDays < 1) {
          throw new Error("ダイエット向け条件: 低脂質・塩分配慮の説明が不足しています。");
        }
      }
    }

    function inferStyleTag(item) {
      const text = `${item?.main_dish || ""} ${item?.side_dish || ""} ${item?.soup || ""}`;
      if (/(トムヤム|ガパオ|フォー|ナシゴレン|タイ|ベトナム|インド|カレー)/.test(text)) return "東南アジア・エスニック";
      if (/(麻婆|回鍋肉|青椒肉絲|中華|担々|餃子|春巻)/.test(text)) return "中華";
      if (/(ビビンバ|チゲ|プルコギ|韓国)/.test(text)) return "韓国";
      if (/(アヒージョ|ペペロンチーノ|カルボナーラ|ボロネーゼ|リゾット|ミネストローネ|イタリアン)/.test(text)) return "イタリアン";
      if (/(ブイヤベース|キッシュ|コンフィ|ポトフ|ラタトゥイユ|フレンチ)/.test(text)) return "フレンチ";
      if (/(シチュー|グラタン|ドリア|ムニエル|ハンバーグ|洋風|パスタ)/.test(text)) return "洋食";
      return "和食";
    }

    function validateCuisineDiversity(menu) {
      const styleSet = new Set(menu.map((item) => String(item.style_tag || "").trim()).filter(Boolean));
      if (styleSet.size < 2) {
        throw new Error("料理ジャンルの幅が不足しています。");
      }
      // Keep cuisine diversity broad without forcing a specific cuisine family.
    }

    function normalizeMenuResponse(data, inputIngredientsRaw, goalType) {
      const recommendedRaw = Array.isArray(data?.recommended_additional_ingredients)
        ? data.recommended_additional_ingredients
        : [];
      const recommended = recommendedRaw
        .map((item) => ({
          ingredient: String(item?.ingredient || "").trim(),
          reason: String(item?.reason || "").trim(),
        }))
        .filter((item) => item.ingredient);

      const menuRaw = Array.isArray(data?.menu) ? data.menu : [];
      const menu = menuRaw
        .map((item, index) => ({
          day: String(item?.day || `${index + 1}日目`).trim(),
          style_tag: String(item?.style_tag || inferStyleTag(item)).trim(),
          main_dish: String(item?.main_dish || "").trim(),
          side_dish: String(item?.side_dish || "").trim(),
          soup: String(item?.soup || "").trim(),
          used_ingredients: normalizeStringArray(item?.used_ingredients),
          recommended_ingredients_used: normalizeStringArray(item?.recommended_ingredients_used),
          daily_total_kcal: Number.isFinite(Number(item?.daily_total_kcal))
            ? Math.max(250, Math.min(1800, Math.round(Number(item?.daily_total_kcal))))
            : estimateDailyCalories(item),
          nutrition_point: String(item?.nutrition_point || "").trim(),
        }))
        .slice(0, 7);

      if (menu.length !== 7) {
        throw new Error("献立が7日分生成されませんでした。");
      }
      if (menu.some((item) => !item.main_dish || !item.side_dish || !item.soup)) {
        throw new Error("献立データを生成できませんでした。");
      }
      const qualityWarnings = validateMenuQuality(menu, inputIngredientsRaw);
      if (qualityWarnings.length > 0) {
        console.warn("[Kondate] Menu quality warnings:", qualityWarnings);
      }
      validateCuisineDiversity(menu);
      validateGoalSpecific(menu, goalType);

      return {
        recommended_additional_ingredients: recommended,
        menu,
      };
    }

    function escapeHtml(value) {
      return String(value || "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    function buildRecipeSearchUrl(dishName) {
      const query = `${String(dishName || "").trim()} 作り方 レシピ`;
      return `https://www.google.com/search?q=${encodeURIComponent(query)}`;
    }

    function isContentGenerationError(error) {
      const message = String(error?.message || "");
      return (
        message.includes("Empty AI response") ||
        message.includes("AIから有効な応答が返ってきませんでした。") ||
        message.includes("AI応答がJSON形式ではありません。") ||
        message.includes("API応答の解析に失敗しました。") ||
        (message.includes("作り方の") && message.includes("名が不足しています。")) ||
        (message.includes("作り方と献立の") && message.includes("名が一致していません。")) ||
        message.includes("レシピの詳細が不足しています。") ||
        message.includes("献立が7日分生成されませんでした。") ||
        message.includes("主菜のバリエーションが不足しています。") ||
        message.includes("副菜のバリエーションが不足しています。") ||
        message.includes("汁物のバリエーションが不足しています。") ||
        message.includes("たんぱく源のバリエーションが不足しています。") ||
        message.includes("入力食材の反映率が低すぎます。") ||
        message.includes("料理ジャンルの幅が不足しています。") ||
        message.includes("筋肉増量向け条件: 高たんぱく要素が不足しています。") ||
        message.includes("筋肉増量向け条件: 炭水化物が不足しています。") ||
        message.includes("ダイエット向け条件: 揚げ物が多すぎます。") ||
        message.includes("ダイエット向け条件: 野菜・食物繊維要素が不足しています。") ||
        message.includes("ダイエット向け条件: 低脂質・塩分配慮の説明が不足しています。")
      );
    }

    function getGoalInstruction(goalType) {
      if (goalType === "muscle") {
        return `【目的: 筋肉増量】
- 各日の主菜は高たんぱくを優先し、肉・魚・卵・大豆製品を積極的に使う。
- 夕食1回でたんぱく質をしっかり確保できる献立構成にする。
- トレーニング後を想定し、炭水化物も不足しないようにする。
- 極端な低脂質にはせず、回復に必要な脂質は適量確保する。`;
      }
      if (goalType === "diet") {
        return `【目的: ダイエット】
- 高たんぱく・適正糖質・低脂質を意識した献立にする。
- 揚げ物や高脂質な調理を避け、蒸す・茹でる・焼く調理を優先する。
- 野菜・きのこ・海藻を増やし、満足感と食物繊維を確保する。
- 味付けは濃くしすぎず、塩分や余分な油を抑える。`;
      }
      return `【目的: 通常】
- 栄養バランスと継続しやすさを重視する。`;
    }

    function getMemoTheme(goalType) {
      if (goalType === "muscle") {
        return {
          label: "筋肉メモ",
          icon: "dumbbell",
          wrapperClass: "bg-rose-50/60 border-t border-rose-100",
          iconClass: "w-4 h-4 text-rose-500 mt-0.5 flex-shrink-0",
          titleClass: "text-xs font-bold text-rose-700 mb-1",
          textClass: "text-sm text-rose-900 leading-relaxed",
        };
      }
      if (goalType === "diet") {
        return {
          label: "ダイエットメモ",
          icon: "salad",
          wrapperClass: "bg-sky-50/60 border-t border-sky-100",
          iconClass: "w-4 h-4 text-sky-500 mt-0.5 flex-shrink-0",
          titleClass: "text-xs font-bold text-sky-700 mb-1",
          textClass: "text-sm text-sky-900 leading-relaxed",
        };
      }
      return {
        label: "栄養メモ",
        icon: "leaf",
        wrapperClass: "bg-green-50/50 border-t border-green-100",
        iconClass: "w-4 h-4 text-green-500 mt-0.5 flex-shrink-0",
        titleClass: "text-xs font-bold text-green-700 mb-1",
        textClass: "text-sm text-green-900 leading-relaxed",
      };
    }

    function getRecipeGoalInstruction(goalType) {
      if (goalType === "muscle") {
        return "高たんぱくを優先し、調理後の栄養バランスが取りやすい手順にしてください。";
      }
      if (goalType === "diet") {
        return "低脂質を意識し、揚げずに作れる手順を優先してください。";
      }
      return "家庭で作りやすく、再現しやすい手順にしてください。";
    }

    async function requestDishRecipe(dayPlan, goalType, dishType) {
      const dishMeta = getDishMeta(dayPlan, dishType);
      const minSteps = getRecipeMinStepCount(dishMeta.type);
      const systemPrompt = `あなたは家庭料理のレシピ開発者です。
与えられた料理名と利用可能食材に合わせて、実際に作れる詳細レシピを作成してください。
返答は必ずJSONオブジェクトのみで、説明文やコードブロックは出さないでください。`;
      const userPrompt = `料理区分: ${dishMeta.label}
料理名: ${dishMeta.name}
目的: ${goalType}
目的補足: ${getRecipeGoalInstruction(goalType)}
使える食材(優先): ${normalizeStringArray(dayPlan?.used_ingredients).join("、")}
追加候補食材: ${normalizeStringArray(dayPlan?.recommended_ingredients_used).join("、")}

条件:
- dish_name は料理名をそのまま返す（表記変更しない）
- servings は「2人分」など文字列で返す
- prep_time_min, cook_time_min は整数
- ingredients は材料名と分量を具体的に（3〜14件）
- steps は${minSteps}〜10手順で、各手順に火加減・時間・状態変化の目安を入れる
- tips は失敗しにくいコツを1〜2文`;

      const requestWithModel = async (model) => {
        const supportsStrictSchema = model === "openai/gpt-oss-120b" || model === "openai/gpt-oss-20b";
        const responseFormat = {
          type: "json_schema",
          json_schema: {
            name: "dish_recipe_detail",
            strict: supportsStrictSchema,
            schema: MAIN_RECIPE_RESPONSE_SCHEMA,
          },
        };
        const token = await currentUser.getIdToken(true);
        const response = await fetch(GROQ_ENDPOINT, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${token}`,
          },
          body: JSON.stringify({
            model,
            temperature: 0.35,
            max_tokens: 1800,
            response_format: responseFormat,
            messages: [
              { role: "system", content: systemPrompt },
              { role: "user", content: userPrompt },
            ],
          }),
        });

        const text = await response.text();
        if (!response.ok) {
          let message = `API error: ${response.status}`;
          try {
            const parsed = JSON.parse(text);
            message = parsed?.error || parsed?.message || message;
          } catch {}
          const error = new Error(String(message));
          if (response.status === 429) {
            error.rateLimited = true;
            const retryAfterHeader = Number(response.headers.get("retry-after") || "0");
            if (Number.isFinite(retryAfterHeader) && retryAfterHeader > 0) {
              error.retryAfterMs = Math.ceil(retryAfterHeader * 1000);
            }
            if (!error.retryAfterMs) {
              const retryMatch = String(message).match(/([0-9]+)\s*s/i);
              if (retryMatch) {
                error.retryAfterMs = Math.ceil(Number(retryMatch[1]) * 1000);
              }
            }
            if (error.retryAfterMs) {
              setCooldownUntil(Date.now() + error.retryAfterMs);
            }
          }
          throw error;
        }

        let parsedResponse;
        try {
          parsedResponse = JSON.parse(text);
        } catch {
          throw new Error("API応答の解析に失敗しました。");
        }
        const rawContent = extractAssistantContent(parsedResponse);
        if (!rawContent) {
          throw new Error("AIから有効な応答が返ってきませんでした。");
        }
        const parsedJson = extractJsonObject(rawContent) || (
          parsedResponse && typeof parsedResponse === "object"
            ? extractJsonObject(JSON.stringify(parsedResponse))
            : null
        );
        if (!parsedJson) {
          throw new Error("AI応答がJSON形式ではありません。");
        }
        const normalized = normalizeGeneratedRecipe(parsedJson);
        validateGeneratedRecipeConsistency(normalized, dishMeta.name, dishMeta.label);
        if (normalized.ingredients.length < 3 || normalized.steps.length < minSteps) {
          throw new Error(`${dishMeta.label}レシピの詳細が不足しています。`);
        }
        return normalized;
      };

      try {
        return await requestWithModel(GROQ_MODEL);
      } catch (primaryError) {
        if (primaryError?.rateLimited || !isContentGenerationError(primaryError)) {
          throw primaryError;
        }
        return requestWithModel(GROQ_FALLBACK_MODEL);
      }
    }

    async function handleGenerateRecipeButton(buttonEl) {
      const dayIndex = Number(buttonEl?.dataset?.dayIndex || "-1");
      if (!Number.isInteger(dayIndex) || dayIndex < 0) return;
      const dayPlan = renderedMenuForRecipe[dayIndex];
      if (!dayPlan) return;
      const dishTypeRaw = String(buttonEl?.dataset?.dishType || "main");
      const dishType = dishTypeRaw === "side" || dishTypeRaw === "soup" ? dishTypeRaw : "main";
      const dishMeta = getDishMeta(dayPlan, dishType);
      if (!dishMeta.name) {
        showError("料理名が取得できないため、作り方を生成できません。");
        return;
      }
      if (!currentUser) {
        showError("先にGoogleでログインしてください。");
        return;
      }

      const recipeKey = buildRecipeCacheKey(dayPlan, dayIndex, dishType, dishMeta.name);
      const labelEl = buttonEl.querySelector(".recipe-btn-text");
      const iconEl = buttonEl.querySelector(".recipe-btn-icon");
      const now = Date.now();
      if (clientCooldownUntil > now) {
        const waitSec = Math.ceil((clientCooldownUntil - now) / 1000);
        showError(`現在リクエストが集中しています。あと${waitSec}秒ほど待ってからお試しください。`);
        return;
      }
      buttonEl.disabled = true;
      if (labelEl) labelEl.textContent = "生成中...";
      if (iconEl) iconEl.innerHTML = `<i data-lucide="loader-2" class="w-3 h-3 animate-spin"></i>`;
      lucide.createIcons();

      try {
        const recipe = await requestDishRecipe(dayPlan, renderedGoalTypeForRecipe, dishType);
        generatedRecipeMap.set(recipeKey, recipe);
        const detailEl = document.getElementById(`recipe-detail-${dishType}-${dayIndex}`);
        if (detailEl) {
          detailEl.innerHTML = renderRecipeDetailHtml(recipe, dishMeta.label);
          detailEl.classList.remove("hidden");
        }
        if (labelEl) labelEl.textContent = "作り方を再生成";
      } catch (error) {
        console.error(error);
        if (error?.rateLimited) {
          const retrySec = Number.isFinite(error?.retryAfterMs) ? Math.ceil(error.retryAfterMs / 1000) : 10;
          showError(`アクセスが集中しています。${retrySec}秒ほど待ってから、もう一度お試しください。`);
        } else if (
          String(error?.message || "").includes("名が不足しています") ||
          String(error?.message || "").includes("名が一致していません")
        ) {
          showError(`${dishMeta.label}と一致しない作り方が返ったため、再生成してください。`);
        } else {
          showError("作り方の生成中にエラーが発生しました。もう一度お試しください。");
        }
      } finally {
        buttonEl.disabled = false;
        if (labelEl) labelEl.textContent = generatedRecipeMap.has(recipeKey) ? "作り方を再生成" : "作り方を生成";
        if (iconEl) iconEl.innerHTML = `<i data-lucide="wand-sparkles" class="w-3 h-3"></i>`;
        lucide.createIcons();
      }
    }

    async function generateMenu(goalType = "normal") {
      const now = Date.now();
      if (clientCooldownUntil > now) {
        const waitSec = Math.ceil((clientCooldownUntil - now) / 1000);
        showError(`現在リクエストが集中しています。あと${waitSec}秒ほど待ってからお試しください。`);
        return;
      }
      const ingredients = ingredientsInput.value.trim();
      if (!ingredients) {
        showError("食材を入力してください。");
        return;
      }
      if (!currentUser) {
        showError("先にGoogleでログインしてください。");
        return;
      }

      setLoading(true, goalType);
      const goalInstruction = getGoalInstruction(goalType);

      const systemPrompt = `あなたはプロの栄養士であり、献立作成の専門家です。
ユーザーが買い込んだ食材を使って、1週間（7日間）の夕食献立を提案してください。

${goalInstruction}

【条件】
1. 栄養バランス（主食、主菜、副菜、汁物）を考慮する。
2. 入力食材を無駄なく使い切る工夫をする。
3. 栄養不足が見込まれる場合は「おすすめ追加食材」を提案し、献立に組み込む。
4. 基本調味料と主食（白米・パン・パスタ等）は常備前提。
5. 必ずJSONオブジェクトのみを返す。コードブロックや説明文は禁止。
6. 各日の主菜・副菜・汁物は、できるだけ重複を避ける。
7. 1週間でたんぱく源（魚・肉・卵・大豆製品）が偏らないよう分散させる。
8. 入力食材をできるだけ多く使い、menu全体で最低でも半分以上の食材に触れる。
9. 1週間の料理ジャンルは幅広くし、和食・洋食・アジアン/中華/韓国に加えてイタリアン・フレンチも候補にする。
10. 週内に中華・イタリアン・フレンチをできるだけ含める。
11. 筋肉増量モードでは高たんぱく要素を中心にし、炭水化物源も適度に確保する。
12. ダイエットモードでは揚げ物を控えめにし、野菜・食物繊維を意識する。
13. 各日の夕食について、主菜・副菜・汁物を合計した概算カロリー daily_total_kcal（整数）を出す。
14. 各日ごとに style_tag（例: 和食, 洋食, イタリアン, フレンチ, 中華, 韓国, 東南アジア・エスニック）を付ける。
15. nutrition_pointは30〜120文字程度で簡潔に書く。
16. レシピ手順・材料・分量の詳細はこの出力に含めない（主菜の作り方は別APIで後から生成するため）。
17. JSON項目以外の説明は出力しない。
18. JSONスキーマ:
{
  "recommended_additional_ingredients": [{"ingredient":"", "reason":""}],
  "menu": [{
    "day":"月曜日",
    "style_tag":"和食",
    "main_dish":"",
    "side_dish":"",
    "soup":"",
    "used_ingredients":[""],
    "recommended_ingredients_used":[""],
    "daily_total_kcal": 650,
    "nutrition_point":""
  }]
}`;
      const userPrompt = `以下の食材で1週間分の夕食献立を作成してください。\n\n食材リスト:\n${ingredients}`;

      const fetchWithRetry = async (retries = 0, delay = 1200, strictJsonMode = false, model = GROQ_MODEL) => {
        try {
          const nowInside = Date.now();
          if (clientCooldownUntil > nowInside) {
            const waitSec = Math.ceil((clientCooldownUntil - nowInside) / 1000);
            const cooldownError = new Error(`Rate limit cooldown active. Please try again in ${waitSec}s.`);
            cooldownError.rateLimited = true;
            cooldownError.retryAfterMs = waitSec * 1000;
            throw cooldownError;
          }
          const supportsStrictSchema = model === "openai/gpt-oss-120b" || model === "openai/gpt-oss-20b";
          const responseFormat = {
            type: "json_schema",
            json_schema: {
              name: "weekly_dinner_plan",
              strict: supportsStrictSchema,
              schema: MENU_RESPONSE_SCHEMA,
            },
          };
          const effectiveUserPrompt = strictJsonMode
            ? `${userPrompt}\n\n重要: 前回の応答に不備がありました。必ず7日分ちょうどのJSONオブジェクトのみを返してください。`
            : userPrompt;
          const token = await currentUser.getIdToken(true);
          const response = await fetch(GROQ_ENDPOINT, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${token}`,
            },
            body: JSON.stringify({
              model,
              temperature: GENERATION_TEMPERATURE,
              max_tokens: GENERATION_MAX_TOKENS,
              response_format: responseFormat,
              messages: [
                { role: "system", content: systemPrompt },
                { role: "user", content: effectiveUserPrompt },
              ],
            }),
          });

          const text = await response.text();
          if (!response.ok) {
            let message = `API error: ${response.status}`;
            try {
              const parsed = JSON.parse(text);
              message = parsed?.error || parsed?.message || message;
            } catch {}
            const error = new Error(String(message));
            if (response.status === 429) {
              error.rateLimited = true;
              const retryAfterHeader = Number(response.headers.get("retry-after") || "0");
              if (Number.isFinite(retryAfterHeader) && retryAfterHeader > 0) {
                error.retryAfterMs = Math.ceil(retryAfterHeader * 1000);
              }
              if (!error.retryAfterMs) {
                const retryMatch = String(message).match(/([0-9]+)\s*s/i);
                if (retryMatch) {
                  error.retryAfterMs = Math.ceil(Number(retryMatch[1]) * 1000);
                }
              }
              if (error.retryAfterMs) {
                setCooldownUntil(Date.now() + error.retryAfterMs);
              }
            }
            throw error;
          }

          let parsedResponse;
          try {
            parsedResponse = JSON.parse(text);
          } catch {
            throw new Error("API応答の解析に失敗しました。");
          }
          const rawContent = extractAssistantContent(parsedResponse);
          if (!rawContent) {
            if (!strictJsonMode) {
              return fetchWithRetry(retries, delay, true, model);
            }
            throw new Error("AIから有効な応答が返ってきませんでした。");
          }
          const parsedJson = extractJsonObject(rawContent) || (
            parsedResponse && typeof parsedResponse === "object"
              ? extractJsonObject(JSON.stringify(parsedResponse))
              : null
          );
          if (!parsedJson) {
            throw new Error("AI応答がJSON形式ではありません。");
          }
          return normalizeMenuResponse(parsedJson, ingredients, goalType);
        } catch (err) {
          if (err?.rateLimited) throw err;
          if (retries > 0) {
            await new Promise((resolve) => setTimeout(resolve, delay));
            return fetchWithRetry(retries - 1, delay * 2, strictJsonMode, model);
          }
          throw err;
        }
      };

      try {
        let result;
        try {
          result = await fetchWithRetry();
        } catch (primaryError) {
          if (!isContentGenerationError(primaryError)) {
            throw primaryError;
          }
          // 主モデルで空応答が続く場合のみ、許可モデルへ1回フォールバック
          result = await fetchWithRetry(1, 1200, true, GROQ_FALLBACK_MODEL);
        }
        saveLastPlan(result, goalType);
        renderResults(result, goalType);
      } catch (err) {
        console.error(err);
        if (err?.rateLimited) {
          const retrySecFromMs = Number.isFinite(err?.retryAfterMs) ? Math.ceil(err.retryAfterMs / 1000) : 10;
          setCooldownUntil(Date.now() + retrySecFromMs * 1000);
          showError(`アクセスが集中しています。${retrySecFromMs}秒ほど待ってから、もう一度お試しください。`);
        } else {
          showError("献立の作成中にエラーが発生しました。時間を置いて再度お試しいただくか、食材の記述を変えてみてください。");
        }
      } finally {
        setLoading(false);
      }
    }

    function renderResults(data, goalType = "normal") {
      const memoTheme = getMemoTheme(goalType);
      renderedMenuForRecipe = Array.isArray(data?.menu) ? data.menu : [];
      renderedGoalTypeForRecipe = goalType;
      generatedRecipeMap.clear();
      if (data.recommended_additional_ingredients && data.recommended_additional_ingredients.length > 0) {
        recommendedList.innerHTML = data.recommended_additional_ingredients.map((item) => `
          <li class="flex items-start gap-2 text-sm text-blue-900 bg-white/60 p-2 rounded-lg">
            <i data-lucide="plus-circle" class="w-4 h-4 text-blue-500 mt-0.5 flex-shrink-0"></i>
            <div>
              <span class="font-bold text-blue-700">${escapeHtml(item.ingredient)}:</span> ${escapeHtml(item.reason)}
            </div>
          </li>
        `).join('');
        recommendedSection.classList.remove('hidden');
      } else {
        recommendedSection.classList.add('hidden');
      }

      menuGrid.innerHTML = renderedMenuForRecipe.map((dayPlan, dayIndex) => {
        const usedIngredientsHtml = dayPlan.used_ingredients.map((ing) =>
          `<span class="px-2 py-1 bg-gray-100 text-gray-600 rounded-md text-xs">${escapeHtml(ing)}</span>`
        ).join('');
        const mainSearchUrl = buildRecipeSearchUrl(dayPlan.main_dish);
        const sideSearchUrl = buildRecipeSearchUrl(dayPlan.side_dish);
        const soupSearchUrl = buildRecipeSearchUrl(dayPlan.soup);

        let recommendedIngredientsHtml = '';
        if (dayPlan.recommended_ingredients_used && dayPlan.recommended_ingredients_used.length > 0) {
          recommendedIngredientsHtml = `
            <div>
              <span class="text-xs font-bold text-blue-500 block mb-1.5">追加おすすめ食材</span>
              <div class="flex flex-wrap gap-1.5">
                ${dayPlan.recommended_ingredients_used.map((ing) => `
                  <span class="px-2 py-1 bg-blue-50 border border-blue-200 text-blue-700 rounded-md text-xs font-medium flex items-center gap-1">
                    <i data-lucide="plus-circle" class="w-3 h-3"></i>
                    ${escapeHtml(ing)}
                  </span>
                `).join('')}
              </div>
            </div>
          `;
        }

        return `
          <div class="bg-white rounded-2xl shadow-sm border border-gray-100 overflow-hidden hover:shadow-md transition-shadow flex flex-col">
            <div class="bg-orange-100/50 px-5 py-3 border-b border-orange-100">
              <div class="flex items-center justify-between gap-2">
                <span class="font-bold text-orange-800 text-lg">${escapeHtml(dayPlan.day)}</span>
                <div class="flex items-center gap-2">
                  <span class="text-[11px] font-bold text-slate-700 bg-white/90 border border-slate-200 rounded-full px-2 py-1">${escapeHtml(dayPlan.style_tag)}</span>
                  <span class="text-xs font-bold text-orange-700 bg-white/70 border border-orange-200 rounded-full px-2 py-1">約${escapeHtml(dayPlan.daily_total_kcal)} kcal</span>
                </div>
              </div>
            </div>

            <div class="p-5 flex-grow space-y-4">
              <div>
                <span class="text-xs font-bold text-gray-400 uppercase tracking-wider block mb-1">主菜 (Main)</span>
                <p class="font-semibold text-gray-800 text-lg leading-tight">${escapeHtml(dayPlan.main_dish)}</p>
                <div class="mt-1">
                  <a href="${mainSearchUrl}" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1 text-xs text-orange-600 hover:text-orange-700 underline underline-offset-2">
                    <i data-lucide="search" class="w-3 h-3"></i> 作り方を検索
                  </a>
                </div>
                <div class="mt-2">
                  <button type="button" data-day-index="${dayIndex}" data-dish-type="main" class="generate-recipe-btn inline-flex items-center gap-1 px-2.5 py-1.5 rounded-md bg-orange-500 hover:bg-orange-600 text-white text-xs font-semibold transition-colors disabled:opacity-60 disabled:cursor-not-allowed">
                    <span class="recipe-btn-icon flex items-center"><i data-lucide="wand-sparkles" class="w-3 h-3"></i></span>
                    <span class="recipe-btn-text">作り方を生成</span>
                  </button>
                </div>
                <div id="recipe-detail-main-${dayIndex}" class="hidden"></div>
              </div>

              <div class="grid grid-cols-2 gap-3">
                <div>
                  <span class="text-xs font-bold text-gray-400 uppercase tracking-wider block mb-1">副菜 (Side)</span>
                  <p class="text-gray-700 text-sm">${escapeHtml(dayPlan.side_dish)}</p>
                  <a href="${sideSearchUrl}" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1 mt-1 text-xs text-orange-600 hover:text-orange-700 underline underline-offset-2">
                    <i data-lucide="search" class="w-3 h-3"></i> 作り方を検索
                  </a>
                  <div class="mt-2">
                    <button type="button" data-day-index="${dayIndex}" data-dish-type="side" class="generate-recipe-btn inline-flex items-center gap-1 px-2.5 py-1.5 rounded-md bg-amber-500 hover:bg-amber-600 text-white text-xs font-semibold transition-colors disabled:opacity-60 disabled:cursor-not-allowed">
                      <span class="recipe-btn-icon flex items-center"><i data-lucide="wand-sparkles" class="w-3 h-3"></i></span>
                      <span class="recipe-btn-text">作り方を生成</span>
                    </button>
                  </div>
                  <div id="recipe-detail-side-${dayIndex}" class="hidden"></div>
                </div>
                <div>
                  <span class="text-xs font-bold text-gray-400 uppercase tracking-wider block mb-1">汁物 (Soup)</span>
                  <p class="text-gray-700 text-sm">${escapeHtml(dayPlan.soup)}</p>
                  <a href="${soupSearchUrl}" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1 mt-1 text-xs text-orange-600 hover:text-orange-700 underline underline-offset-2">
                    <i data-lucide="search" class="w-3 h-3"></i> 作り方を検索
                  </a>
                  <div class="mt-2">
                    <button type="button" data-day-index="${dayIndex}" data-dish-type="soup" class="generate-recipe-btn inline-flex items-center gap-1 px-2.5 py-1.5 rounded-md bg-sky-500 hover:bg-sky-600 text-white text-xs font-semibold transition-colors disabled:opacity-60 disabled:cursor-not-allowed">
                      <span class="recipe-btn-icon flex items-center"><i data-lucide="wand-sparkles" class="w-3 h-3"></i></span>
                      <span class="recipe-btn-text">作り方を生成</span>
                    </button>
                  </div>
                  <div id="recipe-detail-soup-${dayIndex}" class="hidden"></div>
                </div>
              </div>

              <hr class="border-gray-100" />

              <div class="space-y-3">
                <div>
                  <span class="text-xs font-bold text-gray-400 block mb-1.5">入力食材</span>
                  <div class="flex flex-wrap gap-1.5">
                    ${usedIngredientsHtml}
                  </div>
                </div>
                ${recommendedIngredientsHtml}
              </div>
            </div>

            <div class="${memoTheme.wrapperClass} p-4 mt-auto">
              <div class="flex items-start gap-2">
                <i data-lucide="${memoTheme.icon}" class="${memoTheme.iconClass}"></i>
                <div>
                  <p class="${memoTheme.titleClass}">${memoTheme.label}</p>
                  <p class="${memoTheme.textClass}">${escapeHtml(dayPlan.nutrition_point)}</p>
                </div>
              </div>
            </div>
          </div>
        `;
      }).join('');

      lucide.createIcons();
      resultsSection.classList.remove('hidden');
    }

    initializeAuthState();
  </script>
</body>
</html>
