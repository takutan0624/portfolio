<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>1週間献立メーカー</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <!-- Firebase (Compat) -->
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
  <style>
    /* フェードインアニメーション用 */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .animate-fade-in {
      animation: fadeIn 0.7s ease-out forwards;
    }
  </style>
</head>
<body class="min-h-screen bg-orange-50 font-sans text-gray-800">

  <!-- Header -->
  <header class="bg-white shadow-sm border-b border-orange-100 sticky top-0 z-10">
    <div class="max-w-4xl mx-auto px-4 py-4 flex items-center justify-center gap-3">
      <i data-lucide="chef-hat" class="text-orange-500 w-8 h-8"></i>
      <h1 class="text-2xl font-bold text-orange-800 tracking-tight">1週間献立メーカー</h1>
    </div>
  </header>

  <main class="max-w-4xl mx-auto px-4 py-8">
    <!-- Input Section -->
    <div class="bg-white rounded-2xl shadow-md p-6 mb-8 border border-orange-100">
      <div class="flex items-center gap-2 mb-4">
        <i data-lucide="shopping-bag" class="text-orange-500 w-5 h-5"></i>
        <h2 class="text-lg font-semibold text-gray-700">冷蔵庫にある食材・買ってきた食材を入力</h2>
      </div>
      
      <textarea
        id="ingredientsInput"
        placeholder="例:&#10;豚こま肉、鶏もも肉、鮭、キャベツ、玉ねぎ、にんじん、じゃがいも、卵"
        class="w-full h-32 p-4 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-300 focus:border-orange-500 outline-none resize-none mb-4 transition-all"
      ></textarea>

      <div class="mb-4 p-3 bg-orange-50 border border-orange-100 rounded-xl flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
        <p id="authStatus" class="text-sm text-orange-800">認証を初期化しています...</p>
        <button
          id="authBtn"
          class="w-full sm:w-auto px-4 py-2 bg-white border border-orange-300 text-orange-700 rounded-lg text-sm font-semibold hover:bg-orange-100 transition-colors disabled:opacity-60 disabled:cursor-not-allowed"
        >
          Googleでログイン
        </button>
      </div>
      
      <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
        <button
          id="sampleBtn"
          class="text-sm text-orange-600 hover:text-orange-800 underline underline-offset-2"
        >
          サンプルの食材を入力する
        </button>

        <div class="w-full sm:w-auto grid grid-cols-1 sm:grid-cols-3 gap-2">
          <button
            id="generateBtn"
            class="w-full px-4 py-3 bg-orange-500 hover:bg-orange-600 text-white rounded-xl font-bold shadow-sm flex items-center justify-center gap-2 transition-colors disabled:opacity-70 disabled:cursor-not-allowed"
          >
            <span id="btnIcon" class="flex items-center"><i data-lucide="utensils" class="w-5 h-5"></i></span>
            <span id="btnText">通常献立</span>
          </button>
          <button
            id="muscleBtn"
            class="w-full px-4 py-3 bg-emerald-500 hover:bg-emerald-600 text-white rounded-xl font-bold shadow-sm transition-colors disabled:opacity-70 disabled:cursor-not-allowed"
          >
            筋肉増量
          </button>
          <button
            id="dietBtn"
            class="w-full px-4 py-3 bg-sky-500 hover:bg-sky-600 text-white rounded-xl font-bold shadow-sm transition-colors disabled:opacity-70 disabled:cursor-not-allowed"
          >
            ダイエット
          </button>
        </div>
      </div>
      
      <!-- Error Message -->
      <div id="errorBox" class="hidden mt-4 p-4 bg-red-50 text-red-600 rounded-lg flex items-start gap-2 text-sm">
        <i data-lucide="info" class="w-5 h-5 flex-shrink-0"></i>
        <p id="errorText"></p>
      </div>
    </div>

    <!-- Results Section -->
    <div id="resultsSection" class="hidden space-y-6 animate-fade-in">
      
      <!-- Recommended Additional Ingredients -->
      <div id="recommendedSection" class="hidden bg-blue-50 border border-blue-200 rounded-2xl p-5">
        <div class="flex items-center gap-2 mb-3">
          <i data-lucide="sparkles" class="text-blue-500 w-5 h-5"></i>
          <h3 class="font-bold text-blue-800">栄養UP！おすすめ追加食材</h3>
        </div>
        <p class="text-sm text-blue-800 mb-3">
          入力された食材だけでは不足しがちな栄養素を補うため、以下の食材を買い足して献立に組み込んでいます。
        </p>
        <ul id="recommendedList" class="space-y-2">
          <!-- JSで追加 -->
        </ul>
      </div>

      <!-- Menu Grid -->
      <div class="flex items-center gap-2 mb-6 border-b border-orange-200 pb-2 pt-4">
        <i data-lucide="calendar-days" class="text-orange-500 w-6 h-6"></i>
        <h2 class="text-2xl font-bold text-gray-800">1週間の夕食プラン</h2>
      </div>

      <div id="menuGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <!-- JSで追加 -->
      </div>
    </div>
  </main>

  <script>
    lucide.createIcons();

    const FIREBASE_CONFIG_ENDPOINTS = ["/api/firebase-config-antiage", "/api/firebase-config-mental"];
    const FIREBASE_APP_NAME = "antiage-auth";
    const GROQ_ENDPOINT = "/api/groq-antiage";
    const GROQ_MODEL = "openai/gpt-oss-120b";
    const GROQ_FALLBACK_MODEL = "llama-3.3-70b-versatile";
    const GENERATION_TEMPERATURE = 0.55;
    const GENERATION_MAX_TOKENS = 3200;
    const MENU_RESPONSE_SCHEMA = {
      type: "object",
      additionalProperties: false,
      properties: {
        recommended_additional_ingredients: {
          type: "array",
          items: {
            type: "object",
            additionalProperties: false,
            properties: {
              ingredient: { type: "string", minLength: 1 },
              reason: { type: "string", minLength: 24 },
            },
            required: ["ingredient", "reason"],
          },
        },
        menu: {
          type: "array",
          minItems: 7,
          maxItems: 7,
          items: {
            type: "object",
            additionalProperties: false,
            properties: {
              day: { type: "string", minLength: 1 },
              main_dish: { type: "string", minLength: 1 },
              side_dish: { type: "string", minLength: 1 },
              soup: { type: "string", minLength: 1 },
              used_ingredients: {
                type: "array",
                minItems: 2,
                items: { type: "string", minLength: 1 },
              },
              recommended_ingredients_used: {
                type: "array",
                items: { type: "string", minLength: 1 },
              },
              nutrition_point: { type: "string", minLength: 20 },
            },
            required: [
              "day",
              "main_dish",
              "side_dish",
              "soup",
              "used_ingredients",
              "recommended_ingredients_used",
              "nutrition_point",
            ],
          },
        },
      },
      required: ["recommended_additional_ingredients", "menu"],
    };
    const sampleIngredients = "豚こま肉、鶏もも肉、鮭、キャベツ、玉ねぎ、にんじん、じゃがいも、卵";

    const ingredientsInput = document.getElementById('ingredientsInput');
    const sampleBtn = document.getElementById('sampleBtn');
    const generateBtn = document.getElementById('generateBtn');
    const muscleBtn = document.getElementById('muscleBtn');
    const dietBtn = document.getElementById('dietBtn');
    const btnIcon = document.getElementById('btnIcon');
    const btnText = document.getElementById('btnText');
    const errorBox = document.getElementById('errorBox');
    const errorText = document.getElementById('errorText');
    const resultsSection = document.getElementById('resultsSection');
    const recommendedSection = document.getElementById('recommendedSection');
    const recommendedList = document.getElementById('recommendedList');
    const menuGrid = document.getElementById('menuGrid');
    const authBtn = document.getElementById('authBtn');
    const authStatus = document.getElementById('authStatus');

    let authContextPromise = null;
    let currentUser = null;

    sampleBtn.addEventListener('click', () => {
      ingredientsInput.value = sampleIngredients;
      clearError();
    });
    ingredientsInput.addEventListener('input', clearError);
    authBtn.addEventListener('click', handleAuthButtonClick);
    generateBtn.addEventListener('click', () => generateMenu("normal"));
    muscleBtn.addEventListener('click', () => generateMenu("muscle"));
    dietBtn.addEventListener('click', () => generateMenu("diet"));

    function showError(message) {
      errorText.textContent = message;
      errorBox.classList.remove('hidden');
    }

    function clearError() {
      errorBox.classList.add('hidden');
      errorText.textContent = "";
    }

    function getGoalLoadingText(goalType) {
      if (goalType === "muscle") return "AIが筋肉増量向け献立を考案中...";
      if (goalType === "diet") return "AIがダイエット向け献立を考案中...";
      return "AIが通常献立を考案中...";
    }

    function setLoading(isLoading, goalType = "normal") {
      if (isLoading) {
        generateBtn.disabled = true;
        muscleBtn.disabled = true;
        dietBtn.disabled = true;
        ingredientsInput.disabled = true;
        sampleBtn.disabled = true;
        authBtn.disabled = true;
        btnIcon.innerHTML = `<i data-lucide="loader-2" class="w-5 h-5 animate-spin"></i>`;
        btnText.textContent = getGoalLoadingText(goalType);
        clearError();
        resultsSection.classList.add('hidden');
      } else {
        generateBtn.disabled = false;
        muscleBtn.disabled = false;
        dietBtn.disabled = false;
        ingredientsInput.disabled = false;
        sampleBtn.disabled = false;
        authBtn.disabled = false;
        btnIcon.innerHTML = `<i data-lucide="utensils" class="w-5 h-5"></i>`;
        btnText.textContent = "通常献立";
      }
      updateAuthUI();
      lucide.createIcons();
    }

    function parseFirebaseConfigCandidate(candidate) {
      if (!candidate) return null;
      if (typeof candidate === "string") {
        try { return JSON.parse(candidate); } catch { return null; }
      }
      if (typeof candidate === "object") return candidate;
      return null;
    }

    function isValidFirebaseConfig(config) {
      return !!(config && config.apiKey && config.projectId && config.authDomain);
    }

    function readFirebaseConfigRuntime() {
      const direct = parseFirebaseConfigCandidate(typeof __firebase_config !== "undefined" ? __firebase_config : null);
      if (isValidFirebaseConfig(direct)) return direct;

      const fromWindow = parseFirebaseConfigCandidate(window.__FIREBASE_CONFIG__);
      if (isValidFirebaseConfig(fromWindow)) return fromWindow;

      const meta = document.querySelector('meta[name="firebase-config"]');
      const fromMeta = parseFirebaseConfigCandidate(meta?.content);
      if (isValidFirebaseConfig(fromMeta)) return fromMeta;
      return null;
    }

    async function fetchFirebaseConfigFromServer() {
      for (const endpoint of FIREBASE_CONFIG_ENDPOINTS) {
        try {
          const res = await fetch(endpoint, { method: "GET", cache: "no-store" });
          if (!res.ok) continue;
          const data = await res.json();
          if (isValidFirebaseConfig(data)) return data;
        } catch {}
      }
      return null;
    }

    async function initFirebaseAuth() {
      if (authContextPromise) return authContextPromise;
      authContextPromise = (async () => {
        if (typeof firebase === "undefined") {
          throw new Error("Firebase SDKの読み込みに失敗しました。");
        }
        const firebaseConfig = readFirebaseConfigRuntime() || await fetchFirebaseConfigFromServer();
        if (!isValidFirebaseConfig(firebaseConfig)) {
          throw new Error("Firebase設定が見つかりません。/api/firebase-config-antiage を確認してください。");
        }
        const existing = firebase.apps.find((app) => app.name === FIREBASE_APP_NAME);
        const app = existing || firebase.initializeApp(firebaseConfig, FIREBASE_APP_NAME);
        const auth = firebase.auth(app);
        const provider = new firebase.auth.GoogleAuthProvider();
        provider.setCustomParameters({ prompt: "select_account" });
        return { auth, provider };
      })();
      return authContextPromise;
    }

    function updateAuthUI() {
      if (currentUser) {
        const label = currentUser.displayName || currentUser.email || "ログイン中";
        authStatus.textContent = `ログイン中: ${label}`;
        authBtn.textContent = "ログアウト";
      } else {
        authStatus.textContent = "献立作成にはGoogleログインが必要です";
        authBtn.textContent = "Googleでログイン";
      }
    }

    async function initializeAuthState() {
      try {
        const { auth } = await initFirebaseAuth();
        auth.onAuthStateChanged((user) => {
          currentUser = user || null;
          updateAuthUI();
        });
      } catch (error) {
        console.error(error);
        authStatus.textContent = "ログイン設定の読み込みに失敗しました";
        authBtn.disabled = true;
        showError("Firebase設定の取得に失敗しました。管理者設定（firebase-config-antiage API / 環境変数）を確認してください。");
      }
    }

    async function handleAuthButtonClick() {
      clearError();
      try {
        const { auth, provider } = await initFirebaseAuth();
        authBtn.disabled = true;
        if (currentUser) {
          await auth.signOut();
        } else {
          await auth.signInWithPopup(provider);
        }
      } catch (error) {
        console.error(error);
        const msg = String(error?.message || "");
        if (msg.includes("popup")) {
          showError("ログインポップアップを確認して、再度お試しください。");
        } else {
          showError("ログイン処理でエラーが発生しました。時間をおいて再度お試しください。");
        }
      } finally {
        authBtn.disabled = false;
        updateAuthUI();
      }
    }

    function extractJsonObject(raw) {
      if (typeof raw !== "string") return null;
      const tagStart = raw.indexOf("<json>");
      const tagEnd = raw.indexOf("</json>");
      let candidate = raw;
      if (tagStart !== -1 && tagEnd !== -1 && tagEnd > tagStart) {
        candidate = raw.slice(tagStart + 6, tagEnd);
      } else {
        const start = raw.indexOf("{");
        const end = raw.lastIndexOf("}");
        if (start !== -1 && end !== -1 && end > start) {
          candidate = raw.slice(start, end + 1);
        }
      }
      try {
        return JSON.parse(candidate);
      } catch {
        return null;
      }
    }

    function extractTextContent(value) {
      if (typeof value === "string") return value.trim();
      if (Array.isArray(value)) {
        return value
          .map((part) => {
            if (typeof part === "string") return part;
            if (part && typeof part === "object") {
              if (typeof part.text === "string") return part.text;
              if (typeof part.content === "string") return part.content;
            }
            return "";
          })
          .join("\n")
          .trim();
      }
      if (value && typeof value === "object") {
        if (typeof value.text === "string") return value.text.trim();
        if (typeof value.content === "string") return value.content.trim();
      }
      return "";
    }

    function extractAssistantContent(payload) {
      if (!payload || typeof payload !== "object") return "";
      const candidates = [
        payload.content,
        payload.output_text,
        payload.text,
        payload.message,
        payload?.choices?.[0]?.message?.content,
        payload?.choices?.[0]?.text,
      ];
      for (const candidate of candidates) {
        const text = extractTextContent(candidate);
        if (text) return text;
      }
      return "";
    }

    function normalizeStringArray(value) {
      if (!Array.isArray(value)) return [];
      return value
        .map((item) => String(item || "").trim())
        .filter(Boolean);
    }

    function parseIngredientList(raw) {
      return Array.from(new Set(
        String(raw || "")
          .split(/[\n,、，]/g)
          .map((v) => v.trim())
          .filter((v) => v.length >= 2)
      ));
    }

    function normalizeDishName(value) {
      return String(value || "")
        .toLowerCase()
        .replace(/\s+/g, "")
        .replace(/[()（）「」『』・,，、]/g, "");
    }

    function containsAny(text, keywords) {
      return keywords.some((word) => text.includes(word));
    }

    function validateMenuQuality(menu, inputIngredientsRaw) {
      const mainSet = new Set(menu.map((item) => normalizeDishName(item.main_dish)).filter(Boolean));
      if (mainSet.size < 6) {
        throw new Error("主菜のバリエーションが不足しています。");
      }

      const sideSet = new Set(menu.map((item) => normalizeDishName(item.side_dish)).filter(Boolean));
      if (sideSet.size < 6) {
        throw new Error("副菜のバリエーションが不足しています。");
      }

      const soupSet = new Set(menu.map((item) => normalizeDishName(item.soup)).filter(Boolean));
      if (soupSet.size < 5) {
        throw new Error("汁物のバリエーションが不足しています。");
      }

      const proteinCategories = {
        fish: ["鮭", "さば", "鯖", "ぶり", "たら", "鱈", "まぐろ", "いわし", "あじ", "しらす", "えび", "海老", "いか", "たこ", "魚"],
        meat: ["鶏", "豚", "牛", "ひき肉", "ベーコン", "ハム", "ソーセージ", "肉"],
        egg: ["卵", "たまご", "玉子"],
        soy: ["豆腐", "納豆", "厚揚げ", "油揚げ", "高野豆腐", "大豆"],
      };
      const weeklyText = menu
        .map((item) => `${item.main_dish} ${item.side_dish} ${item.soup} ${item.used_ingredients.join(" ")}`)
        .join(" ");
      const usedProteinKinds = Object.entries(proteinCategories)
        .filter(([, words]) => containsAny(weeklyText, words))
        .map(([kind]) => kind);
      if (usedProteinKinds.length < 3) {
        throw new Error("たんぱく源のバリエーションが不足しています。");
      }

      const inputIngredients = parseIngredientList(inputIngredientsRaw);
      if (inputIngredients.length >= 4) {
        const textForCoverage = menu
          .map((item) => `${item.main_dish} ${item.side_dish} ${item.soup} ${item.used_ingredients.join(" ")}`)
          .join(" ");
        const covered = inputIngredients.filter((ing) => textForCoverage.includes(ing));
        const coverageRatio = covered.length / inputIngredients.length;
        if (coverageRatio < 0.45) {
          throw new Error("入力食材の反映率が低すぎます。");
        }
      }
    }

    function normalizeMenuResponse(data, inputIngredientsRaw) {
      const recommendedRaw = Array.isArray(data?.recommended_additional_ingredients)
        ? data.recommended_additional_ingredients
        : [];
      const recommended = recommendedRaw
        .map((item) => ({
          ingredient: String(item?.ingredient || "").trim(),
          reason: String(item?.reason || "").trim(),
        }))
        .filter((item) => item.ingredient);

      const menuRaw = Array.isArray(data?.menu) ? data.menu : [];
      const menu = menuRaw
        .map((item, index) => ({
          day: String(item?.day || `${index + 1}日目`).trim(),
          main_dish: String(item?.main_dish || "").trim(),
          side_dish: String(item?.side_dish || "").trim(),
          soup: String(item?.soup || "").trim(),
          used_ingredients: normalizeStringArray(item?.used_ingredients),
          recommended_ingredients_used: normalizeStringArray(item?.recommended_ingredients_used),
          nutrition_point: String(item?.nutrition_point || "").trim(),
        }))
        .slice(0, 7);

      if (menu.length !== 7) {
        throw new Error("献立が7日分生成されませんでした。");
      }
      if (menu.some((item) => !item.main_dish || !item.side_dish || !item.soup)) {
        throw new Error("献立データを生成できませんでした。");
      }
      validateMenuQuality(menu, inputIngredientsRaw);

      return {
        recommended_additional_ingredients: recommended,
        menu,
      };
    }

    function escapeHtml(value) {
      return String(value || "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    function buildRecipeSearchUrl(dishName) {
      const query = `${String(dishName || "").trim()} 作り方 レシピ`;
      return `https://www.google.com/search?q=${encodeURIComponent(query)}`;
    }

    function isContentGenerationError(error) {
      const message = String(error?.message || "");
      return (
        message.includes("Empty AI response") ||
        message.includes("AIから有効な応答が返ってきませんでした。") ||
        message.includes("AI応答がJSON形式ではありません。") ||
        message.includes("API応答の解析に失敗しました。") ||
        message.includes("献立が7日分生成されませんでした。") ||
        message.includes("主菜のバリエーションが不足しています。") ||
        message.includes("副菜のバリエーションが不足しています。") ||
        message.includes("汁物のバリエーションが不足しています。") ||
        message.includes("たんぱく源のバリエーションが不足しています。") ||
        message.includes("入力食材の反映率が低すぎます。")
      );
    }

    function getGoalInstruction(goalType) {
      if (goalType === "muscle") {
        return `【目的: 筋肉増量】
- 各日の主菜は高たんぱくを優先し、肉・魚・卵・大豆製品を積極的に使う。
- 夕食1回でたんぱく質をしっかり確保できる献立構成にする。
- トレーニング後を想定し、炭水化物も不足しないようにする。
- 極端な低脂質にはせず、回復に必要な脂質は適量確保する。`;
      }
      if (goalType === "diet") {
        return `【目的: ダイエット】
- 高たんぱく・適正糖質・低脂質を意識した献立にする。
- 揚げ物や高脂質な調理を避け、蒸す・茹でる・焼く調理を優先する。
- 野菜・きのこ・海藻を増やし、満足感と食物繊維を確保する。
- 味付けは濃くしすぎず、塩分や余分な油を抑える。`;
      }
      return `【目的: 通常】
- 栄養バランスと継続しやすさを重視する。`;
    }

    function getMemoTheme(goalType) {
      if (goalType === "muscle") {
        return {
          label: "筋肉メモ",
          icon: "dumbbell",
          wrapperClass: "bg-rose-50/60 border-t border-rose-100",
          iconClass: "w-4 h-4 text-rose-500 mt-0.5 flex-shrink-0",
          titleClass: "text-xs font-bold text-rose-700 mb-1",
          textClass: "text-sm text-rose-900 leading-relaxed",
        };
      }
      if (goalType === "diet") {
        return {
          label: "ダイエットメモ",
          icon: "salad",
          wrapperClass: "bg-sky-50/60 border-t border-sky-100",
          iconClass: "w-4 h-4 text-sky-500 mt-0.5 flex-shrink-0",
          titleClass: "text-xs font-bold text-sky-700 mb-1",
          textClass: "text-sm text-sky-900 leading-relaxed",
        };
      }
      return {
        label: "栄養メモ",
        icon: "leaf",
        wrapperClass: "bg-green-50/50 border-t border-green-100",
        iconClass: "w-4 h-4 text-green-500 mt-0.5 flex-shrink-0",
        titleClass: "text-xs font-bold text-green-700 mb-1",
        textClass: "text-sm text-green-900 leading-relaxed",
      };
    }

    async function generateMenu(goalType = "normal") {
      const ingredients = ingredientsInput.value.trim();
      if (!ingredients) {
        showError("食材を入力してください。");
        return;
      }
      if (!currentUser) {
        showError("先にGoogleでログインしてください。");
        return;
      }

      setLoading(true, goalType);
      const goalInstruction = getGoalInstruction(goalType);

      const systemPrompt = `あなたはプロの栄養士であり、献立作成の専門家です。
ユーザーが買い込んだ食材を使って、1週間（7日間）の夕食献立を提案してください。

${goalInstruction}

【条件】
1. 栄養バランス（主食、主菜、副菜、汁物）を考慮する。
2. 入力食材を無駄なく使い切る工夫をする。
3. 栄養不足が見込まれる場合は「おすすめ追加食材」を提案し、献立に組み込む。
4. 基本調味料と主食（白米・パン・パスタ等）は常備前提。
5. 必ずJSONオブジェクトのみを返す。コードブロックや説明文は禁止。
6. 各日の主菜・副菜・汁物は、できるだけ重複を避ける。
7. 1週間でたんぱく源（魚・肉・卵・大豆製品）が偏らないよう分散させる。
8. 入力食材をできるだけ多く使い、menu全体で最低でも半分以上の食材に触れる。
9. nutrition_pointは30〜120文字程度で簡潔に書く。
10. JSON項目以外の説明は出力しない。
11. JSONスキーマ:
{
  "recommended_additional_ingredients": [{"ingredient":"", "reason":""}],
  "menu": [{
    "day":"月曜日",
    "main_dish":"",
    "side_dish":"",
    "soup":"",
    "used_ingredients":[""],
    "recommended_ingredients_used":[""],
    "nutrition_point":""
  }]
}`;
      const userPrompt = `以下の食材で1週間分の夕食献立を作成してください。\n\n食材リスト:\n${ingredients}`;

      const fetchWithRetry = async (retries = 1, delay = 1200, strictJsonMode = false, model = GROQ_MODEL) => {
        try {
          const supportsStrictSchema = model === "openai/gpt-oss-120b" || model === "openai/gpt-oss-20b";
          const responseFormat = {
            type: "json_schema",
            json_schema: {
              name: "weekly_dinner_plan",
              strict: supportsStrictSchema,
              schema: MENU_RESPONSE_SCHEMA,
            },
          };
          const effectiveUserPrompt = strictJsonMode
            ? `${userPrompt}\n\n重要: 前回の応答に不備がありました。必ず7日分ちょうどのJSONオブジェクトのみを返してください。`
            : userPrompt;
          const token = await currentUser.getIdToken(true);
          const response = await fetch(GROQ_ENDPOINT, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${token}`,
            },
            body: JSON.stringify({
              model,
              temperature: GENERATION_TEMPERATURE,
              max_tokens: GENERATION_MAX_TOKENS,
              response_format: responseFormat,
              messages: [
                { role: "system", content: systemPrompt },
                { role: "user", content: effectiveUserPrompt },
              ],
            }),
          });

          const text = await response.text();
          if (!response.ok) {
            let message = `API error: ${response.status}`;
            try {
              const parsed = JSON.parse(text);
              message = parsed?.error || parsed?.message || message;
            } catch {}
            const error = new Error(String(message));
            if (response.status === 429) {
              error.rateLimited = true;
              const retryAfterHeader = Number(response.headers.get("retry-after") || "0");
              if (Number.isFinite(retryAfterHeader) && retryAfterHeader > 0) {
                error.retryAfterMs = Math.ceil(retryAfterHeader * 1000);
              }
            }
            throw error;
          }

          let parsedResponse;
          try {
            parsedResponse = JSON.parse(text);
          } catch {
            throw new Error("API応答の解析に失敗しました。");
          }
          const rawContent = extractAssistantContent(parsedResponse);
          if (!rawContent) {
            if (!strictJsonMode) {
              return fetchWithRetry(retries, delay, true, model);
            }
            throw new Error("AIから有効な応答が返ってきませんでした。");
          }
          const parsedJson = extractJsonObject(rawContent) || (
            parsedResponse && typeof parsedResponse === "object"
              ? extractJsonObject(JSON.stringify(parsedResponse))
              : null
          );
          if (!parsedJson) {
            throw new Error("AI応答がJSON形式ではありません。");
          }
          return normalizeMenuResponse(parsedJson, ingredients);
        } catch (err) {
          if (err?.rateLimited) throw err;
          if (retries > 0) {
            await new Promise((resolve) => setTimeout(resolve, delay));
            return fetchWithRetry(retries - 1, delay * 2, strictJsonMode, model);
          }
          throw err;
        }
      };

      try {
        let result;
        try {
          result = await fetchWithRetry();
        } catch (primaryError) {
          if (!isContentGenerationError(primaryError)) {
            throw primaryError;
          }
          // 主モデルで空応答が続く場合のみ、許可モデルへ1回フォールバック
          result = await fetchWithRetry(1, 1200, true, GROQ_FALLBACK_MODEL);
        }
        renderResults(result, goalType);
      } catch (err) {
        console.error(err);
        if (err?.rateLimited) {
          const retrySecFromMs = Number.isFinite(err?.retryAfterMs) ? Math.ceil(err.retryAfterMs / 1000) : 10;
          showError(`アクセスが集中しています。${retrySecFromMs}秒ほど待ってから、もう一度お試しください。`);
        } else {
          showError("献立の作成中にエラーが発生しました。時間を置いて再度お試しいただくか、食材の記述を変えてみてください。");
        }
      } finally {
        setLoading(false);
      }
    }

    function renderResults(data, goalType = "normal") {
      const memoTheme = getMemoTheme(goalType);
      if (data.recommended_additional_ingredients && data.recommended_additional_ingredients.length > 0) {
        recommendedList.innerHTML = data.recommended_additional_ingredients.map((item) => `
          <li class="flex items-start gap-2 text-sm text-blue-900 bg-white/60 p-2 rounded-lg">
            <i data-lucide="plus-circle" class="w-4 h-4 text-blue-500 mt-0.5 flex-shrink-0"></i>
            <div>
              <span class="font-bold text-blue-700">${escapeHtml(item.ingredient)}:</span> ${escapeHtml(item.reason)}
            </div>
          </li>
        `).join('');
        recommendedSection.classList.remove('hidden');
      } else {
        recommendedSection.classList.add('hidden');
      }

      menuGrid.innerHTML = data.menu.map((dayPlan) => {
        const usedIngredientsHtml = dayPlan.used_ingredients.map((ing) =>
          `<span class="px-2 py-1 bg-gray-100 text-gray-600 rounded-md text-xs">${escapeHtml(ing)}</span>`
        ).join('');
        const mainSearchUrl = buildRecipeSearchUrl(dayPlan.main_dish);
        const sideSearchUrl = buildRecipeSearchUrl(dayPlan.side_dish);
        const soupSearchUrl = buildRecipeSearchUrl(dayPlan.soup);

        let recommendedIngredientsHtml = '';
        if (dayPlan.recommended_ingredients_used && dayPlan.recommended_ingredients_used.length > 0) {
          recommendedIngredientsHtml = `
            <div>
              <span class="text-xs font-bold text-blue-500 block mb-1.5">追加おすすめ食材</span>
              <div class="flex flex-wrap gap-1.5">
                ${dayPlan.recommended_ingredients_used.map((ing) => `
                  <span class="px-2 py-1 bg-blue-50 border border-blue-200 text-blue-700 rounded-md text-xs font-medium flex items-center gap-1">
                    <i data-lucide="plus-circle" class="w-3 h-3"></i>
                    ${escapeHtml(ing)}
                  </span>
                `).join('')}
              </div>
            </div>
          `;
        }

        return `
          <div class="bg-white rounded-2xl shadow-sm border border-gray-100 overflow-hidden hover:shadow-md transition-shadow flex flex-col">
            <div class="bg-orange-100/50 px-5 py-3 border-b border-orange-100">
              <span class="font-bold text-orange-800 text-lg">${escapeHtml(dayPlan.day)}</span>
            </div>

            <div class="p-5 flex-grow space-y-4">
              <div>
                <span class="text-xs font-bold text-gray-400 uppercase tracking-wider block mb-1">主菜 (Main)</span>
                <p class="font-semibold text-gray-800 text-lg leading-tight">${escapeHtml(dayPlan.main_dish)}</p>
                <a href="${mainSearchUrl}" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1 mt-1 text-xs text-orange-600 hover:text-orange-700 underline underline-offset-2">
                  <i data-lucide="search" class="w-3 h-3"></i> 作り方を検索
                </a>
              </div>

              <div class="grid grid-cols-2 gap-3">
                <div>
                  <span class="text-xs font-bold text-gray-400 uppercase tracking-wider block mb-1">副菜 (Side)</span>
                  <p class="text-gray-700 text-sm">${escapeHtml(dayPlan.side_dish)}</p>
                  <a href="${sideSearchUrl}" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1 mt-1 text-xs text-orange-600 hover:text-orange-700 underline underline-offset-2">
                    <i data-lucide="search" class="w-3 h-3"></i> 作り方を検索
                  </a>
                </div>
                <div>
                  <span class="text-xs font-bold text-gray-400 uppercase tracking-wider block mb-1">汁物 (Soup)</span>
                  <p class="text-gray-700 text-sm">${escapeHtml(dayPlan.soup)}</p>
                  <a href="${soupSearchUrl}" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1 mt-1 text-xs text-orange-600 hover:text-orange-700 underline underline-offset-2">
                    <i data-lucide="search" class="w-3 h-3"></i> 作り方を検索
                  </a>
                </div>
              </div>

              <hr class="border-gray-100" />

              <div class="space-y-3">
                <div>
                  <span class="text-xs font-bold text-gray-400 block mb-1.5">入力食材</span>
                  <div class="flex flex-wrap gap-1.5">
                    ${usedIngredientsHtml}
                  </div>
                </div>
                ${recommendedIngredientsHtml}
              </div>
            </div>

            <div class="${memoTheme.wrapperClass} p-4 mt-auto">
              <div class="flex items-start gap-2">
                <i data-lucide="${memoTheme.icon}" class="${memoTheme.iconClass}"></i>
                <div>
                  <p class="${memoTheme.titleClass}">${memoTheme.label}</p>
                  <p class="${memoTheme.textClass}">${escapeHtml(dayPlan.nutrition_point)}</p>
                </div>
              </div>
            </div>
          </div>
        `;
      }).join('');

      lucide.createIcons();
      resultsSection.classList.remove('hidden');
    }

    initializeAuthState();
  </script>
</body>
</html>
