<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mental Partner v12 (Emotion Score)</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='16' fill='%23ec4899'/%3E%3Cpath d='M32 54 C30 52 12 38 12 24 C12 16 18 10 26 10 C29.8 10 33 11.8 35 15 C37 11.8 40.2 10 44 10 C52 10 58 16 58 24 C58 38 40 52 38 54 C36.3 55.8 33.7 55.8 32 54 Z' fill='white'/%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.5/dist/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Helvetica Neue', Arial, sans-serif; background-color: #f8fafc; }
        .chat-bubble { max-width: 85%; line-height: 1.6; }
        .markdown-body p { margin-bottom: 0.5em; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fadeIn 0.4s ease-out forwards; }
        .icon-btn { transition: all 0.2s; }
        .icon-btn:active { transform: scale(0.9); }
        .icon-selected { transform: scale(1.2); }
        
        /* Tool Cards */
        .tool-card {
            position: relative; overflow: hidden; border-radius: 16px; padding: 16px;
            color: white; transition: transform 0.2s, box-shadow 0.2s; cursor: pointer;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); height: 80px; display: flex; align-items: center;
        }
        .tool-card:active { transform: scale(0.98); }
        .tool-bg-icon {
            position: absolute; right: -10px; bottom: -10px; font-size: 3.5rem; opacity: 0.15; transform: rotate(-10deg);
        }
        .tool-mascot {
            position: absolute; right: 10px; bottom: 8px; width: 36px; height: 36px;
            background: rgba(255,255,255,0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center;
            color: #333; font-size: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Analysis Tabs */
        .analysis-tab { border-bottom: 2px solid transparent; color: #94a3b8; font-weight: bold; font-size: 0.9rem; padding-bottom: 0.5rem; flex: 1; text-align: center; transition: all 0.3s; }
        .analysis-tab.active { border-bottom-color: #0d9488; color: #0f766e; }

        .nav-btn { color: #9ca3af; }
        .nav-btn.tab-active { color: #0d9488; }

        /* Emotion Slider Customization */
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%; background: #ffffff; cursor: pointer; margin-top: -8px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); border: 2px solid currentColor;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #e2e8f0; border-radius: 2px;
        }
        
        /* SVG Ring Progress */
        .ring-container { position: relative; width: 60px; height: 60px; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .ring-svg { transform: rotate(-90deg); width: 100%; height: 100%; }
        .ring-circle-bg { fill: none; stroke: #334155; stroke-width: 4; opacity: 0.3; }
        .ring-circle-fg { fill: none; stroke-width: 4; stroke-linecap: round; transition: stroke-dashoffset 0.5s ease; }
        .ring-text { position: absolute; text-align: center; color: white; line-height: 1; }
        .ring-score { font-size: 14px; font-weight: bold; }
        .ring-label { font-size: 9px; opacity: 0.9; margin-bottom: 2px; }

        .selfcare-card { display: flex; align-items: center; justify-content: space-between; width: 100%; background: #ffffff; border: 1px solid #f1f5f9; border-radius: 16px; padding: 12px 14px; box-shadow: 0 1px 2px rgba(15, 23, 42, 0.05); transition: all 0.2s; text-align: left; }
        .selfcare-card:hover { border-color: #99f6e4; transform: translateY(-1px); }
    </style>
</head>
<body class="h-screen flex flex-col items-center justify-center text-gray-800 bg-slate-50">

    <!-- ログイン画面 -->
    <div id="login-screen" class="absolute inset-0 z-50 bg-white flex flex-col items-center justify-center p-6 overflow-y-auto">
        <div class="w-20 h-20 bg-pink-100 rounded-full flex items-center justify-center text-pink-500 text-4xl mb-6 flex-shrink-0">
            <i class="fa-solid fa-heart"></i>
        </div>
        <h1 class="text-2xl font-bold text-gray-800 mb-2">Mental Partner</h1>
        <p class="text-gray-500 mb-8 text-sm text-center">感情の機微を記録して、<br>AIと一緒にこころを整える。</p>
        
        <div class="flex flex-col gap-3 w-full max-w-xs">
            <button id="google-login-btn" class="bg-white border border-gray-300 text-gray-700 font-bold py-3 px-6 rounded-xl shadow-sm hover:bg-gray-50 transition flex items-center justify-center gap-3 w-full">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" class="w-5 h-5">
                <span>Googleでログイン</span>
            </button>
        </div>
        <div id="login-error-container" class="mt-6 w-full max-w-sm hidden">
            <div class="bg-red-50 border border-red-200 rounded-lg p-4 text-xs text-red-700 break-all">
                <p class="font-bold mb-2"><i class="fa-solid fa-circle-exclamation"></i> ログインエラー</p>
                <p id="login-error-msg" class="mb-2">エラーが発生しました。</p>
            </div>
        </div>
    </div>

    <!-- アプリ本体 -->
    <div id="app-container" class="hidden w-full h-full md:max-w-md md:h-[95vh] md:rounded-3xl md:shadow-2xl flex flex-col bg-white overflow-hidden relative border border-gray-200">
        
        <!-- ヘッダー -->
        <header class="bg-white/95 backdrop-blur-sm border-b border-gray-100 p-4 flex justify-between items-center z-20 absolute top-0 w-full h-14 shadow-sm">
            <h1 class="font-bold text-gray-800 flex items-center gap-2 text-lg">
                <i class="fa-solid fa-heart text-pink-500"></i> Mental Partner
            </h1>
            <div class="flex gap-3">
                <button id="settings-btn" class="text-gray-400 hover:text-teal-600 transition text-xs flex items-center gap-1">
                    <i class="fa-solid fa-gear"></i> <span>設定</span>
                </button>
            </div>
        </header>

        <!-- メインコンテンツ -->
        <main class="flex-1 overflow-hidden relative pt-14 pb-16 bg-slate-50">
            
            <!-- 1. チャット -->
            <div id="view-chat" class="view-section w-full h-full flex flex-col absolute inset-0 transition-opacity duration-300 pt-14 pb-16">
                <div class="px-4 pt-3 flex justify-end">
                    <button id="summarize-btn" class="text-[10px] font-bold text-teal-700 bg-teal-50 border border-teal-100 px-3 py-1 rounded-full hover:bg-teal-100 transition">
                        会話を要約
                    </button>
                </div>
                <div id="chat-summary-wrap" class="hidden px-4 pt-2">
                    <details class="bg-teal-50 border border-teal-100 rounded-xl p-3 text-xs text-gray-700">
                        <summary class="cursor-pointer font-bold text-teal-700">これまでのあらすじ</summary>
                        <div id="chat-summary-text" class="mt-2 whitespace-pre-wrap"></div>
                    </details>
                </div>
                <div id="chat-container" class="flex-1 overflow-y-auto p-4 space-y-4 scroll-smooth"></div>
                <div class="p-3 bg-white border-t border-gray-100">
                    <form id="chat-form" class="flex gap-2 items-end">
                        <textarea id="user-input" rows="2" class="flex-1 bg-gray-100 border-0 rounded-2xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-teal-500 text-sm resize-none leading-relaxed" placeholder="話しかける..." autocomplete="off"></textarea>
                        <button type="submit" id="send-btn" class="bg-teal-600 text-white rounded-full w-10 h-10 flex items-center justify-center hover:bg-teal-700 shadow-md transition transform active:scale-95">
                            <i class="fa-solid fa-paper-plane text-xs"></i>
                        </button>
                    </form>
                </div>
            </div>

            <!-- 2. 記録 -->
            <div id="view-work" class="view-section w-full h-full absolute inset-0 opacity-0 pointer-events-none transition-opacity duration-300 overflow-y-auto pt-14 pb-20 p-4 bg-slate-50">
                <div class="mb-4 bg-white rounded-xl p-1 border border-gray-100 shadow-sm flex">
                    <button class="work-tab-btn flex-1 py-2 text-xs font-bold rounded-lg bg-teal-600 text-white" data-work-tab="write">記録する</button>
                    <button class="work-tab-btn flex-1 py-2 text-xs font-bold rounded-lg text-gray-500" data-work-tab="read">よむ</button>
                </div>

                <div id="work-pane-write">
                
                <div id="daily-message-area" class="bg-white p-4 rounded-xl shadow-sm mb-6 border border-teal-100 relative hidden animate-fade-in mx-1">
                    <div class="text-xs text-gray-400 mb-1 flex items-center gap-1">
                        <i class="fa-solid fa-robot"></i> AIからのフィードバック
                    </div>
                    <p id="daily-message-text" class="text-sm text-gray-700 leading-relaxed"></p>
                    <button onclick="document.getElementById('daily-message-area').classList.add('hidden')" class="absolute top-2 right-3 text-gray-300 hover:text-gray-500"><i class="fa-solid fa-times"></i></button>
                </div>

                <!-- A. ツール選択メニュー -->
                <div id="tool-menu-container" class="animate-fade-in space-y-6 pb-10">
                    <div class="flex justify-between items-center px-1">
                        <h2 class="text-lg font-bold text-gray-800">ノートを追加</h2>
                        <span class="text-xs text-gray-400" id="current-date"></span>
                    </div>

                    <!-- 認知行動療法シリーズ -->
                    <div>
                        <div class="flex items-center gap-2 mb-3 ml-1">
                            <span class="w-1 h-4 bg-teal-400 rounded-full"></span>
                            <h3 class="text-xs font-bold text-gray-500">問題を整理し解決策を考える</h3>
                        </div>
                        <div class="grid grid-cols-1 gap-3">
                            <div class="tool-card bg-gradient-to-r from-teal-400 to-emerald-400" onclick="switchTool('cbt-3')">
                                <div><h4 class="font-bold text-sm">3コラム法</h4></div>
                                <i class="fa-solid fa-columns tool-bg-icon"></i>
                                <div class="tool-mascot"><i class="fa-solid fa-3"></i></div>
                            </div>
                            <div class="tool-card bg-gradient-to-r from-teal-500 to-emerald-500" onclick="switchTool('cbt-5')">
                                <div><h4 class="font-bold text-sm">5コラム法</h4></div>
                                <i class="fa-solid fa-table-columns tool-bg-icon"></i>
                                <div class="tool-mascot"><i class="fa-solid fa-5"></i></div>
                            </div>
                            <div class="tool-card bg-gradient-to-r from-teal-600 to-emerald-600" onclick="switchTool('cbt-7')">
                                <div><h4 class="font-bold text-sm">7コラム法</h4></div>
                                <i class="fa-solid fa-table-cells-large tool-bg-icon"></i>
                                <div class="tool-mascot"><i class="fa-solid fa-7"></i></div>
                            </div>
                        </div>
                    </div>

                    <!-- 日記・振り返り -->
                    <div>
                        <div class="flex items-center gap-2 mb-3 ml-1">
                            <span class="w-1 h-4 bg-blue-400 rounded-full"></span>
                            <h3 class="text-xs font-bold text-gray-500">三行で1日をふり返る</h3>
                        </div>
                        <div class="grid grid-cols-1 gap-3">
                            <div class="tool-card bg-gradient-to-r from-sky-400 to-blue-400" onclick="switchTool('gratitude')">
                                <div>
                                    <h4 class="font-bold text-sm">感謝日記</h4>
                                    <p class="text-[10px] opacity-90 mt-0.5">今日感謝したい出来事を3つ振り返る</p>
                                </div>
                                <i class="fa-solid fa-star tool-bg-icon"></i>
                                <div class="tool-mascot"><i class="fa-solid fa-gift"></i></div>
                            </div>
                            <div class="tool-card bg-gradient-to-r from-indigo-400 to-purple-400" onclick="switchTool('free')">
                                <div>
                                    <h4 class="font-bold text-sm">自由記述・モヤモヤ整理</h4>
                                    <p class="text-[10px] opacity-90 mt-0.5">気持ちを吐き出す</p>
                                </div>
                                <i class="fa-solid fa-pen-nib tool-bg-icon"></i>
                                <div class="tool-mascot"><i class="fa-solid fa-feather"></i></div>
                            </div>
                        </div>
                    </div>

                    <!-- ストレス対処 -->
                    <div>
                        <div class="flex items-center gap-2 mb-3 ml-1">
                            <span class="w-1 h-4 bg-violet-400 rounded-full"></span>
                            <h3 class="text-xs font-bold text-gray-500">今のストレスを整えて対処する</h3>
                        </div>
                        <div class="grid grid-cols-1 gap-3">
                            <div class="tool-card bg-gradient-to-r from-violet-500 to-fuchsia-500" onclick="switchTool('cog-organize')">
                                <div>
                                    <h4 class="font-bold text-sm">認知行動整理</h4>
                                    <p class="text-[10px] opacity-90 mt-0.5">状況を客観視して整理する</p>
                                </div>
                                <i class="fa-solid fa-brain tool-bg-icon"></i>
                                <div class="tool-mascot"><i class="fa-solid fa-magnifying-glass"></i></div>
                            </div>
                            <div class="tool-card bg-gradient-to-r from-cyan-500 to-blue-500" onclick="switchTool('problem-solving')">
                                <div>
                                    <h4 class="font-bold text-sm">問題解決</h4>
                                    <p class="text-[10px] opacity-90 mt-0.5">問題を分解して対処法を決める</p>
                                </div>
                                <i class="fa-solid fa-screwdriver-wrench tool-bg-icon"></i>
                                <div class="tool-mascot"><i class="fa-solid fa-list-check"></i></div>
                            </div>
                            <div class="tool-card bg-gradient-to-r from-rose-500 to-orange-500" onclick="switchTool('quit-behavior')">
                                <div>
                                    <h4 class="font-bold text-sm">辞めたい行動</h4>
                                    <p class="text-[10px] opacity-90 mt-0.5">きっかけと本当の欲求を見つける</p>
                                </div>
                                <i class="fa-solid fa-road-circle-xmark tool-bg-icon"></i>
                                <div class="tool-mascot"><i class="fa-solid fa-seedling"></i></div>
                            </div>
                        </div>
                    </div>

                    <!-- 対人コミュニケーション -->
                    <div>
                        <div class="flex items-center gap-2 mb-3 ml-1">
                            <span class="w-1 h-4 bg-pink-400 rounded-full"></span>
                            <h3 class="text-xs font-bold text-gray-500">相手を傷つけず、自分にも正直に伝える</h3>
                        </div>
                        <div class="grid grid-cols-1 gap-3">
                            <div class="tool-card bg-gradient-to-r from-pink-500 to-rose-500" onclick="switchTool('assertion')">
                                <div>
                                    <h4 class="font-bold text-sm">アサーション</h4>
                                    <p class="text-[10px] opacity-90 mt-0.5">率直・対等・誠実に伝える練習</p>
                                </div>
                                <i class="fa-solid fa-comment-dots tool-bg-icon"></i>
                                <div class="tool-mascot"><i class="fa-solid fa-scale-balanced"></i></div>
                            </div>
                            <div class="tool-card bg-gradient-to-r from-fuchsia-500 to-purple-500" onclick="switchTool('desc')">
                                <div>
                                    <h4 class="font-bold text-sm">DESC法</h4>
                                    <p class="text-[10px] opacity-90 mt-0.5">D/E/S/Cで具体的に伝える</p>
                                </div>
                                <i class="fa-solid fa-list-ol tool-bg-icon"></i>
                                <div class="tool-mascot"><i class="fa-solid fa-comments"></i></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- B. 入力フォーム -->
                <div id="tool-form-container" class="hidden h-full flex flex-col">
                    <button onclick="showToolMenu()" class="mb-4 text-xs font-bold text-gray-500 hover:text-teal-600 flex items-center gap-1 self-start">
                        <i class="fa-solid fa-chevron-left"></i> 戻る
                    </button>

                    <div class="bg-white p-6 rounded-3xl shadow-sm mb-6 border border-gray-100 flex-1">
                        
                        <!-- コンディション -->
                        <div class="mb-6 pb-6 border-b border-gray-100">
                             <div class="grid grid-cols-2 gap-4">
                                <div class="text-center">
                                    <label class="block text-xs font-bold text-teal-600 mb-2">ココロ</label>
                                    <div class="flex justify-between px-1">
                                        <button class="icon-btn text-2xl text-gray-300 hover:text-indigo-400" onclick="setMental(1, this)"><i class="fa-solid fa-face-sad-tear"></i></button>
                                        <button class="icon-btn text-2xl text-gray-300 hover:text-blue-400" onclick="setMental(2, this)"><i class="fa-solid fa-face-frown"></i></button>
                                        <button class="icon-btn text-2xl text-gray-300 hover:text-gray-400" onclick="setMental(3, this)"><i class="fa-solid fa-face-meh"></i></button>
                                        <button class="icon-btn text-2xl text-gray-300 hover:text-teal-400" onclick="setMental(4, this)"><i class="fa-solid fa-face-smile"></i></button>
                                        <button class="icon-btn text-2xl text-gray-300 hover:text-yellow-400" onclick="setMental(5, this)"><i class="fa-solid fa-face-laugh-beam"></i></button>
                                    </div>
                                    <input type="hidden" id="mental-val" value="3">
                                </div>
                                <div class="text-center">
                                    <label class="block text-xs font-bold text-teal-600 mb-2">カラダ</label>
                                    <div id="physical-hearts" class="flex justify-center gap-2">
                                        <button class="icon-btn text-2xl text-gray-200 hover:text-pink-400" onclick="setPhysical(1)"><i class="fa-solid fa-heart"></i></button>
                                        <button class="icon-btn text-2xl text-gray-200 hover:text-pink-400" onclick="setPhysical(2)"><i class="fa-solid fa-heart"></i></button>
                                        <button class="icon-btn text-2xl text-gray-200 hover:text-pink-400" onclick="setPhysical(3)"><i class="fa-solid fa-heart"></i></button>
                                        <button class="icon-btn text-2xl text-gray-200 hover:text-pink-400" onclick="setPhysical(4)"><i class="fa-solid fa-heart"></i></button>
                                        <button class="icon-btn text-2xl text-gray-200 hover:text-pink-400" onclick="setPhysical(5)"><i class="fa-solid fa-heart"></i></button>
                                    </div>
                                    <input type="hidden" id="physical-val" value="3">
                                </div>
                            </div>
                        </div>

                        <input type="hidden" id="current-tool-type" value="cbt-3">

                        <!-- フォームコンテンツ -->
                        <div id="form-content" class="space-y-6">
                            <h3 id="form-title" class="text-sm font-bold text-teal-600 border-b pb-2">記録</h3>
                            
                            <!-- 感情スコア入力 -->
                            <div class="mb-4">
                                <div class="flex justify-between items-center mb-2">
                                    <label class="block text-xs font-bold text-gray-500">感情の種類と強さ (0-100)</label>
                                    <button onclick="toggleEmotionSelector()" class="text-xs text-teal-600 font-bold bg-teal-50 px-2 py-1 rounded hover:bg-teal-100"><i class="fa-solid fa-plus"></i> 追加</button>
                                </div>
                                <div id="active-emotions-container" class="space-y-3">
                                    <!-- JSでスライダーを追加 -->
                                </div>
                                <div id="emotion-selector" class="hidden mt-3 p-3 bg-slate-50 rounded-xl border border-slate-100 grid grid-cols-2 gap-2">
                                    <!-- 感情リスト (JS生成) -->
                                </div>
                            </div>

                            <!-- テキストフィールド (JSで切り替え) -->
                            <div class="field-group space-y-4" data-fields="cbt-common">
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">状況・出来事</label>
                                    <input type="text" id="cbt-situation" class="w-full bg-gray-50 border border-gray-200 rounded-lg p-3 text-sm focus:outline-none focus:border-teal-500" placeholder="例：上司に注意された">
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">頭に浮かんだこと (自動思考)</label>
                                    <textarea id="cbt-thought" class="w-full bg-gray-50 border border-gray-200 rounded-lg p-3 text-sm focus:outline-none focus:border-teal-500 resize-none h-20" placeholder="例：自分はダメな人間だ"></textarea>
                                </div>
                            </div>

                            <div class="field-group hidden" data-fields="cbt-advanced">
                                <label class="block text-xs font-bold text-gray-500 mb-1">別の考え方 (適応的思考)</label>
                                <textarea id="cbt-adaptive" class="w-full bg-gray-50 border border-gray-200 rounded-lg p-3 text-sm focus:outline-none focus:border-teal-500 resize-none h-20" placeholder="例：誰でもミスはする、次は気をつけよう"></textarea>
                            </div>

                            <div class="field-group hidden space-y-3" data-fields="cbt-7">
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">その時の気分・感情</label>
                                    <input type="text" id="cbt7-emotion" class="w-full bg-gray-50 border border-gray-200 rounded-lg p-3 text-sm" placeholder="例：不安80%、焦り60%">
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">自動思考を裏づける根拠</label>
                                    <textarea id="cbt7-evidence-for" class="w-full bg-gray-50 border border-gray-200 rounded-lg p-3 text-sm resize-none h-20" placeholder="例：期限に遅れた"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">自動思考への反証</label>
                                    <textarea id="cbt7-evidence-against" class="w-full bg-gray-50 border border-gray-200 rounded-lg p-3 text-sm resize-none h-20" placeholder="例：これまでは多くの業務を完了できている"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">次に取る小さな行動</label>
                                    <textarea id="cbt7-action" class="w-full bg-gray-50 border border-gray-200 rounded-lg p-3 text-sm resize-none h-20" placeholder="例：明日の朝、優先順位を3つに絞る"></textarea>
                                </div>
                            </div>

                            <div class="field-group hidden space-y-3" data-fields="gratitude">
                                <div class="space-y-3">
                                    <textarea id="gratitude-1" class="w-full bg-blue-50 border border-blue-100 rounded-lg p-3 text-sm resize-none h-16" placeholder="1. 感謝したい出来事"></textarea>
                                    <textarea id="gratitude-2" class="w-full bg-blue-50 border border-blue-100 rounded-lg p-3 text-sm resize-none h-16" placeholder="2. 感謝したい出来事"></textarea>
                                    <textarea id="gratitude-3" class="w-full bg-blue-50 border border-blue-100 rounded-lg p-3 text-sm resize-none h-16" placeholder="3. 感謝したい出来事"></textarea>
                                </div>
                            </div>

                            <div class="field-group hidden space-y-3" data-fields="cog-organize">
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">ストレス状況 (事実ベース)</label>
                                    <textarea id="cog-situation" class="w-full bg-violet-50 border border-violet-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="今起きていることを具体的に"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">浮かんだ解釈・考え</label>
                                    <textarea id="cog-thought" class="w-full bg-violet-50 border border-violet-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="例：自分は失敗するかもしれない"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">客観的に見た別の捉え方</label>
                                    <textarea id="cog-reframe" class="w-full bg-violet-50 border border-violet-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="第三者視点での見方"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">自分でコントロールできること</label>
                                    <textarea id="cog-control" class="w-full bg-violet-50 border border-violet-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="今の自分ができる範囲"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">次の一歩</label>
                                    <input type="text" id="cog-next" class="w-full bg-violet-50 border border-violet-100 rounded-lg p-3 text-sm" placeholder="今日中にやる小さな行動">
                                </div>
                            </div>

                            <div class="field-group hidden space-y-3" data-fields="problem-solving">
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">今の問題</label>
                                    <textarea id="ps-problem" class="w-full bg-cyan-50 border border-cyan-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="解決したい問題を具体化"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">目標 (どうなればOKか)</label>
                                    <input type="text" id="ps-goal" class="w-full bg-cyan-50 border border-cyan-100 rounded-lg p-3 text-sm" placeholder="達成したい状態">
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">解決案の候補</label>
                                    <textarea id="ps-options" class="w-full bg-cyan-50 border border-cyan-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="思いつく案を複数"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">採用する案</label>
                                    <input type="text" id="ps-best" class="w-full bg-cyan-50 border border-cyan-100 rounded-lg p-3 text-sm" placeholder="今選ぶ案">
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">最初の行動</label>
                                    <input type="text" id="ps-first-step" class="w-full bg-cyan-50 border border-cyan-100 rounded-lg p-3 text-sm" placeholder="最小の1ステップ">
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">障害への備え</label>
                                    <textarea id="ps-obstacle" class="w-full bg-cyan-50 border border-cyan-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="詰まった時の代替案"></textarea>
                                </div>
                            </div>

                            <div class="field-group hidden space-y-3" data-fields="quit-behavior">
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">辞めたい行動</label>
                                    <input type="text" id="quit-behavior-name" class="w-full bg-rose-50 border border-rose-100 rounded-lg p-3 text-sm" placeholder="例：夜更かし、衝動買い">
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">起きるきっかけ</label>
                                    <textarea id="quit-trigger" class="w-full bg-rose-50 border border-rose-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="いつ・どこで・何があると起きるか"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">その時すぐ満たされるもの</label>
                                    <textarea id="quit-short-reward" class="w-full bg-rose-50 border border-rose-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="例：安心感、気晴らし"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">本当に満たしたいもの</label>
                                    <textarea id="quit-true-need" class="w-full bg-rose-50 border border-rose-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="例：休息、つながり、自信"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">代わりの行動</label>
                                    <textarea id="quit-alternative" class="w-full bg-rose-50 border border-rose-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="辞めたい行動の代替"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">実行プラン (If-Then)</label>
                                    <input type="text" id="quit-plan" class="w-full bg-rose-50 border border-rose-100 rounded-lg p-3 text-sm" placeholder="例：もし帰宅後に不安が強ければ、10分散歩する">
                                </div>
                            </div>

                            <div class="field-group hidden space-y-3" data-fields="assertion">
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">状況の事実 (評価を入れずに)</label>
                                    <textarea id="assertion-fact" class="w-full bg-pink-50 border border-pink-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="例：締切前日に仕様変更の連絡がありました"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">その時の気持ち</label>
                                    <input type="text" id="assertion-feeling" class="w-full bg-pink-50 border border-pink-100 rounded-lg p-3 text-sm" placeholder="例：焦りと不安を感じました">
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">大切にしたいこと・ニーズ</label>
                                    <input type="text" id="assertion-need" class="w-full bg-pink-50 border border-pink-100 rounded-lg p-3 text-sm" placeholder="例：準備時間と見通しが必要です">
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">具体的なお願い</label>
                                    <textarea id="assertion-request" class="w-full bg-pink-50 border border-pink-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="例：変更がある場合は2日前までに共有してください"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">相手への配慮</label>
                                    <input type="text" id="assertion-consideration" class="w-full bg-pink-50 border border-pink-100 rounded-lg p-3 text-sm" placeholder="例：急ぎの事情があることは理解しています">
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">伝え方の練習文 (Iメッセージ)</label>
                                    <textarea id="assertion-script" class="w-full bg-pink-50 border border-pink-100 rounded-lg p-3 text-sm resize-none h-24" placeholder="例：私は〇〇だと△△と感じます。なので□□してもらえると助かります。"></textarea>
                                </div>
                            </div>

                            <div class="field-group hidden space-y-3" data-fields="desc">
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">D: Describe (事実)</label>
                                    <textarea id="desc-describe" class="w-full bg-fuchsia-50 border border-fuchsia-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="客観的に見える行動・出来事"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">E: Express (気持ち)</label>
                                    <textarea id="desc-express" class="w-full bg-fuchsia-50 border border-fuchsia-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="その時の気持ち・困りごと"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">S: Specify (提案・依頼)</label>
                                    <textarea id="desc-specify" class="w-full bg-fuchsia-50 border border-fuchsia-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="相手にしてほしい具体的行動"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">C: Consequence (結果)</label>
                                    <textarea id="desc-consequence" class="w-full bg-fuchsia-50 border border-fuchsia-100 rounded-lg p-3 text-sm resize-none h-20" placeholder="実現するとどう良くなるか"></textarea>
                                </div>
                                <div>
                                    <label class="block text-xs font-bold text-gray-500 mb-1">最終メッセージ草案</label>
                                    <textarea id="desc-script" class="w-full bg-fuchsia-50 border border-fuchsia-100 rounded-lg p-3 text-sm resize-none h-24" placeholder="D→E→S→Cの順に1つの文章へ"></textarea>
                                </div>
                            </div>

                            <div class="field-group hidden" data-fields="free">
                                <label class="block text-xs font-bold text-gray-500 mb-1">自由記述</label>
                                <textarea id="free-note" class="w-full bg-indigo-50 border border-indigo-100 rounded-lg p-3 text-sm resize-none h-28" placeholder="今の気持ちや出来事を自由に書く"></textarea>
                            </div>
                        </div>

                        <button id="save-entry-btn" class="w-full mt-6 bg-gray-800 text-white py-4 rounded-2xl text-sm font-bold shadow-lg hover:opacity-90 transition transform active:scale-95 flex items-center justify-center gap-2">
                            <i class="fa-solid fa-check"></i> 記録する
                        </button>
                    </div>
                </div>

                </div>

                <div id="work-pane-read" class="hidden">
                    <div class="flex justify-between items-center px-1 mb-3">
                        <h2 class="text-lg font-bold text-gray-800">記録の履歴</h2>
                        <button id="refresh-history-btn" class="text-[10px] font-bold text-teal-700 bg-teal-50 border border-teal-100 px-3 py-1 rounded-full hover:bg-teal-100 transition">
                            更新
                        </button>
                    </div>
                    <div id="entries-history-list" class="space-y-3 pb-8"></div>
                </div>
            </div>

            <!-- 3. 分析 -->
            <div id="view-analysis" class="view-section w-full h-full flex flex-col absolute inset-0 opacity-0 pointer-events-none transition-opacity duration-300 overflow-y-auto pt-14 pb-24 bg-white">
                
                <div class="sticky top-0 bg-white z-10 px-6 pt-4 border-b border-gray-100 flex">
                    <button class="analysis-tab active" data-tab="daily" onclick="switchAnalysisTab('daily')">日々の変化</button>
                    <button class="analysis-tab" data-tab="ai" onclick="switchAnalysisTab('ai')">AIじぶん分析</button>
                </div>

                <div id="analysis-daily" class="p-6 space-y-8">
                    <!-- コンディション (Area Chart) -->
                    <div>
                        <h3 class="text-lg font-bold text-gray-800 mb-4">コンディションの変化</h3>
                        <div class="bg-white rounded-none">
                            <div class="h-[200px] w-full relative">
                                <canvas id="conditionChart"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- 感情の構成 (Donut) -->
                    <div>
                        <h3 class="text-lg font-bold text-gray-800 mb-4">感情の構成</h3>
                        <div class="bg-white rounded-2xl p-4 shadow-sm border border-gray-50 flex flex-col items-center">
                            <div class="h-[200px] w-[200px] relative mb-6">
                                <canvas id="emotionDoughnutChart"></canvas>
                            </div>
                            <!-- スコアカード -->
                            <div class="grid grid-cols-4 gap-2 w-full">
                                <div class="text-center p-2 rounded-lg bg-red-50 border border-red-100">
                                    <div class="text-[10px] text-red-500 font-bold mb-1">怒り</div>
                                    <div class="text-xl font-bold text-gray-800" id="score-anger">0</div>
                                </div>
                                <div class="text-center p-2 rounded-lg bg-purple-50 border border-purple-100">
                                    <div class="text-[10px] text-purple-500 font-bold mb-1">不安</div>
                                    <div class="text-xl font-bold text-gray-800" id="score-anxiety">0</div>
                                </div>
                                <div class="text-center p-2 rounded-lg bg-blue-50 border border-blue-100">
                                    <div class="text-[10px] text-blue-500 font-bold mb-1">悲しみ</div>
                                    <div class="text-xl font-bold text-gray-800" id="score-sadness">0</div>
                                </div>
                                <div class="text-center p-2 rounded-lg bg-green-50 border border-green-100">
                                    <div class="text-[10px] text-green-600 font-bold mb-1">嫌悪</div>
                                    <div class="text-xl font-bold text-gray-800" id="score-disgust">0</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="analysis-ai" class="hidden p-6 pb-10">
                    <div class="flex justify-end mb-4">
                        <button id="analyze-btn" class="bg-gradient-to-r from-teal-500 to-teal-600 text-white px-4 py-2 rounded-full text-xs font-bold shadow-md hover:shadow-lg transition flex items-center justify-center gap-2">
                            <i class="fa-solid fa-wand-magic-sparkles"></i> AI分析を実行
                        </button>
                    </div>
                    <div class="relative mb-8">
                        <div class="bg-teal-50 p-5 rounded-2xl text-sm text-gray-700 shadow-sm border border-teal-100 relative z-0">
                            <h4 class="text-teal-700 font-bold text-sm mb-2 flex items-center gap-2">
                                <i class="fa-solid fa-robot"></i> 今週の傾向とアドバイス
                            </h4>
                            <div id="wave-analysis-text" class="leading-relaxed">まだ分析データがありません。</div>
                        </div>
                    </div>
                    <h2 class="text-lg font-bold text-gray-800 mb-4">思考のクセ</h2>
                    <div class="bg-white rounded-xl border border-gray-100 p-4 shadow-sm mb-6">
                        <div class="h-[250px] w-full relative"><canvas id="patternChart"></canvas></div>
                    </div>
                </div>
            </div>

            <!-- 4. メモリ -->
            <div id="view-memory" class="view-section w-full h-full flex flex-col absolute inset-0 opacity-0 pointer-events-none transition-opacity duration-300 overflow-y-auto pt-14 pb-24 bg-white">
                <div class="px-6 py-6 border-b border-gray-100">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-lg font-bold text-gray-800">AIメモリ</h2>
                        <button id="memory-refresh-btn" class="text-[10px] font-bold text-teal-700 bg-teal-50 border border-teal-100 px-3 py-1 rounded-full hover:bg-teal-100 transition">
                            要約を更新
                        </button>
                    </div>
                    <div class="bg-teal-50 border border-teal-100 rounded-2xl p-4 text-sm text-gray-700">
                        <p id="memory-empty" class="text-xs text-gray-500">まだ要約がありません。</p>
                        <div id="memory-summary-text" class="hidden whitespace-pre-wrap"></div>
                    </div>
                </div>
                <div class="px-6 py-6">
                    <h3 class="text-sm font-bold text-teal-700 mb-3">セルフケア</h3>
                    <div class="grid grid-cols-1 gap-3">
                        <button class="selfcare-card">
                            <div>
                                <div class="text-xs font-bold text-gray-800 mb-1">3分呼吸リセット</div>
                                <div class="text-[11px] text-gray-500">4-7-8呼吸で落ち着きを取り戻す</div>
                            </div>
                            <span class="text-[10px] text-teal-600 font-bold">3分</span>
                        </button>
                        <button class="selfcare-card">
                            <div>
                                <div class="text-xs font-bold text-gray-800 mb-1">気分の書き出し</div>
                                <div class="text-[11px] text-gray-500">頭の中のモヤモヤを外に出す</div>
                            </div>
                            <span class="text-[10px] text-teal-600 font-bold">2分</span>
                        </button>
                        <button class="selfcare-card">
                            <div>
                                <div class="text-xs font-bold text-gray-800 mb-1">軽いストレッチ</div>
                                <div class="text-[11px] text-gray-500">首・肩をゆっくり回す</div>
                            </div>
                            <span class="text-[10px] text-teal-600 font-bold">5分</span>
                        </button>
                    </div>
                </div>
            </div>
        </main>

        <!-- ナビゲーション -->
        <nav class="bg-white border-t border-gray-100 h-16 flex justify-around items-center z-20 absolute bottom-0 w-full shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)]">
            <button class="nav-btn tab-active flex-1 flex flex-col items-center justify-center h-full gap-1 group" data-target="view-chat"><i class="fa-solid fa-comments text-xl mb-0.5 group-hover:scale-110 transition"></i><span class="text-[9px] font-bold">チャット</span></button>
            <button class="nav-btn tab-inactive flex-1 flex flex-col items-center justify-center h-full gap-1 group" data-target="view-work"><i class="fa-solid fa-pen-to-square text-xl mb-0.5 group-hover:scale-110 transition"></i><span class="text-[9px] font-bold">記録</span></button>
            <button class="nav-btn tab-inactive flex-1 flex flex-col items-center justify-center h-full gap-1 group" data-target="view-analysis"><i class="fa-solid fa-chart-pie text-xl mb-0.5 group-hover:scale-110 transition"></i><span class="text-[9px] font-bold">分析</span></button>
            <button class="nav-btn tab-inactive flex-1 flex flex-col items-center justify-center h-full gap-1 group" data-target="view-memory"><i class="fa-solid fa-brain text-xl mb-0.5 group-hover:scale-110 transition"></i><span class="text-[9px] font-bold">メモリ</span></button>
        </nav>

        <div id="settings-modal" class="hidden absolute inset-0 z-40 bg-black/35 p-4 flex items-end md:items-center justify-center">
            <div class="w-full max-w-sm bg-white rounded-2xl shadow-xl border border-gray-100 p-4 animate-fade-in">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-bold text-gray-800">設定</h3>
                    <button id="settings-close-btn" class="text-gray-400 hover:text-gray-600 text-sm">
                        <i class="fa-solid fa-xmark"></i>
                    </button>
                </div>
                <p class="text-xs text-gray-500 mb-4">ログイン中: <span id="user-name" class="font-bold text-gray-700"></span></p>
                <div class="space-y-2">
                    <button id="clear-logs-btn" class="w-full text-left bg-rose-50 text-rose-700 border border-rose-200 rounded-xl px-4 py-3 text-sm font-bold hover:bg-rose-100 transition">
                        <i class="fa-solid fa-trash-can mr-2"></i> ログを削除
                    </button>
                    <button id="settings-logout-btn" class="w-full text-left bg-gray-50 text-gray-700 border border-gray-200 rounded-xl px-4 py-3 text-sm font-bold hover:bg-gray-100 transition">
                        <i class="fa-solid fa-right-from-bracket mr-2"></i> ログアウト
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider, signOut, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, doc, setDoc, getDoc, onSnapshot, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        function readFirebaseConfigRuntime() {
            if (typeof __firebase_config !== "undefined" && __firebase_config) {
                try { return JSON.parse(__firebase_config); } catch {}
            }
            if (typeof window !== "undefined" && window.__FIREBASE_CONFIG__) {
                if (typeof window.__FIREBASE_CONFIG__ === "string") {
                    try { return JSON.parse(window.__FIREBASE_CONFIG__); } catch {}
                } else if (typeof window.__FIREBASE_CONFIG__ === "object") {
                    return window.__FIREBASE_CONFIG__;
                }
            }
            const meta = typeof document !== "undefined"
                ? document.querySelector('meta[name="firebase-config"]')
                : null;
            if (meta?.content) {
                try { return JSON.parse(meta.content); } catch {}
            }
            return null;
        }

        async function fetchFirebaseConfigFromServer() {
            try {
                const res = await fetch("/api/firebase-config-mental", {
                    method: "GET",
                    cache: "no-store"
                });
                if (!res.ok) return null;
                const data = await res.json();
                if (data && typeof data === "object" && data.apiKey && data.projectId) {
                    return data;
                }
            } catch {}
            return null;
        }

        const firebaseConfig = readFirebaseConfigRuntime() || await fetchFirebaseConfigFromServer();
        if (!firebaseConfig) {
            const msg = "Firebase config is missing. Provide __firebase_config, window.__FIREBASE_CONFIG__, or /api/firebase-config-mental.";
            const errWrap = document.getElementById("login-error-container");
            const errMsg = document.getElementById("login-error-msg");
            if (errWrap && errMsg) {
                errMsg.textContent = "Firebase設定の取得に失敗しました。管理者設定（firebase-config-mental API / 環境変数）を確認してください。";
                errWrap.classList.remove("hidden");
            }
            throw new Error(msg);
        }

        const GROQ_MODEL = "openai/gpt-oss-120b";
        const CHAT_SYSTEM_PROMPT = "あなたは経験豊富な日本語カウンセラーです。相手の気持ちを尊重し、共感的で自然な会話文で返答してください。固定の項目分けや見出し、箇条書きは使わず、会話の流れに沿って短く分かりやすく答えてください。必要なときだけ、押しつけにならない範囲で実行しやすい提案を1つ含めてください。";
        const MAX_INPUT_TOKENS = 5200;
        const TOKEN_PER_CHAR = 1 / 3.5;
        const SUMMARY_MAX_INPUT_TOKENS = 2400;
        const AUTO_SUMMARY_MIN_MESSAGES = 12;
        const AUTO_SUMMARY_COOLDOWN_MS = 5 * 60 * 1000;
        const AUTO_SUMMARY_MAX_TOKENS = 4200;
        const AUTO_SUMMARY_EVERY_USER_MESSAGES = 4;
        const AUTO_SUMMARY_FORCE_USER_MESSAGES = 8;

        const DEFAULT_PATTERNS = {
            "全か無か思考": 0,
            "過度の一般化": 0,
            "心のフィルター": 0,
            "マイナス化思考": 0,
            "結論の飛躍": 0,
            "拡大解釈・過小評価": 0,
            "感情的決めつけ": 0,
            "べき思考": 0,
            "レッテル貼り": 0,
            "個人化": 0
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const provider = new GoogleAuthProvider();

        let currentUser = null;
        let groqRateLimitUntil = 0;
        let autoSummaryTimer = null;
        let unsummarizedUserTurns = 0;
        const entryCommentRetryTimers = new Map();
        const entryCommentOverlay = new Map();
        let entryCommentInFlight = false;
        let entriesUnsubscribe = null;
        let firestoreErrorShown = false;
        let state = {
            chatHistory: [],
            chatSummary: "",
            chatSummaryUpdatedAt: 0,
            cbtEntries: [],
            patterns: { ...DEFAULT_PATTERNS },
            analysisComment: ""
        };

        function explainFirestoreError(error) {
            const message = `${error?.code || ""} ${error?.message || ""}`;
            if (/databases\/\(default\)/i.test(message) || /not[\s-]?found/i.test(message)) {
                return "Firestore データベースが見つかりません。Firebase Console で projectId と Firestore Database(default) の作成状態を確認してください。";
            }
            if (/permission[\s-]?denied/i.test(message)) {
                return "Firestore のセキュリティルールでアクセス拒否されています。認証済みユーザーの読み書きルールを確認してください。";
            }
            return "Firebase 設定値 (apiKey / projectId / authDomain) と、接続先プロジェクトが一致しているか確認してください。";
        }

        function notifyFirestoreError(context, error) {
            console.error(`[Firestore:${context}]`, error);
            if (firestoreErrorShown) return;
            firestoreErrorShown = true;
            const hint = explainFirestoreError(error);
            const fallbackMsg = "⚠️ データの読み込みに失敗しました。";
            if (typeof appendMsg === 'function') {
                appendMsg(`${fallbackMsg}\n${hint}`, 'ai');
                return;
            }
            alert(`${fallbackMsg}\n${hint}`);
        }

        function resetFirestoreListener() {
            if (typeof entriesUnsubscribe === 'function') {
                entriesUnsubscribe();
                entriesUnsubscribe = null;
            }
        }
        
        // 感情定義
        const EMOTIONS = [
            { id: 'anger', label: '怒り', color: '#ef4444' },
            { id: 'sadness', label: '悲しみ', color: '#3b82f6' },
            { id: 'anxiety', label: '不安', color: '#a855f7' },
            { id: 'disgust', label: '嫌悪', color: '#10b981' },
            { id: 'joy', label: '喜び', color: '#f43f5e' },
            { id: 'calm', label: '穏やか', color: '#64748b' }
        ];

        // --- Helpers ---
        function estimateTokens(text) {
            return Math.ceil((text || "").length * TOKEN_PER_CHAR);
        }

        function normalizeHistory(history) {
            if (!Array.isArray(history)) return [];
            return history.map((m) => {
                if (!m) return null;
                if (m.type === 'emotions' && m.content) return m;
                if (typeof m.content === 'string') return { role: m.role || 'user', content: m.content };
                if (m.parts && m.parts[0]?.text) {
                    const role = m.role === 'model' ? 'assistant' : (m.role || 'user');
                    return { role, content: m.parts[0].text };
                }
                return null;
            }).filter(Boolean);
        }

        function emotionsToText(emotions) {
            if (!emotions) return "";
            return Object.entries(emotions).map(([k,v]) => `${k}:${v}`).join(', ');
        }

        function normalizePatterns(input) {
            const base = { ...DEFAULT_PATTERNS };
            if (input && typeof input === 'object') {
                Object.keys(base).forEach((k) => {
                    if (typeof input[k] === 'number') base[k] = input[k];
                });
            }
            return base;
        }

        function getToolLabel(type) {
            const map = {
                "cbt-3": "3コラム法",
                "cbt-5": "5コラム法",
                "cbt-7": "7コラム法",
                "gratitude": "感謝日記",
                "tgt": "感謝日記",
                "cog-organize": "認知行動整理",
                "problem-solving": "問題解決",
                "quit-behavior": "辞めたい行動",
                "assertion": "アサーション",
                "desc": "DESC法",
                "free": "自由記述"
            };
            return map[type] || type || "ノート";
        }

        function formatEntryDate(iso) {
            const d = new Date(iso || Date.now());
            if (Number.isNaN(d.getTime())) return "";
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, "0");
            const day = String(d.getDate()).padStart(2, "0");
            const h = String(d.getHours()).padStart(2, "0");
            const min = String(d.getMinutes()).padStart(2, "0");
            return `${y}/${m}/${day} ${h}:${min}`;
        }

        const DETAIL_LABELS = {
            situation: "状況・出来事",
            thought: "自動思考",
            adaptive: "別の考え方",
            emotion: "気分・感情",
            evidenceFor: "根拠",
            evidenceAgainst: "反証",
            action: "次の行動",
            items: "感謝した出来事",
            reframe: "客観的な見方",
            control: "コントロールできること",
            next: "次の一歩",
            problem: "問題",
            goal: "目標",
            options: "解決案",
            best: "採用案",
            firstStep: "最初の行動",
            obstacle: "障害への備え",
            behavior: "辞めたい行動",
            trigger: "きっかけ",
            shortReward: "すぐ満たされるもの",
            trueNeed: "本当に満たしたいもの",
            alternative: "代替行動",
            plan: "If-Then",
            assertionFact: "事実",
            assertionFeeling: "気持ち",
            assertionNeed: "ニーズ",
            assertionRequest: "具体的なお願い",
            assertionConsideration: "相手への配慮",
            assertionScript: "Iメッセージ",
            descDescribe: "D: Describe",
            descExpress: "E: Express",
            descSpecify: "S: Specify",
            descConsequence: "C: Consequence",
            descScript: "最終メッセージ草案",
            note: "自由記述"
        };

        function getEntryDetailLines(entry) {
            const detail = entry?.detail;
            if (!detail || typeof detail !== "object") return [];
            const lines = [];
            Object.entries(detail).forEach(([k, v]) => {
                if (v === null || v === undefined || v === "") return;
                const label = DETAIL_LABELS[k] || k;
                if (Array.isArray(v)) {
                    const text = v.filter(Boolean).join(" / ");
                    if (text) lines.push(`${label}: ${text}`);
                    return;
                }
                const text = String(v).trim();
                if (text) lines.push(`${label}: ${text}`);
            });
            return lines;
        }

        function buildEntryDetailText(entry) {
            return getEntryDetailLines(entry).join(" | ").slice(0, 900);
        }

        function normalizeAiCommentText(text) {
            if (!text) return "";
            return String(text)
                .replace(/^["'`]+|["'`]+$/g, "")
                .replace(/\n{3,}/g, "\n\n")
                .trim();
        }

        function isRetryableAiCommentError(err) {
            if (!err) return false;
            if (err?.status === 429 || err?.code === "rate_limit_exceeded" || err?.code === "rate_limit_hold") return true;
            if (typeof err?.status === "number" && err.status >= 500) return true;
            const msg = String(err?.message || "");
            return /network|fetch|timeout|temporar/i.test(msg);
        }

        function getEntryWithOverlay(entry) {
            if (!entry || !entry.id) return entry;
            const overlay = entryCommentOverlay.get(entry.id);
            return overlay ? { ...entry, ...overlay } : entry;
        }

        function setEntryOverlay(entryId, patch) {
            if (!entryId) return;
            const prev = entryCommentOverlay.get(entryId) || {};
            entryCommentOverlay.set(entryId, { ...prev, ...patch });
        }

        function clearEntryOverlay(entryId) {
            if (!entryId) return;
            entryCommentOverlay.delete(entryId);
        }

        function clearEntryCommentRetry(entryId) {
            const timer = entryCommentRetryTimers.get(entryId);
            if (timer) {
                clearTimeout(timer);
                entryCommentRetryTimers.delete(entryId);
            }
        }

        function clearAllEntryCommentRetries() {
            entryCommentRetryTimers.forEach((timer) => clearTimeout(timer));
            entryCommentRetryTimers.clear();
        }

        function scheduleEntryCommentRetry(entryId, entrySnapshot, retryMs = 12000) {
            if (!entryId) return;
            if (entryCommentRetryTimers.has(entryId)) return;
            const wait = Math.max(1500, Math.min(retryMs, 60000));
            const timer = setTimeout(() => {
                entryCommentRetryTimers.delete(entryId);
                const latest = getEntryWithOverlay(state.cbtEntries.find((e) => e.id === entryId)) || entrySnapshot;
                generateEntryComment(entryId, latest, { silent: true, force: true }).catch((e) => console.error(e));
            }, wait);
            entryCommentRetryTimers.set(entryId, timer);
        }

        function syncPendingEntryComments() {
            if (!currentUser) return;
            const targets = [...(state.cbtEntries || [])]
                .map((e) => getEntryWithOverlay(e))
                .filter((e) => e && !e.aiComment && (e.aiCommentStatus === "pending" || e.aiCommentStatus === "retrying" || e.aiCommentStatus === "failed"))
                .sort((a, b) => new Date(b.date || 0) - new Date(a.date || 0))
                .slice(0, 1);
            targets.forEach((entry) => {
                const delay = entry.aiCommentStatus === "retrying" ? 5000 : (entry.aiCommentStatus === "failed" ? 4000 : 2500);
                scheduleEntryCommentRetry(entry.id, entry, delay);
            });
        }

        function buildChatMessages(history) {
            const systemContent = state.chatSummary
                ? `${CHAT_SYSTEM_PROMPT}\n\n【これまでの会話要約】\n${state.chatSummary}`
                : CHAT_SYSTEM_PROMPT;
            const system = { role: "system", content: systemContent };
            let total = estimateTokens(system.content);
            const selected = [];
            for (let i = history.length - 1; i >= 0; i--) {
                const msg = history[i];
                let role = msg.role || 'user';
                let content = msg.content || '';
                if (msg.type === 'emotions') {
                    role = 'user';
                    content = `感情記録: ${emotionsToText(msg.content)}`;
                }
                const cost = estimateTokens(content);
                if (total + cost > MAX_INPUT_TOKENS) break;
                selected.push({ role, content });
                total += cost;
            }
            return [system, ...selected.reverse()];
        }

        function estimateHistoryTokens(history) {
            return history.reduce((sum, m) => {
                if (m?.type === 'emotions') return sum + estimateTokens(emotionsToText(m.content));
                return sum + estimateTokens(m?.content || "");
            }, 0);
        }

        function shouldAutoSummarize() {
            if (Date.now() < groqRateLimitUntil) return false;
            const forceByTurns = unsummarizedUserTurns >= AUTO_SUMMARY_FORCE_USER_MESSAGES;
            if (forceByTurns) return true;
            if (state.chatHistory.length < 6) return false;
            if (Date.now() - (state.chatSummaryUpdatedAt || 0) < AUTO_SUMMARY_COOLDOWN_MS) return false;
            const tokens = estimateHistoryTokens(state.chatHistory);
            const byTurns = unsummarizedUserTurns >= AUTO_SUMMARY_EVERY_USER_MESSAGES;
            const byTokens = tokens > AUTO_SUMMARY_MAX_TOKENS;
            return byTurns || byTokens;
        }

        function buildSummaryInput(history, options = {}) {
            let total = 0;
            const blocks = [];
            const maxTokens = options.maxTokens ?? SUMMARY_MAX_INPUT_TOKENS;
            const maxMessages = options.maxMessages ?? history.length;
            const includeSummary = options.includeSummary ?? true;
            if (includeSummary && state.chatSummary) {
                const header = `【既存の要約】\n${state.chatSummary}\n\n`;
                blocks.push(header);
                total += estimateTokens(header);
            }
            const lines = [];
            let count = 0;
            for (let i = history.length - 1; i >= 0; i--) {
                if (count >= maxMessages) break;
                const msg = history[i];
                let line = '';
                if (msg.type === 'emotions') {
                    line = `Emotions: ${emotionsToText(msg.content)}\n`;
                } else {
                    const role = msg.role === 'user' ? 'User' : 'Assistant';
                    line = `${role}: ${msg.content}\n`;
                }
                const cost = estimateTokens(line);
                if (total + cost > maxTokens) break;
                lines.push(line);
                total += cost;
                count += 1;
            }
            lines.reverse();
            blocks.push(lines.join(""));
            return blocks.join("");
        }

        function chunkHistoryByTokens(history, maxTokens) {
            const chunks = [];
            let current = [];
            let total = 0;
            history.forEach((msg) => {
                let text = "";
                if (msg?.type === 'emotions') text = `Emotions: ${emotionsToText(msg.content)}`;
                else text = msg?.content || "";
                const cost = estimateTokens(text);
                if (current.length > 0 && total + cost > maxTokens) {
                    chunks.push(current);
                    current = [];
                    total = 0;
                }
                current.push(msg);
                total += cost;
            });
            if (current.length > 0) chunks.push(current);
            return chunks;
        }

        function buildLocalSummary(history) {
            const recent = (history || []).slice(-12);
            if (recent.length === 0) return "";

            const userTexts = [];
            const aiTexts = [];
            const emotionNotes = [];
            recent.forEach((msg) => {
                if (!msg) return;
                if (msg.type === 'emotions' && msg.content) {
                    emotionNotes.push(emotionsToText(msg.content));
                    return;
                }
                const text = (msg.content || "").toString().trim();
                if (!text) return;
                if (msg.role === 'assistant') aiTexts.push(text);
                else userTexts.push(text);
            });

            const pick = (arr) => arr.length ? arr[arr.length - 1].slice(0, 120) : "記録なし";
            const background = pick(userTexts);
            const emotion = emotionNotes.length ? emotionNotes.slice(-2).join(" / ").slice(0, 120) : "感情記録なし";
            const advice = pick(aiTexts);
            const unresolved = userTexts.length > 1 ? userTexts[userTexts.length - 2].slice(0, 120) : "次の相談で確認";

            return [
                `- 今の状況: ${background}`,
                `- 気持ち: ${emotion}`,
                `- 試したこと: ${advice}`,
                `- 次の一歩: ${unresolved}`
            ].join("\n");
        }

        async function callGroq(messages, options = {}) {
            if (!currentUser) throw new Error("Not authenticated");
            if (window.location.protocol === "file:") {
                throw new Error("ローカルファイルではAPIが使えません。デプロイ先URLで開いてください。");
            }
            if (Date.now() < groqRateLimitUntil) {
                const err = new Error("rate_limit_hold");
                err.retryAfterMs = groqRateLimitUntil - Date.now();
                err.code = "rate_limit_hold";
                throw err;
            }
            const token = await currentUser.getIdToken(true);
            const bodyObj = {
                model: GROQ_MODEL,
                messages,
                temperature: options.temperature ?? 0.7,
                max_tokens: options.max_tokens ?? 1000
            };
            if (options.reasoning_effort) bodyObj.reasoning_effort = options.reasoning_effort;
            const res = await fetch("/api/groq-mental", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${token}`
                },
                body: JSON.stringify(bodyObj)
            });
            if (!res.ok) {
                const text = await res.text();
                let message = text || "Groq API error";
                try {
                    const parsed = JSON.parse(text);
                    if (parsed?.error?.message) message = parsed.error.message;
                    else if (typeof parsed?.error === "string") message = parsed.error;
                } catch {}
                let retryAfterMs = 0;
                const retryHeader = res.headers.get("Retry-After");
                if (retryHeader) {
                    const sec = parseFloat(retryHeader);
                    if (Number.isFinite(sec) && sec > 0) {
                        retryAfterMs = Math.ceil(sec * 1000);
                    }
                }
                const match = message.match(/try again in\s*([0-9.]+)s/i);
                if (match) retryAfterMs = Math.ceil(parseFloat(match[1]) * 1000);
                if (res.status === 429) {
                    if (!retryAfterMs) retryAfterMs = 12000;
                    groqRateLimitUntil = Date.now() + retryAfterMs + 700;
                }
                const err = new Error(message || "Groq API error");
                err.status = res.status;
                err.retryAfterMs = retryAfterMs;
                err.code = res.status === 429 ? "rate_limit_exceeded" : undefined;
                throw err;
            }
            const data = await res.json();
            return data?.content || "";
        }

        function handleRateLimitError(err, { silent } = {}) {
            const retryMs = err?.retryAfterMs || Math.max(0, groqRateLimitUntil - Date.now());
            if (retryMs > 0 && !silent) {
                const secs = Math.ceil(retryMs / 1000);
                alert(`アクセス集中のため、${secs}秒後に再試行してください。`);
            }
            return retryMs;
        }

        function formatErrorDetails(err) {
            if (!err) return "";
            let msg = err?.message || String(err);
            if (!msg) return "";
            try {
                const parsed = JSON.parse(msg);
                if (parsed?.error?.message) msg = parsed.error.message;
            } catch {}
            if (msg.length > 400) msg = msg.slice(0, 400) + "...";
            return msg;
        }

        function buildQuickDailyFeedback(entry) {
            const summary = truncateText(entry?.summary || "", 80);
            const emotions = entry?.emotions && Object.keys(entry.emotions).length > 0
                ? emotionsToText(entry.emotions)
                : "";
            const firstDetail = getEntryDetailLines(entry)[0] || "";
            const cue = summary || firstDetail || "今日の記録";
            if (emotions) {
                return `${cue}を書き出せたのは大切な一歩です。${emotions}という感情に気づけているので、次は「今できる最小の行動」を1つだけ決めてみましょう。`;
            }
            return `${cue}を言葉にできた時点で整理は進んでいます。次は気持ちを10点でも軽くする行動を1つだけ選んで、短く実行してみましょう。`;
        }

        function buildEntryCommentFallback(entry, error) {
            const tool = getToolLabel(entry?.type);
            const summary = truncateText(entry?.summary || "", 90);
            const detailLine = getEntryDetailLines(entry)[0] || "";
            const emotions = entry?.emotions || {};
            const topEmotion = Object.entries(emotions).sort((a, b) => (b[1] || 0) - (a[1] || 0))[0]?.[0] || "";
            const avgScore = Math.round((((entry?.mental || 0) + (entry?.physical || 0)) / 2));
            const cue = summary || truncateText(detailLine, 70) || "いまの記録";
            const empathy = topEmotion
                ? `「${topEmotion}」を感じる中で${tool}を記録したのですね。`
                : `${tool}として今の状態を言葉にできたのは大切な一歩です。`;
            const reframe = avgScore <= 45
                ? `しんどさが強い時に「${cue}」を見える形にしたことで、気持ちを守る準備はもう始まっています。`
                : `「${cue}」を整理して書けている時点で、状況を客観視する力はしっかり働いています。`;
            const stepMap = {
                "gratitude": "次は今日の中で少しでも楽だった瞬間を1つだけ追記して、気持ちの土台を増やしてみましょう。",
                "cbt-7": "次は反証の欄を1行だけ追加して、考えの偏りを少しゆるめてみましょう。",
                "problem-solving": "次は最初の行動を10分で終わる粒度にして、実行ハードルを下げてみましょう。",
                "assertion": "次はお願いの文を「私は〜してもらえると助かる」に整えて、伝わりやすさを上げてみましょう。",
                "desc": "次はDESCのS(提案)を1文で具体化して、相手に行動をイメージしてもらいましょう。"
            };
            const step = stepMap[entry?.type] || "次は今の負担を10%軽くする行動を1つだけ決めて、短く試してみましょう。";
            const errHint = formatErrorDetails(error);
            if (errHint && /anonymous users are not allowed|missing authorization|not authenticated/i.test(errHint)) {
                return `${empathy}${reframe}${step}`;
            }
            return `${empathy}${reframe}${step}`;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function callGroqWithRetry(messages, options = {}, maxRetries = 2) {
            let attempt = 0;
            const retryOptions = { ...options };
            while (true) {
                try {
                    return await callGroq(messages, retryOptions);
                } catch (e) {
                    const isRateLimit = e?.status === 429 || e?.code === "rate_limit_exceeded" || e?.code === "rate_limit_hold";
                    const retryMs = handleRateLimitError(e, { silent: true });
                    if (isRateLimit && attempt < maxRetries) {
                        attempt += 1;
                        if (typeof retryOptions.max_tokens === "number" && retryOptions.max_tokens > 350) {
                            retryOptions.max_tokens = Math.max(350, Math.floor(retryOptions.max_tokens * 0.7));
                        }
                        const waitMs = retryMs > 0 ? (retryMs + 700) : (attempt * 2500);
                        await sleep(waitMs);
                        continue;
                    }
                    throw e;
                }
            }
        }

        function scheduleAutoSummary(delayMs = 12000) {
            if (autoSummaryTimer) return;
            autoSummaryTimer = setTimeout(async () => {
                autoSummaryTimer = null;
                try {
                    await runSummary({ silent: true });
                } catch (e) {
                    const retryMs = handleRateLimitError(e, { silent: true });
                    if (retryMs > 0) scheduleAutoSummary(retryMs + 500);
                }
            }, delayMs);
        }

        function truncateText(value, max = 160) {
            const text = String(value || "").replace(/\s+/g, " ").trim();
            if (!text) return "";
            return text.length > max ? `${text.slice(0, max)}…` : text;
        }

        function extractJsonObject(raw) {
            if (typeof raw !== "string") return null;
            const startTag = raw.indexOf("<json>");
            const endTag = raw.indexOf("</json>");
            let candidate = raw;
            if (startTag !== -1 && endTag !== -1 && endTag > startTag) {
                candidate = raw.slice(startTag + 6, endTag).trim();
            } else {
                const start = raw.indexOf("{");
                const end = raw.lastIndexOf("}");
                if (start !== -1 && end !== -1 && end > start) {
                    candidate = raw.slice(start, end + 1).trim();
                }
            }
            if (!candidate) return null;
            try {
                return JSON.parse(candidate);
            } catch {
                return null;
            }
        }

        function buildAnalysisInput(entries) {
            const recent = [...(entries || [])]
                .filter(Boolean)
                .sort((a, b) => new Date(b.date || 0) - new Date(a.date || 0))
                .slice(0, 8);

            const notes = recent.map((e) => {
                const emText = truncateText(e.emotions ? emotionsToText(e.emotions) : "", 80);
                const summary = truncateText(e.summary, 120);
                const detail = truncateText(buildEntryDetailText(e), 140);
                const day = formatEntryDate(e.date).split(" ")[0] || "";
                return [`[${day}]`, getToolLabel(e.type), summary, emText, detail].filter(Boolean).join(" / ");
            }).filter(Boolean).join("\n");

            const scores = recent.slice(0, 7).map((e) => {
                const day = formatEntryDate(e.date).split(" ")[0] || "";
                return `[${day}] 心:${e.mental || 0} 体:${e.physical || 0}`;
            }).join(", ");

            return { notes: notes.slice(0, 1500), scores: scores.slice(0, 500), recent };
        }

        function buildLocalAnalysisFallback(entries) {
            const patterns = normalizePatterns({});
            const recent = [...(entries || [])]
                .filter(Boolean)
                .sort((a, b) => new Date(b.date || 0) - new Date(a.date || 0))
                .slice(0, 10);

            const corpus = recent.map((e) => {
                return [
                    e.summary || "",
                    buildEntryDetailText(e),
                    e.emotions ? emotionsToText(e.emotions) : ""
                ].join(" ");
            }).join(" ").toLowerCase();

            const keywordRules = [
                ["全か無か思考", ["絶対", "必ず", "いつも", "全然", "完璧", "100", "0か100"]],
                ["過度の一般化", ["毎回", "どうせ", "結局", "全部だめ"]],
                ["心のフィルター", ["失敗", "だめ", "悪い", "不足"]],
                ["マイナス化思考", ["意味ない", "無理", "価値がない", "無駄"]],
                ["結論の飛躍", ["きっと", "に違いない", "嫌われ", "決めつけ"]],
                ["感情的決めつけ", ["不安だから", "怖いから", "つらいから"]],
                ["べき思考", ["べき", "ねば", "しなければ"]],
                ["レッテル貼り", ["自分はダメ", "最低", "無能", "ダメ人間"]],
                ["個人化", ["自分のせい", "私が悪い", "全部自分"]]
            ];
            keywordRules.forEach(([label, words]) => {
                const hit = words.reduce((n, w) => n + (corpus.includes(String(w).toLowerCase()) ? 1 : 0), 0);
                if (hit > 0) patterns[label] += Math.min(3, hit);
            });

            const avgMental = recent.length ? Math.round(recent.reduce((n, e) => n + (e.mental || 0), 0) / recent.length) : 0;
            const avgPhysical = recent.length ? Math.round(recent.reduce((n, e) => n + (e.physical || 0), 0) / recent.length) : 0;
            if (avgMental <= 45) patterns["マイナス化思考"] += 1;
            if (avgPhysical <= 45) patterns["感情的決めつけ"] += 1;

            const top = Object.entries(patterns).sort((a, b) => b[1] - a[1]).slice(0, 2).filter(([, v]) => v > 0);
            const topText = top.length > 0 ? top.map(([k]) => `「${k}」`).join("と") : "考えの偏り";
            const comment = `${topText}が出やすい傾向です。事実と解釈を分けて1行ずつ書き、最後に「今できる一歩」を1つだけ決めると気持ちが整いやすくなります。`;

            return { patterns, comment, source: "local" };
        }

        async function callAnalysis({ notes, scores, recentEntries }) {
            const prompts = [
                `以下の記録を分析し、必ずJSONのみ返してください。余計な説明は禁止。commentは120字以内。\n出力キー: patterns, comment\npatternsキー: 全か無か思考,過度の一般化,心のフィルター,マイナス化思考,結論の飛躍,拡大解釈・過小評価,感情的決めつけ,べき思考,レッテル貼り,個人化\n記録:\nテキスト:${notes || "なし"}\nスコア:${scores || "なし"}`,
                `認知の歪み10項目を0以上の整数で採点し、commentを作ってJSONのみ返してください。形式: {"patterns":{...},"comment":"..."}\n記録:${notes || "なし"}\nスコア:${scores || "なし"}`
            ];

            let lastError;
            for (const prompt of prompts) {
                try {
                    const raw = await callGroqWithRetry(
                        [
                            { role: "system", content: "あなたは認知行動療法に詳しい心理支援AIです。出力はJSONのみ。" },
                            { role: "user", content: prompt }
                        ],
                        { temperature: 0.2, max_tokens: 600, reasoning_effort: "low" },
                        3
                    );
                    const parsed = extractJsonObject(raw);
                    if (!parsed || typeof parsed !== "object") continue;
                    const patterns = normalizePatterns(parsed.patterns);
                    const comment = truncateText(parsed.comment, 180);
                    if (!comment) continue;
                    return { patterns, comment, source: "ai" };
                } catch (e) {
                    lastError = e;
                    const retryMs = handleRateLimitError(e, { silent: true });
                    if (retryMs > 0) await sleep(retryMs + 500);
                }
            }

            if (lastError) {
                console.warn("AI分析はフォールバックします:", lastError);
            }
            return buildLocalAnalysisFallback(recentEntries || []);
        }

        // --- Auth ---
        const loginErrorContainer = document.getElementById('login-error-container');
        const loginErrorMsg = document.getElementById('login-error-msg');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const settingsCloseBtn = document.getElementById('settings-close-btn');
        const settingsLogoutBtn = document.getElementById('settings-logout-btn');
        const clearLogsBtn = document.getElementById('clear-logs-btn');

        function openSettingsModal() {
            settingsModal.classList.remove('hidden');
        }

        function closeSettingsModal() {
            settingsModal.classList.add('hidden');
        }

        document.getElementById('google-login-btn').addEventListener('click', async () => {
            try {
                loginErrorContainer.classList.add('hidden');
                await signInWithPopup(auth, provider);
            } catch (e) {
                loginErrorMsg.textContent = e?.message || "ログインに失敗しました";
                loginErrorContainer.classList.remove('hidden');
            }
        });
        settingsBtn.addEventListener('click', openSettingsModal);
        settingsCloseBtn.addEventListener('click', closeSettingsModal);
        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) closeSettingsModal();
        });
        settingsLogoutBtn.addEventListener('click', async () => {
            closeSettingsModal();
            await signOut(auth);
        });
        if (typeof __initial_auth_token !== 'undefined') signInWithCustomToken(auth, __initial_auth_token).catch(()=>{});

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                unsummarizedUserTurns = 0;
                firestoreErrorShown = false;
                clearAllEntryCommentRetries();
                entryCommentOverlay.clear();
                resetFirestoreListener();
                document.getElementById('user-name').textContent = user.isAnonymous ? "ゲスト" : (user.displayName || "ユーザー");
                document.getElementById('login-screen').classList.add('hidden');
                document.getElementById('app-container').classList.remove('hidden');
                loadFirestoreData(user.uid);
            } else {
                currentUser = null;
                unsummarizedUserTurns = 0;
                clearAllEntryCommentRetries();
                entryCommentOverlay.clear();
                closeSettingsModal();
                document.getElementById('user-name').textContent = "";
                resetFirestoreListener();
                document.getElementById('login-screen').classList.remove('hidden');
                document.getElementById('app-container').classList.add('hidden');
                state = { chatHistory: [], chatSummary: "", chatSummaryUpdatedAt: 0, cbtEntries: [], patterns: { ...DEFAULT_PATTERNS }, analysisComment: "" };
                updateSummaryUI();
                renderEntryHistory();
            }
        });

        // --- Data ---
        function loadFirestoreData(uid) {
            resetFirestoreListener();
            const chatRef = doc(db, "users", uid, "data", "chatHistory");
            getDoc(chatRef).then(snap => {
                if (snap.exists()) {
                    const data = snap.data() || {};
                    state.chatHistory = normalizeHistory(data.history || []);
                    state.chatSummary = data.summary || "";
                    state.chatSummaryUpdatedAt = data.summaryUpdatedAt || 0;
                } else {
                    state.chatHistory = [{role: "assistant", content: "こんにちは。今の気分を教えていただけますか？"}];
                }
                renderChatHistory();
            }).catch((error) => {
                state.chatHistory = [{role: "assistant", content: "こんにちは。今の気分を教えていただけますか？"}];
                renderChatHistory();
                notifyFirestoreError("chatHistory/getDoc", error);
            });

            const patRef = doc(db, "users", uid, "data", "patterns");
            getDoc(patRef).then(snap => {
                if(snap.exists()) {
                    const data = snap.data() || {};
                    state.patterns = normalizePatterns(data.patterns);
                    state.analysisComment = data.comment || "";
                    if (state.analysisComment) {
                        document.getElementById('wave-analysis-text').textContent = state.analysisComment;
                    }
                    renderPatternChart();
                }
            }).catch((error) => {
                notifyFirestoreError("patterns/getDoc", error);
            });

            const q = query(collection(db, "users", uid, "entries"), orderBy("date", "desc"), limit(50));
            entriesUnsubscribe = onSnapshot(q, (snap) => {
                state.cbtEntries = snap.docs.map(d => ({id:d.id, ...d.data()}));
                updateCharts();
                renderEntryHistory();
                syncPendingEntryComments();
            }, (error) => {
                notifyFirestoreError("entries/onSnapshot", error);
            });
        }

        async function saveChat() {
            if(!currentUser) return;
            await setDoc(doc(db, "users", currentUser.uid, "data", "chatHistory"), { 
                history: state.chatHistory,
                summary: state.chatSummary,
                summaryUpdatedAt: state.chatSummaryUpdatedAt || 0
            }, {merge:true});
        }

        async function saveAnalysis(patterns, comment) {
            if (!currentUser) return;
            await setDoc(doc(db, "users", currentUser.uid, "data", "patterns"), { patterns, comment }, { merge: true });
        }

        async function clearUserLogs(uid) {
            resetFirestoreListener();

            const entriesRef = collection(db, "users", uid, "entries");
            const entriesSnapshot = await getDocs(entriesRef);
            const docs = entriesSnapshot.docs;
            for (let i = 0; i < docs.length; i += 450) {
                const batch = writeBatch(db);
                docs.slice(i, i + 450).forEach((d) => batch.delete(d.ref));
                await batch.commit();
            }

            const initialHistory = [{ role: "assistant", content: "こんにちは。今の気分を教えていただけますか？" }];
            await setDoc(doc(db, "users", uid, "data", "chatHistory"), {
                history: initialHistory,
                summary: "",
                summaryUpdatedAt: 0
            });
            await setDoc(doc(db, "users", uid, "data", "patterns"), {
                patterns: { ...DEFAULT_PATTERNS },
                comment: ""
            });

            state = {
                chatHistory: initialHistory,
                chatSummary: "",
                chatSummaryUpdatedAt: 0,
                cbtEntries: [],
                patterns: { ...DEFAULT_PATTERNS },
                analysisComment: ""
            };
            unsummarizedUserTurns = 0;
            clearAllEntryCommentRetries();
            entryCommentOverlay.clear();
            document.getElementById('wave-analysis-text').textContent = "まだ分析データがありません。";
            renderChatHistory();
            renderPatternChart();
            resetDailyCharts();
            renderEntryHistory();
            loadFirestoreData(uid);
        }

        clearLogsBtn.addEventListener('click', async () => {
            if (!currentUser) return;
            const ok = confirm("保存済みの記録・チャット要約・分析結果を削除します。元に戻せません。実行しますか？");
            if (!ok) return;

            const original = clearLogsBtn.innerHTML;
            clearLogsBtn.disabled = true;
            clearLogsBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i> 削除中...';
            try {
                await clearUserLogs(currentUser.uid);
                closeSettingsModal();
                alert("ログを削除しました。");
            } catch (e) {
                console.error(e);
                alert("ログの削除に失敗しました。時間をおいて再度お試しください。");
            } finally {
                clearLogsBtn.disabled = false;
                clearLogsBtn.innerHTML = original;
            }
        });

        // --- Chat ---
        const chatContainer = document.getElementById('chat-container');
        const summarizeBtn = document.getElementById('summarize-btn');
        const chatSummaryWrap = document.getElementById('chat-summary-wrap');
        const chatSummaryText = document.getElementById('chat-summary-text');
        const memorySummaryText = document.getElementById('memory-summary-text');
        const memoryEmpty = document.getElementById('memory-empty');
        const memoryRefreshBtn = document.getElementById('memory-refresh-btn');
        const workTabButtons = Array.from(document.querySelectorAll('.work-tab-btn'));
        const workPaneWrite = document.getElementById('work-pane-write');
        const workPaneRead = document.getElementById('work-pane-read');
        const entriesHistoryList = document.getElementById('entries-history-list');
        const refreshHistoryBtn = document.getElementById('refresh-history-btn');
        let activeWorkTab = "write";

        function updateSummaryUI() {
            if (state.chatSummary) {
                chatSummaryText.textContent = state.chatSummary;
                chatSummaryWrap.classList.remove('hidden');
                memorySummaryText.textContent = state.chatSummary;
                memorySummaryText.classList.remove('hidden');
                memoryEmpty.classList.add('hidden');
            } else {
                chatSummaryText.textContent = '';
                chatSummaryWrap.classList.add('hidden');
                memorySummaryText.textContent = '';
                memorySummaryText.classList.add('hidden');
                memoryEmpty.classList.remove('hidden');
            }
        }

        function renderChatHistory() {
            chatContainer.innerHTML = '';
            updateSummaryUI();
            state.chatHistory.forEach(m => {
                if(m.type === 'emotions') appendEmotionBubble(m.content);
                else appendMsg(m.content, m.role === 'user' ? 'user' : 'ai');
            });
        }

        function switchWorkTab(tab) {
            activeWorkTab = (tab === "read") ? "read" : "write";
            const showRead = activeWorkTab === "read";
            workPaneWrite.classList.toggle("hidden", showRead);
            workPaneRead.classList.toggle("hidden", !showRead);
            workTabButtons.forEach((btn) => {
                const active = btn.dataset.workTab === activeWorkTab;
                btn.classList.toggle("bg-teal-600", active);
                btn.classList.toggle("text-white", active);
                btn.classList.toggle("text-gray-500", !active);
            });
            if (showRead) renderEntryHistory();
        }

        function renderEntryHistory() {
            if (!entriesHistoryList) return;
            entriesHistoryList.innerHTML = "";
            const sorted = [...(state.cbtEntries || [])]
                .filter((e) => !!e)
                .sort((a, b) => new Date(b.date || 0) - new Date(a.date || 0));

            if (sorted.length === 0) {
                const empty = document.createElement("div");
                empty.className = "bg-white border border-gray-100 rounded-xl p-4 text-sm text-gray-500";
                empty.textContent = "まだ記録がありません。";
                entriesHistoryList.appendChild(empty);
                return;
            }

            sorted.forEach((rawEntry) => {
                const entry = getEntryWithOverlay(rawEntry);
                const card = document.createElement("article");
                card.className = "bg-white border border-gray-100 rounded-2xl p-4 shadow-sm";

                const top = document.createElement("div");
                top.className = "flex items-center justify-between gap-2 mb-2";
                const date = document.createElement("div");
                date.className = "text-[11px] text-gray-400";
                date.textContent = formatEntryDate(entry.date);
                const badge = document.createElement("span");
                badge.className = "text-[10px] px-2 py-1 rounded-full bg-teal-50 text-teal-700 font-bold";
                badge.textContent = getToolLabel(entry.type);
                top.appendChild(date);
                top.appendChild(badge);

                const summary = document.createElement("p");
                summary.className = "text-sm text-gray-700 leading-relaxed whitespace-pre-wrap";
                summary.textContent = entry.summary || "（要約なし）";

                card.appendChild(top);
                card.appendChild(summary);

                const detailLines = getEntryDetailLines(entry);
                if (detailLines.length > 0) {
                    const details = document.createElement("details");
                    details.className = "mt-3 bg-slate-50 rounded-lg p-3 border border-slate-100";
                    const detailsSummary = document.createElement("summary");
                    detailsSummary.className = "cursor-pointer text-xs font-bold text-slate-600";
                    detailsSummary.textContent = "入力内容をみる";
                    const ul = document.createElement("ul");
                    ul.className = "mt-2 space-y-1";
                    detailLines.forEach((line) => {
                        const li = document.createElement("li");
                        li.className = "text-xs text-gray-600 leading-relaxed";
                        li.textContent = line;
                        ul.appendChild(li);
                    });
                    details.appendChild(detailsSummary);
                    details.appendChild(ul);
                    card.appendChild(details);
                }

                const aiBox = document.createElement("div");
                aiBox.className = "mt-3 p-3 rounded-lg border border-rose-100 bg-rose-50";
                const aiTitle = document.createElement("p");
                aiTitle.className = "text-[11px] font-bold text-rose-600 mb-1";
                aiTitle.innerHTML = '<i class="fa-solid fa-robot mr-1"></i> AIコメント';
                aiBox.appendChild(aiTitle);

                const comment = (entry.aiComment || "").trim();
                const status = entry.aiCommentStatus || "";
                if (comment) {
                    const txt = document.createElement("p");
                    txt.className = "text-xs text-gray-700 leading-relaxed whitespace-pre-wrap";
                    txt.textContent = comment;
                    aiBox.appendChild(txt);

                    const regen = document.createElement("button");
                    regen.className = "mt-2 text-[10px] font-bold text-rose-700 bg-white border border-rose-200 px-2 py-1 rounded hover:bg-rose-100";
                    regen.textContent = "再生成";
                    regen.addEventListener("click", () => generateEntryComment(entry.id, entry, { silent: true, force: true }));
                    aiBox.appendChild(regen);
                } else if (status === "generating" || status === "retrying") {
                    const generating = document.createElement("p");
                    generating.className = "text-xs text-gray-500";
                    generating.innerHTML = status === "retrying"
                        ? '<i class="fa-solid fa-clock-rotate-left mr-1"></i> 生成待ちです。自動で再試行します...'
                        : '<i class="fa-solid fa-spinner fa-spin mr-1"></i> 生成中...';
                    aiBox.appendChild(generating);
                } else if (status === "failed") {
                    const failed = document.createElement("p");
                    failed.className = "text-xs text-gray-500";
                    failed.textContent = "コメント生成に失敗しました。再試行してください。";
                    aiBox.appendChild(failed);

                    const retryBtn = document.createElement("button");
                    retryBtn.className = "mt-2 text-[10px] font-bold text-rose-700 bg-white border border-rose-200 px-2 py-1 rounded hover:bg-rose-100";
                    retryBtn.textContent = "再試行";
                    retryBtn.addEventListener("click", () => generateEntryComment(entry.id, entry, { silent: false, force: true }));
                    aiBox.appendChild(retryBtn);
                } else {
                    const btn = document.createElement("button");
                    btn.className = "text-[11px] font-bold text-rose-700 bg-white border border-rose-200 px-3 py-1.5 rounded hover:bg-rose-100";
                    btn.textContent = "AIコメントを作る";
                    btn.addEventListener("click", () => generateEntryComment(entry.id, entry, { silent: false, force: true }));
                    aiBox.appendChild(btn);
                }

                card.appendChild(aiBox);
                entriesHistoryList.appendChild(card);
            });
        }

        function appendMsg(text, type) {
            const div = document.createElement('div');
            div.className = `flex ${type==='user'?'justify-end':'justify-start'} mb-4 animate-fade-in`;
            const bg = type==='user'?'bg-teal-600 text-white rounded-br-none':'bg-white text-gray-800 rounded-bl-none shadow-sm';
            div.innerHTML = `<div class="${bg} p-3 rounded-2xl max-w-[85%] text-sm leading-relaxed bubble">${DOMPurify.sanitize(marked.parse(text))}</div>`;
            chatContainer.appendChild(div);
            chatContainer.scrollTo({top: chatContainer.scrollHeight, behavior:'smooth'});
        }

        function appendEmotionBubble(emotions) {
            const div = document.createElement('div');
            div.className = `flex justify-end mb-4 animate-fade-in`;
            
            let ringsHtml = '';
            Object.entries(emotions).forEach(([key, val]) => {
                const em = EMOTIONS.find(e => e.label === key) || { color: '#ccc' };
                const radius = 24;
                const circumference = 2 * Math.PI * radius;
                const offset = circumference - (val / 100) * circumference;
                
                ringsHtml += `
                    <div class="ring-container">
                        <svg class="ring-svg" viewBox="0 0 60 60">
                            <circle class="ring-circle-bg" cx="30" cy="30" r="${radius}"></circle>
                            <circle class="ring-circle-fg" cx="30" cy="30" r="${radius}" 
                                style="stroke: ${em.color}; stroke-dasharray: ${circumference}; stroke-dashoffset: ${offset};"></circle>
                        </svg>
                        <div class="ring-text">
                            <div class="ring-label">${key}</div>
                            <div class="ring-score">${val}</div>
                        </div>
                    </div>
                `;
            });

            div.innerHTML = `<div class="bg-gray-800 p-3 rounded-2xl rounded-br-none shadow-lg flex gap-2">${ringsHtml}</div>`;
            chatContainer.appendChild(div);
            chatContainer.scrollTo({top: chatContainer.scrollHeight, behavior:'smooth'});
        }

        async function runSummary({ silent }) {
            const attempts = [
                { maxTokens: SUMMARY_MAX_INPUT_TOKENS, maxMessages: Math.min(state.chatHistory.length, 20), includeSummary: true },
                { maxTokens: 1600, maxMessages: 12, includeSummary: true },
                { maxTokens: 1100, maxMessages: 8, includeSummary: false }
            ];
            let summary = "";
            let lastError;
            for (const attempt of attempts) {
                try {
                    const input = buildSummaryInput(state.chatHistory, attempt);
                    if (!input.trim()) throw new Error("empty summary input");
                    const summaryPrompt = `次の会話を、やさしい日本語で短く要約してください。難しい言葉は使わず、1文を短くしてください。文字数は180〜260字。出力は必ず次の4行のみ。\n- 今の状況:\n- 気持ち:\n- 試したこと:\n- 次の一歩:\n\n${input}`;
                    summary = await callGroqWithRetry(
                        [
                            { role: "system", content: "あなたは会話要約の専門家です。余計な前置きは不要で、指定形式の要約だけ返してください。" },
                            { role: "user", content: summaryPrompt }
                        ],
                        { temperature: 0.25, max_tokens: 500, reasoning_effort: "low" },
                        2
                    );
                    if (summary) break;
                } catch (e) {
                    lastError = e;
                    if (!silent && e?.code !== "rate_limit_exceeded") {
                        const detail = formatErrorDetails(e);
                        if (detail) console.warn("summary attempt failed:", detail);
                    }
                }
            }
            if (!summary) {
                // Chunked summary fallback
                const chunks = chunkHistoryByTokens(state.chatHistory, 1200);
                const recentChunks = chunks.slice(-3);
                const partials = [];
                for (let i = 0; i < recentChunks.length; i++) {
                    const chunk = recentChunks[i];
                    const input = buildSummaryInput(chunk, { maxTokens: 1200, maxMessages: chunk.length, includeSummary: false });
                    if (!input.trim()) continue;
                    const prompt = `次の会話ログを、やさしい日本語で100〜160字に要約してください。出力は次の4行のみ。\n- 今の状況:\n- 気持ち:\n- 試したこと:\n- 次の一歩:\n\n${input}`;
                    try {
                        const part = await callGroqWithRetry(
                            [
                                { role: "system", content: "あなたは会話要約の専門家です。指定形式の要約だけ返してください。" },
                                { role: "user", content: prompt }
                            ],
                            { temperature: 0.25, max_tokens: 400, reasoning_effort: "low" },
                            2
                        );
                        if (part) partials.push(part.trim());
                    } catch (e) {
                        lastError = e;
                    }
                    await sleep(600);
                }
                if (partials.length > 0) {
                    const combined = (state.chatSummary ? `【既存の要約】\n${state.chatSummary}\n\n` : "") + partials.map((p, i) => `【要約${i + 1}】\n${p}`).join("\n\n");
                    const finalPrompt = `以下の要約を統合し、やさしい日本語で180〜260字の最終要約にしてください。出力は次の4行のみ。\n- 今の状況:\n- 気持ち:\n- 試したこと:\n- 次の一歩:\n\n${combined}`;
                    summary = await callGroqWithRetry(
                        [
                            { role: "system", content: "あなたは会話要約の専門家です。余計な前置きは不要で、指定形式の要約だけ返してください。" },
                            { role: "user", content: finalPrompt }
                        ],
                        { temperature: 0.25, max_tokens: 500, reasoning_effort: "low" },
                        2
                    );
                }
            }
            if (!summary) {
                summary = buildLocalSummary(state.chatHistory);
            }
            if (!summary) throw lastError || new Error("summary failed");

            state.chatSummary = (summary || "").trim();
            state.chatSummaryUpdatedAt = Date.now();
            unsummarizedUserTurns = 0;
            state.chatHistory = state.chatHistory.slice(-6);
            await saveChat();
            renderChatHistory();
            if (!silent) return;
        }

        document.getElementById('chat-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const input = document.getElementById('user-input');
            const text = input.value.trim();
            if(!text) return;
            input.value = '';
            
            state.chatHistory.push({role:'user', content:text});
            unsummarizedUserTurns += 1;
            appendMsg(text, 'user');
            saveChat();

            try {
                const messages = buildChatMessages(state.chatHistory);
                const reply = await callGroqWithRetry(messages, { temperature: 0.45, max_tokens: 1200 }, 2);
                state.chatHistory.push({role:'assistant', content:reply});
                appendMsg(reply, 'ai');
                saveChat();
                if (shouldAutoSummarize()) {
                    scheduleAutoSummary(12000);
                }
            } catch(e){ console.error(e); }
        });

        summarizeBtn.addEventListener('click', async () => {
            if (state.chatHistory.length < 2) return alert("要約する内容がありません");
            summarizeBtn.disabled = true;
            summarizeBtn.textContent = "要約中...";
            try {
                await runSummary({ silent: false });
            } catch (e) {
                const retryMs = handleRateLimitError(e, { silent: false });
                if (!retryMs) {
                    console.error(e);
                    const detail = formatErrorDetails(e);
                    alert(`要約に失敗しました。もう一度お試しください。${detail ? `\n詳細: ${detail}` : ""}`);
                }
            } finally {
                summarizeBtn.textContent = "会話を要約";
                summarizeBtn.disabled = false;
            }
        });

        if (memoryRefreshBtn) {
            memoryRefreshBtn.addEventListener('click', async () => {
                if (state.chatHistory.length < 2) return alert("要約する内容がありません");
                memoryRefreshBtn.disabled = true;
                memoryRefreshBtn.textContent = "更新中...";
                try {
                    await runSummary({ silent: false });
                } catch (e) {
                    const retryMs = handleRateLimitError(e, { silent: false });
                    if (!retryMs) {
                        console.error(e);
                        const detail = formatErrorDetails(e);
                        alert(`要約に失敗しました。もう一度お試しください。${detail ? `\n詳細: ${detail}` : ""}`);
                    }
                } finally {
                    memoryRefreshBtn.textContent = "要約を更新";
                    memoryRefreshBtn.disabled = false;
                }
            });
        }

        workTabButtons.forEach((btn) => {
            btn.addEventListener("click", () => switchWorkTab(btn.dataset.workTab));
        });
        if (refreshHistoryBtn) {
            refreshHistoryBtn.addEventListener("click", () => renderEntryHistory());
        }
        switchWorkTab("write");

        // --- Tools Logic ---
        const activeEmotionsContainer = document.getElementById('active-emotions-container');
        const emotionSelector = document.getElementById('emotion-selector');
        const TOOL_DEFINITIONS = {
            'cbt-3': { title: '3コラム法', fields: ['cbt-common'] },
            'cbt-5': { title: '5コラム法', fields: ['cbt-common', 'cbt-advanced'] },
            'cbt-7': { title: '7コラム法', fields: ['cbt-common', 'cbt-advanced', 'cbt-7'] },
            'gratitude': { title: '感謝日記', fields: ['gratitude'] },
            'tgt': { title: 'スリー・グッド・シングス', fields: ['gratitude'] }, // 互換
            'cog-organize': { title: '認知行動整理', fields: ['cog-organize'] },
            'problem-solving': { title: '問題解決', fields: ['problem-solving'] },
            'quit-behavior': { title: '辞めたい行動', fields: ['quit-behavior'] },
            'assertion': { title: 'アサーション', fields: ['assertion'] },
            'desc': { title: 'DESC法', fields: ['desc'] },
            'free': { title: '自由記述・モヤモヤ整理', fields: ['free'] }
        };

        function readText(id) {
            return (document.getElementById(id)?.value || '').trim();
        }

        function buildEntryPayload(type) {
            if (type === 'cbt-3') {
                const situation = readText('cbt-situation');
                const thought = readText('cbt-thought');
                if (!situation && !thought) return { validationError: '状況・出来事 か 自動思考 を入力してください。' };
                return {
                    summary: [situation ? `状況:${situation}` : '', thought ? `思考:${thought}` : ''].filter(Boolean).join(' / '),
                    detail: { situation, thought }
                };
            }
            if (type === 'cbt-5') {
                const situation = readText('cbt-situation');
                const thought = readText('cbt-thought');
                const adaptive = readText('cbt-adaptive');
                if (!situation && !thought && !adaptive) return { validationError: '入力内容が空です。最低1項目入力してください。' };
                return {
                    summary: [situation ? `状況:${situation}` : '', thought ? `思考:${thought}` : '', adaptive ? `別の考え:${adaptive}` : ''].filter(Boolean).join(' / '),
                    detail: { situation, thought, adaptive }
                };
            }
            if (type === 'cbt-7') {
                const situation = readText('cbt-situation');
                const thought = readText('cbt-thought');
                const adaptive = readText('cbt-adaptive');
                const emotion = readText('cbt7-emotion');
                const evidenceFor = readText('cbt7-evidence-for');
                const evidenceAgainst = readText('cbt7-evidence-against');
                const action = readText('cbt7-action');
                if (!situation && !thought && !adaptive) return { validationError: '7コラム法の主要項目（状況・思考・別の考え方）を入力してください。' };
                return {
                    summary: [
                        situation ? `状況:${situation}` : '',
                        thought ? `思考:${thought}` : '',
                        adaptive ? `適応思考:${adaptive}` : '',
                        action ? `行動:${action}` : ''
                    ].filter(Boolean).join(' / '),
                    detail: { situation, thought, adaptive, emotion, evidenceFor, evidenceAgainst, action }
                };
            }
            if (type === 'gratitude' || type === 'tgt') {
                const items = [1, 2, 3].map((i) => readText(`gratitude-${i}`));
                const filled = items.filter(Boolean);
                if (filled.length < 3) return { validationError: '感謝したい出来事を3つ入力してください。' };
                return {
                    summary: filled.map((v, idx) => `${idx + 1}. ${v}`).join(' / '),
                    detail: { items: filled }
                };
            }
            if (type === 'cog-organize') {
                const situation = readText('cog-situation');
                const thought = readText('cog-thought');
                const reframe = readText('cog-reframe');
                const control = readText('cog-control');
                const next = readText('cog-next');
                if (!situation || !next) return { validationError: '認知行動整理は「ストレス状況」と「次の一歩」を入力してください。' };
                return {
                    summary: [`状況:${situation}`, thought ? `考え:${thought}` : '', reframe ? `客観視:${reframe}` : '', `次:${next}`].filter(Boolean).join(' / '),
                    detail: { situation, thought, reframe, control, next }
                };
            }
            if (type === 'problem-solving') {
                const problem = readText('ps-problem');
                const goal = readText('ps-goal');
                const options = readText('ps-options');
                const best = readText('ps-best');
                const firstStep = readText('ps-first-step');
                const obstacle = readText('ps-obstacle');
                if (!problem || !firstStep) return { validationError: '問題解決は「今の問題」と「最初の行動」を入力してください。' };
                return {
                    summary: [`問題:${problem}`, goal ? `目標:${goal}` : '', best ? `採用案:${best}` : '', `初動:${firstStep}`].filter(Boolean).join(' / '),
                    detail: { problem, goal, options, best, firstStep, obstacle }
                };
            }
            if (type === 'quit-behavior') {
                const behavior = readText('quit-behavior-name');
                const trigger = readText('quit-trigger');
                const shortReward = readText('quit-short-reward');
                const trueNeed = readText('quit-true-need');
                const alternative = readText('quit-alternative');
                const plan = readText('quit-plan');
                if (!behavior || !trigger || !alternative) return { validationError: '辞めたい行動は「行動名」「きっかけ」「代わりの行動」を入力してください。' };
                return {
                    summary: [`行動:${behavior}`, `きっかけ:${trigger}`, trueNeed ? `本当に満たしたいもの:${trueNeed}` : '', `代替:${alternative}`].filter(Boolean).join(' / '),
                    detail: { behavior, trigger, shortReward, trueNeed, alternative, plan }
                };
            }
            if (type === 'assertion') {
                const assertionFact = readText('assertion-fact');
                const assertionFeeling = readText('assertion-feeling');
                const assertionNeed = readText('assertion-need');
                const assertionRequest = readText('assertion-request');
                const assertionConsideration = readText('assertion-consideration');
                const assertionScript = readText('assertion-script');
                if (!assertionFact || !assertionFeeling || !assertionRequest) {
                    return { validationError: 'アサーションは「事実」「気持ち」「具体的なお願い」を入力してください。' };
                }
                return {
                    summary: [
                        `事実:${assertionFact}`,
                        `気持ち:${assertionFeeling}`,
                        assertionNeed ? `ニーズ:${assertionNeed}` : '',
                        `お願い:${assertionRequest}`
                    ].filter(Boolean).join(' / '),
                    detail: {
                        assertionFact,
                        assertionFeeling,
                        assertionNeed,
                        assertionRequest,
                        assertionConsideration,
                        assertionScript
                    }
                };
            }
            if (type === 'desc') {
                const descDescribe = readText('desc-describe');
                const descExpress = readText('desc-express');
                const descSpecify = readText('desc-specify');
                const descConsequence = readText('desc-consequence');
                const descScript = readText('desc-script');
                if (!descDescribe || !descExpress || !descSpecify || !descConsequence) {
                    return { validationError: 'DESC法は D/E/S/C の4項目を入力してください。' };
                }
                return {
                    summary: [
                        `D:${descDescribe}`,
                        `E:${descExpress}`,
                        `S:${descSpecify}`,
                        `C:${descConsequence}`
                    ].join(' / '),
                    detail: { descDescribe, descExpress, descSpecify, descConsequence, descScript }
                };
            }

            const freeNote = readText('free-note');
            if (!freeNote) return { validationError: '自由記述を入力してください。' };
            return { summary: freeNote, detail: { note: freeNote } };
        }

        function updateEntryInState(entryId, patch) {
            const idx = state.cbtEntries.findIndex((e) => e.id === entryId);
            if (idx < 0) return;
            state.cbtEntries[idx] = { ...state.cbtEntries[idx], ...patch };
        }

        async function generateEntryComment(entryId, entryInput, { silent = true, force = false } = {}) {
            if (!currentUser || !entryId) return;
            const currentEntry = getEntryWithOverlay(state.cbtEntries.find((e) => e.id === entryId)) || entryInput || {};
            const currentComment = normalizeAiCommentText(currentEntry.aiComment);
            if (!force && currentComment) return currentComment;
            if (currentEntry.aiCommentStatus === "generating") return "";

            if (entryCommentInFlight) {
                const queuedPatch = { aiCommentStatus: "retrying", aiCommentUpdatedAt: new Date().toISOString() };
                updateEntryInState(entryId, queuedPatch);
                setEntryOverlay(entryId, queuedPatch);
                renderEntryHistory();
                scheduleEntryCommentRetry(entryId, currentEntry, 2500);
                if (!silent) {
                    alert("別のAIコメントを生成中です。完了後に自動で再試行します。");
                }
                return "";
            }

            entryCommentInFlight = true;
            clearEntryCommentRetry(entryId);

            const entryRef = doc(db, "users", currentUser.uid, "entries", entryId);
            const markGenerating = {
                aiCommentStatus: "generating",
                aiCommentUpdatedAt: new Date().toISOString()
            };
            updateEntryInState(entryId, markGenerating);
            setEntryOverlay(entryId, markGenerating);
            renderEntryHistory();
            try {
                await setDoc(entryRef, markGenerating, { merge: true });
                clearEntryOverlay(entryId);
            } catch (persistError) {
                console.warn("AIコメント生成状態の保存に失敗:", persistError);
            }

            const emText = currentEntry.emotions ? emotionsToText(currentEntry.emotions) : "";
            const detailText = buildEntryDetailText(currentEntry).slice(0, 220);
            const shortSummary = String(currentEntry.summary || "").slice(0, 180);
            const promptPrimary = `次の記録に、心理職としての共感コメントを日本語で返してください。順序は「共感1文→リフレーミング1文→次の一歩1つ」。やさしいが専門家らしい文体、90〜160字、定型文は禁止。\n記録タイプ:${getToolLabel(currentEntry.type)}\nココロ:${currentEntry.mental || 0}\nカラダ:${currentEntry.physical || 0}\n感情:${emText || "なし"}\n要約:${shortSummary || "なし"}\n詳細:${detailText || "なし"}`;
            const promptFallback = `次の記録への短い共感コメントを作成してください。1文目で受け止め、2文目で前向きな解釈、3文目で次の一歩を1つ。100〜170字。前置き・箇条書き・定型句は禁止。\n記録タイプ:${getToolLabel(currentEntry.type)}\n要約:${shortSummary || "なし"}\n感情:${emText || "なし"}`;
            const promptLite = `記録への共感コメントを3文で返してください。1)共感 2)見方の言い換え 3)次の一歩。90〜140字。\n要約:${shortSummary || "なし"}\n感情:${emText || "なし"}`;

            try {
                let comment = normalizeAiCommentText(await callGroqWithRetry(
                    [{ role: "user", content: promptPrimary }],
                    { temperature: 0.45, max_tokens: 150, reasoning_effort: "low" },
                    3
                ));
                if (!comment) {
                    comment = normalizeAiCommentText(await callGroqWithRetry(
                        [{ role: "user", content: promptFallback }],
                        { temperature: 0.4, max_tokens: 140, reasoning_effort: "low" },
                        3
                    ));
                }
                if (!comment) {
                    comment = normalizeAiCommentText(await callGroqWithRetry(
                        [{ role: "user", content: promptLite }],
                        { temperature: 0.35, max_tokens: 120, reasoning_effort: "low" },
                        2
                    ));
                }
                if (!comment) throw new Error("empty ai comment");

                const readyPatch = {
                    aiComment: comment,
                    aiCommentStatus: "ready",
                    aiCommentUpdatedAt: new Date().toISOString()
                };
                updateEntryInState(entryId, readyPatch);
                setEntryOverlay(entryId, readyPatch);
                renderEntryHistory();
                try {
                    await setDoc(entryRef, readyPatch, { merge: true });
                    clearEntryOverlay(entryId);
                } catch (persistError) {
                    console.warn("AIコメント保存に失敗:", persistError);
                    if (!silent) {
                        alert("AIコメントは生成できましたが保存に失敗しました。通信状態をご確認ください。");
                    }
                }
                return comment;
            } catch (e) {
                const retryable = isRetryableAiCommentError(e);
                const waitMs = e?.retryAfterMs ? (e.retryAfterMs + 700) : 12000;
                const failPatch = {
                    aiComment: currentComment || "",
                    aiCommentStatus: retryable ? "retrying" : "failed",
                    aiCommentUpdatedAt: new Date().toISOString()
                };
                updateEntryInState(entryId, failPatch);
                setEntryOverlay(entryId, failPatch);
                renderEntryHistory();
                try {
                    await setDoc(entryRef, failPatch, { merge: true });
                    clearEntryOverlay(entryId);
                } catch (persistError) {
                    console.warn("AIコメント状態保存に失敗:", persistError);
                }
                if (retryable) {
                    scheduleEntryCommentRetry(entryId, currentEntry, waitMs);
                    if (!silent) {
                        const secs = Math.ceil(waitMs / 1000);
                        alert(`AIコメントは混雑中です。約${secs}秒後に自動で再試行します。`);
                    }
                }
                if (!silent && !retryable) {
                    const detail = formatErrorDetails(e);
                    alert(`AIコメントの生成に失敗しました。${detail ? `\n詳細: ${detail}` : ""}`);
                }
                const fallbackComment = currentComment || buildEntryCommentFallback(currentEntry, e);
                if (fallbackComment) {
                    const fallbackPatch = {
                        aiComment: fallbackComment,
                        aiCommentStatus: "ready",
                        aiCommentUpdatedAt: new Date().toISOString()
                    };
                    updateEntryInState(entryId, fallbackPatch);
                    setEntryOverlay(entryId, fallbackPatch);
                    renderEntryHistory();
                    try {
                        await setDoc(entryRef, fallbackPatch, { merge: true });
                        clearEntryOverlay(entryId);
                    } catch (persistError) {
                        console.warn("フォールバックコメント保存に失敗:", persistError);
                    }
                    return fallbackComment;
                }
                return "";
            } finally {
                entryCommentInFlight = false;
                syncPendingEntryComments();
            }
        }

        window.switchTool = (type) => {
            switchWorkTab("write");
            document.getElementById('tool-menu-container').classList.add('hidden');
            document.getElementById('tool-form-container').classList.remove('hidden');
            document.getElementById('current-tool-type').value = type;
            const toolDef = TOOL_DEFINITIONS[type] || TOOL_DEFINITIONS.free;
            document.getElementById('form-title').textContent = toolDef.title;
            
            // フィールド制御
            document.querySelectorAll('.field-group').forEach(el => el.classList.add('hidden'));
            toolDef.fields.forEach((fieldKey) => {
                const group = document.querySelector(`[data-fields="${fieldKey}"]`);
                if (group) group.classList.remove('hidden');
            });
            
            // 感情セレクタ初期化
            emotionSelector.innerHTML = '';
            EMOTIONS.forEach(em => {
                const btn = document.createElement('button');
                btn.className = "flex items-center gap-2 text-xs font-bold p-2 rounded bg-white border hover:bg-teal-50";
                btn.innerHTML = `<span class="w-3 h-3 rounded-full" style="background:${em.color}"></span> ${em.label}`;
                btn.onclick = () => addEmotionSlider(em);
                emotionSelector.appendChild(btn);
            });
        };

        window.showToolMenu = () => {
            switchWorkTab("write");
            document.getElementById('tool-form-container').classList.add('hidden');
            document.getElementById('tool-menu-container').classList.remove('hidden');
            activeEmotionsContainer.innerHTML = '';
        };

        window.toggleEmotionSelector = () => {
            emotionSelector.classList.toggle('hidden');
        };

        window.addEmotionSlider = (em) => {
            if(document.getElementById(`slider-${em.id}`)) return;
            const div = document.createElement('div');
            div.id = `slider-${em.id}`;
            div.className = "bg-white p-3 rounded-xl border border-gray-100 shadow-sm";
            div.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <div class="flex items-center gap-2">
                        <span class="w-3 h-3 rounded-full" style="background:${em.color}"></span>
                        <span class="text-xs font-bold text-gray-700">${em.label}</span>
                    </div>
                    <span class="text-sm font-bold text-teal-600" id="val-${em.id}">50</span>
                </div>
                <input type="range" min="0" max="100" value="50" style="color:${em.color}" 
                    oninput="document.getElementById('val-${em.id}').textContent = this.value">
            `;
            activeEmotionsContainer.appendChild(div);
            emotionSelector.classList.add('hidden');
        };

        // Set Scores Helpers
        window.setMental = (val, btn) => {
            document.getElementById('mental-val').value = val;
            btn.parentElement.querySelectorAll('button').forEach((b,i) => { b.className = `icon-btn text-3xl ${i+1===val ? 'icon-selected text-teal-400' : 'text-gray-200'}`; });
        };
        window.setPhysical = (val) => {
             document.getElementById('physical-val').value = val;
             document.getElementById('physical-hearts').querySelectorAll('button').forEach((b,i) => { b.className = `icon-btn text-2xl ${i<val ? 'text-pink-400' : 'text-gray-200'} icon-selected`; });
        };

        document.getElementById('save-entry-btn').addEventListener('click', async () => {
            const btn = document.getElementById('save-entry-btn');
            btn.disabled = true;
            
            // 感情データ収集
            const emotions = {};
            activeEmotionsContainer.querySelectorAll('[id^="slider-"]').forEach(el => {
                const id = el.id.replace('slider-', '');
                const label = EMOTIONS.find(e => e.id === id).label;
                const val = el.querySelector('input').value;
                emotions[label] = parseInt(val);
            });

            const type = document.getElementById('current-tool-type').value;
            const payload = buildEntryPayload(type);
            if (payload.validationError) {
                btn.disabled = false;
                alert(payload.validationError);
                return;
            }
            const summary = payload.summary;

            const entry = {
                date: new Date().toISOString(),
                type,
                mental: parseInt(document.getElementById('mental-val').value) * 20,
                physical: parseInt(document.getElementById('physical-val').value) * 20,
                emotions,
                summary,
                detail: payload.detail,
                aiComment: "",
                aiCommentStatus: "pending",
                aiCommentUpdatedAt: ""
            };

            try {
                const created = await addDoc(collection(db, "users", currentUser.uid, "entries"), entry);
                const createdEntry = { id: created.id, ...entry };
                state.cbtEntries = [createdEntry, ...state.cbtEntries].slice(0, 50);
                renderEntryHistory();
                updateCharts();
                const commentPromise = generateEntryComment(created.id, createdEntry, { silent: true, force: true }).catch((e) => {
                    console.error(e);
                    return "";
                });
                
                // チャットに反映
                if(Object.keys(emotions).length > 0) {
                    state.chatHistory.push({ type: 'emotions', content: emotions });
                    appendEmotionBubble(emotions);
                    await saveChat();
                }

                // Daily feedback (API同時呼び出しを避けるためローカル生成)
                const localFeedback = buildQuickDailyFeedback(createdEntry);
                if (localFeedback) {
                    document.getElementById('daily-message-text').innerText = localFeedback;
                    document.getElementById('daily-message-area').classList.remove('hidden');
                }
                commentPromise.then((aiComment) => {
                    const text = normalizeAiCommentText(aiComment);
                    if (!text) return;
                    document.getElementById('daily-message-text').innerText = text;
                    document.getElementById('daily-message-area').classList.remove('hidden');
                });

                // Clear
                activeEmotionsContainer.innerHTML = '';
                document.querySelectorAll('textarea, input[type="text"]').forEach(e => e.value = '');
                showToolMenu();

            } catch (e) {
                console.error(e);
                alert("保存エラー：記録の保存に失敗しました。");
            } finally { btn.disabled = false; }
        });

        // --- Analysis ---
        window.switchAnalysisTab = (tab) => {
            document.querySelectorAll('.analysis-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.analysis-tab[data-tab="${tab}"]`).classList.add('active');
            document.getElementById('analysis-daily').classList.toggle('hidden', tab !== 'daily');
            document.getElementById('analysis-ai').classList.toggle('hidden', tab !== 'ai');
        };

        const analyzeBtn = document.getElementById('analyze-btn');
        analyzeBtn.addEventListener('click', async () => {
            if (state.cbtEntries.length < 1) return alert("データがありません");
            analyzeBtn.disabled = true;
            analyzeBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> 分析中...';
            try {
                const input = buildAnalysisInput(state.cbtEntries);
                const result = await callAnalysis({
                    notes: input.notes,
                    scores: input.scores,
                    recentEntries: input.recent
                });
                state.patterns = normalizePatterns(result.patterns);
                state.analysisComment = result.comment || "";
                document.getElementById('wave-analysis-text').textContent = state.analysisComment || "";
                await saveAnalysis(state.patterns, state.analysisComment);
                renderPatternChart();
                if (result.source === "local") {
                    alert("AIが混雑していたため、記録内容からローカル分析で結果を作成しました。");
                }
            } catch (e) {
                console.error(e);
                const detail = formatErrorDetails(e);
                alert(`AI分析に失敗しました。しばらくしてから再度お試しください。${detail ? `\n詳細: ${detail}` : ""}`);
            } finally {
                analyzeBtn.innerHTML = '<i class="fa-solid fa-wand-magic-sparkles"></i> AI分析を実行';
                analyzeBtn.disabled = false;
            }
        });

        let charts = {};
        function resetDailyCharts() {
            if (charts.cond) {
                charts.cond.destroy();
                charts.cond = null;
            }
            if (charts.donut) {
                charts.donut.destroy();
                charts.donut = null;
            }
            document.getElementById('score-anger').textContent = "0";
            document.getElementById('score-sadness').textContent = "0";
            document.getElementById('score-anxiety').textContent = "0";
            document.getElementById('score-disgust').textContent = "0";
        }

        function updateCharts() {
            if (state.cbtEntries.length === 0) {
                resetDailyCharts();
                return;
            }
            const sorted = [...state.cbtEntries].sort((a,b) => new Date(a.date) - new Date(b.date)).slice(-7);
            const labels = sorted.map(d => { const dt = new Date(d.date); return `${dt.getMonth()+1}/${dt.getDate()}`; });

            // 1. Condition (Area Chart)
            const ctxCond = document.getElementById('conditionChart').getContext('2d');
            if(charts.cond) charts.cond.destroy();
            charts.cond = new Chart(ctxCond, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        { label: 'ココロ', data: sorted.map(d => d.mental), borderColor: '#2dd4bf', backgroundColor: 'rgba(45,212,191,0.2)', fill: true, tension: 0.4 },
                        { label: 'カラダ', data: sorted.map(d => d.physical), borderColor: '#fb923c', backgroundColor: 'rgba(251,146,60,0.2)', fill: true, tension: 0.4 }
                    ]
                },
                options: { responsive: true, maintainAspectRatio: false, scales: { y: {display:false, min:0, max:110}, x: {grid:{display:false}} }, plugins:{legend:{position:'top', align:'end'}} }
            });

            // 2. Emotion (Donut & Scores)
            const agg = { '怒り':0, '悲しみ':0, '不安':0, '嫌悪':0 };
            sorted.forEach(d => {
                if(d.emotions) Object.entries(d.emotions).forEach(([k,v]) => { if(agg[k] !== undefined) agg[k] += v; });
            });

            document.getElementById('score-anger').textContent = agg['怒り'];
            document.getElementById('score-sadness').textContent = agg['悲しみ'];
            document.getElementById('score-anxiety').textContent = agg['不安'];
            document.getElementById('score-disgust').textContent = agg['嫌悪'];

            const ctxDonut = document.getElementById('emotionDoughnutChart').getContext('2d');
            if(charts.donut) charts.donut.destroy();
            charts.donut = new Chart(ctxDonut, {
                type: 'doughnut',
                data: {
                    labels: Object.keys(agg),
                    datasets: [{ data: Object.values(agg), backgroundColor: ['#ef4444', '#3b82f6', '#a855f7', '#10b981'], borderWidth: 0 }]
                },
                options: { responsive: true, maintainAspectRatio: false, cutout: '65%', plugins: { legend: { display: false } } }
            });
        }

        function renderPatternChart() {
            const patterns = normalizePatterns(state.patterns);
            const labels = Object.keys(patterns);
            const data = Object.values(patterns);
            const ctxPat = document.getElementById('patternChart').getContext('2d');
            if (charts.pattern) charts.pattern.destroy();
            charts.pattern = new Chart(ctxPat, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{ data, backgroundColor: labels.map((_, i) => i%2===0?'#99f6e4':'#bae6fd'), borderRadius: 4, barThickness: 12 }]
                },
                options: { indexAxis: 'y', responsive: true, maintainAspectRatio: false, scales: { x: { display: false }, y: { grid: { display: false } } }, plugins: { legend: { display: false } } }
            });
        }
        
        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const target = btn.dataset.target;
                document.querySelectorAll('.view-section').forEach(el => { el.style.opacity = (el.id === target) ? '1' : '0'; el.style.pointerEvents = (el.id === target) ? 'auto' : 'none'; });
                document.querySelectorAll('.nav-btn').forEach(b => { b.classList.toggle('tab-active', b.dataset.target === target); b.classList.toggle('tab-inactive', b.dataset.target !== target); b.classList.toggle('text-teal-600', b.dataset.target === target); });
                if(target === 'view-analysis') setTimeout(updateCharts, 100);
            });
        });

        const d = new Date();
        document.getElementById('current-date').textContent = `${d.getMonth()+1}/${d.getDate()}`;
    </script>
</body>
</html>
